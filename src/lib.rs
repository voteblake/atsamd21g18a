# ! [ cfg_attr ( feature = "rt" , feature ( global_asm ) ) ] # ! [ cfg_attr ( feature = "rt" , feature ( macro_reexport ) ) ] # ! [ cfg_attr ( feature = "rt" , feature ( used ) ) ] # ! [ doc = "Peripheral access API for ATSAMD21G18A microcontrollers (generated using svd2rust v0.11.3)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.11.3/svd2rust/#peripheral-api" ] # ! [ deny ( missing_docs ) ] # ! [ deny ( warnings ) ] # ! [ allow ( non_camel_case_types ) ] # ! [ feature ( const_fn ) ] # ! [ no_std ]extern crate cortex_m ;
#[macro_reexport(default_handler, exception)]
#[cfg(feature = "rt")]
extern crate cortex_m_rt ;
extern crate bare_metal ;
extern crate vcell ;
use core::ops::Deref;
use bare_metal::Peripheral;
#[doc = r" Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 2;
pub use interrupt::Interrupt;
#[doc(hidden)]
pub mod interrupt {
    use bare_metal::Nr;
    #[cfg(feature = "rt")]
    global_asm!(
        "
                .thumb_func
                DH_TRAMPOLINE:
                    b DEFAULT_HANDLER
                "
    );
    #[cfg(feature = "rt")]
    global_asm!("\n.weak PM\nPM = DH_TRAMPOLINE\n.weak SYSCTRL\nSYSCTRL = DH_TRAMPOLINE\n.weak WDT\nWDT = DH_TRAMPOLINE\n.weak RTC\nRTC = DH_TRAMPOLINE\n.weak EIC\nEIC = DH_TRAMPOLINE\n.weak NVMCTRL\nNVMCTRL = DH_TRAMPOLINE\n.weak DMAC\nDMAC = DH_TRAMPOLINE\n.weak USB\nUSB = DH_TRAMPOLINE\n.weak EVSYS\nEVSYS = DH_TRAMPOLINE\n.weak SERCOM1\nSERCOM1 = DH_TRAMPOLINE\n.weak SERCOM2\nSERCOM2 = DH_TRAMPOLINE\n.weak SERCOM3\nSERCOM3 = DH_TRAMPOLINE\n.weak SERCOM4\nSERCOM4 = DH_TRAMPOLINE\n.weak SERCOM5\nSERCOM5 = DH_TRAMPOLINE\n.weak TCC0\nTCC0 = DH_TRAMPOLINE\n.weak TCC1\nTCC1 = DH_TRAMPOLINE\n.weak TCC2\nTCC2 = DH_TRAMPOLINE\n.weak TC4\nTC4 = DH_TRAMPOLINE\n.weak TC5\nTC5 = DH_TRAMPOLINE\n.weak ADC\nADC = DH_TRAMPOLINE\n.weak AC\nAC = DH_TRAMPOLINE\n.weak DAC\nDAC = DH_TRAMPOLINE\n.weak I2S\nI2S = DH_TRAMPOLINE");
    #[cfg(feature = "rt")]
    extern "C" {
        fn PM();
        fn SYSCTRL();
        fn WDT();
        fn RTC();
        fn EIC();
        fn NVMCTRL();
        fn DMAC();
        fn USB();
        fn EVSYS();
        fn SERCOM1();
        fn SERCOM2();
        fn SERCOM3();
        fn SERCOM4();
        fn SERCOM5();
        fn TCC0();
        fn TCC1();
        fn TCC2();
        fn TC4();
        fn TC5();
        fn ADC();
        fn AC();
        fn DAC();
        fn I2S();
    }
    #[allow(private_no_mangle_statics)]
    #[cfg(feature = "rt")]
    #[doc(hidden)]
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    #[used]
    pub static INTERRUPTS: [Option<unsafe extern "C" fn()>; 28] = [
        Some(PM),
        Some(SYSCTRL),
        Some(WDT),
        Some(RTC),
        Some(EIC),
        Some(NVMCTRL),
        Some(DMAC),
        Some(USB),
        Some(EVSYS),
        None,
        Some(SERCOM1),
        Some(SERCOM2),
        Some(SERCOM3),
        Some(SERCOM4),
        Some(SERCOM5),
        Some(TCC0),
        Some(TCC1),
        Some(TCC2),
        None,
        Some(TC4),
        Some(TC5),
        None,
        None,
        Some(ADC),
        Some(AC),
        Some(DAC),
        None,
        Some(I2S),
    ];
    #[doc = r" Enumeration of all the interrupts"]
    pub enum Interrupt {
        #[doc = "0 - PM"]
        PM,
        #[doc = "1 - SYSCTRL"]
        SYSCTRL,
        #[doc = "2 - WDT"]
        WDT,
        #[doc = "3 - RTC"]
        RTC,
        #[doc = "4 - EIC"]
        EIC,
        #[doc = "5 - NVMCTRL"]
        NVMCTRL,
        #[doc = "6 - DMAC"]
        DMAC,
        #[doc = "7 - USB"]
        USB,
        #[doc = "8 - EVSYS"]
        EVSYS,
        #[doc = "10 - SERCOM1"]
        SERCOM1,
        #[doc = "11 - SERCOM2"]
        SERCOM2,
        #[doc = "12 - SERCOM3"]
        SERCOM3,
        #[doc = "13 - SERCOM4"]
        SERCOM4,
        #[doc = "14 - SERCOM5"]
        SERCOM5,
        #[doc = "15 - TCC0"]
        TCC0,
        #[doc = "16 - TCC1"]
        TCC1,
        #[doc = "17 - TCC2"]
        TCC2,
        #[doc = "19 - TC4"]
        TC4,
        #[doc = "20 - TC5"]
        TC5,
        #[doc = "23 - ADC"]
        ADC,
        #[doc = "24 - AC"]
        AC,
        #[doc = "25 - DAC"]
        DAC,
        #[doc = "27 - I2S"]
        I2S,
    }
    unsafe impl Nr for Interrupt {
        #[inline(always)]
        fn nr(&self) -> u8 {
            match *self {
                Interrupt::PM => 0,
                Interrupt::SYSCTRL => 1,
                Interrupt::WDT => 2,
                Interrupt::RTC => 3,
                Interrupt::EIC => 4,
                Interrupt::NVMCTRL => 5,
                Interrupt::DMAC => 6,
                Interrupt::USB => 7,
                Interrupt::EVSYS => 8,
                Interrupt::SERCOM1 => 10,
                Interrupt::SERCOM2 => 11,
                Interrupt::SERCOM3 => 12,
                Interrupt::SERCOM4 => 13,
                Interrupt::SERCOM5 => 14,
                Interrupt::TCC0 => 15,
                Interrupt::TCC1 => 16,
                Interrupt::TCC2 => 17,
                Interrupt::TC4 => 19,
                Interrupt::TC5 => 20,
                Interrupt::ADC => 23,
                Interrupt::AC => 24,
                Interrupt::DAC => 25,
                Interrupt::I2S => 27,
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    macro_rules ! interrupt { ( $ NAME : ident , $ path : path , locals : { $ ( $ lvar : ident : $ lty : ident = $ lval : expr ; ) * } ) => { # [ allow ( non_snake_case ) ] mod $ NAME { pub struct Locals { $ ( pub $ lvar : $ lty , ) * } } # [ allow ( non_snake_case ) ] # [ no_mangle ] pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ( $ lvar : $ lval , ) * } ; let f : fn ( & mut self :: $ NAME :: Locals ) = $ path ; f ( unsafe { & mut LOCALS } ) ; } } ; ( $ NAME : ident , $ path : path ) => { # [ allow ( non_snake_case ) ] # [ no_mangle ] pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn ( ) = $ path ; f ( ) ; } } }
}
pub use cortex_m::peripheral::CPUID;
pub use cortex_m::peripheral::DCB;
pub use cortex_m::peripheral::DWT;
pub use cortex_m::peripheral::FPB;
pub use cortex_m::peripheral::FPU;
pub use cortex_m::peripheral::ITM;
pub use cortex_m::peripheral::MPU;
pub use cortex_m::peripheral::NVIC;
pub use cortex_m::peripheral::SCB;
pub use cortex_m::peripheral::SYST;
pub use cortex_m::peripheral::TPIU;
#[doc = "Analog Comparators"]
pub const AC: Peripheral<AC> = unsafe { Peripheral::new(1107313664) };
#[doc = "Analog Comparators"]
pub mod ac {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control A"]
        pub ctrla: CTRLA,
        #[doc = "0x01 - Control B"]
        pub ctrlb: CTRLB,
        #[doc = "0x02 - Event Control"]
        pub evctrl: EVCTRL,
        #[doc = "0x04 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x05 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x06 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        _reserved0: [u8; 1usize],
        #[doc = "0x08 - Status A"]
        pub statusa: STATUSA,
        #[doc = "0x09 - Status B"]
        pub statusb: STATUSB,
        #[doc = "0x0a - Status C"]
        pub statusc: STATUSC,
        _reserved1: [u8; 1usize],
        #[doc = "0x0c - Window Control"]
        pub winctrl: WINCTRL,
        _reserved2: [u8; 3usize],
        #[doc = "0x10 - Comparator Control n"]
        pub compctrl0: COMPCTRL,
        #[doc = "0x14 - Comparator Control n"]
        pub compctrl1: COMPCTRL,
        _reserved3: [u8; 8usize],
        #[doc = "0x20 - Scaler n"]
        pub scaler0: SCALER,
        #[doc = "0x21 - Scaler n"]
        pub scaler1: SCALER,
    }
    #[doc = "Comparator Control n"]
    pub struct COMPCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Comparator Control n"]
    pub mod compctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COMPCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SINGLER {
            bits: bool,
        }
        impl SINGLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SPEED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPEEDR {
            #[doc = "Low speed"]
            LOW,
            #[doc = "High speed"]
            HIGH,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SPEEDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SPEEDR::LOW => 0,
                    SPEEDR::HIGH => 1,
                    SPEEDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SPEEDR {
                match value {
                    0 => SPEEDR::LOW,
                    1 => SPEEDR::HIGH,
                    i => SPEEDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == SPEEDR::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == SPEEDR::HIGH
            }
        }
        #[doc = "Possible values of the field `INTSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INTSELR {
            #[doc = "Interrupt on comparator output toggle"]
            TOGGLE,
            #[doc = "Interrupt on comparator output rising"]
            RISING,
            #[doc = "Interrupt on comparator output falling"]
            FALLING,
            #[doc = "Interrupt on end of comparison (single-shot mode only)"]
            EOC,
        }
        impl INTSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    INTSELR::TOGGLE => 0,
                    INTSELR::RISING => 1,
                    INTSELR::FALLING => 2,
                    INTSELR::EOC => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> INTSELR {
                match value {
                    0 => INTSELR::TOGGLE,
                    1 => INTSELR::RISING,
                    2 => INTSELR::FALLING,
                    3 => INTSELR::EOC,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TOGGLE`"]
            #[inline(always)]
            pub fn is_toggle(&self) -> bool {
                *self == INTSELR::TOGGLE
            }
            #[doc = "Checks if the value of the field is `RISING`"]
            #[inline(always)]
            pub fn is_rising(&self) -> bool {
                *self == INTSELR::RISING
            }
            #[doc = "Checks if the value of the field is `FALLING`"]
            #[inline(always)]
            pub fn is_falling(&self) -> bool {
                *self == INTSELR::FALLING
            }
            #[doc = "Checks if the value of the field is `EOC`"]
            #[inline(always)]
            pub fn is_eoc(&self) -> bool {
                *self == INTSELR::EOC
            }
        }
        #[doc = "Possible values of the field `MUXNEG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MUXNEGR {
            #[doc = "I/O pin 0"]
            PIN0,
            #[doc = "I/O pin 1"]
            PIN1,
            #[doc = "I/O pin 2"]
            PIN2,
            #[doc = "I/O pin 3"]
            PIN3,
            #[doc = "Ground"]
            GND,
            #[doc = "VDD scaler"]
            VSCALE,
            #[doc = "Internal bandgap voltage"]
            BANDGAP,
            #[doc = "DAC output"]
            DAC,
        }
        impl MUXNEGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MUXNEGR::PIN0 => 0,
                    MUXNEGR::PIN1 => 1,
                    MUXNEGR::PIN2 => 2,
                    MUXNEGR::PIN3 => 3,
                    MUXNEGR::GND => 4,
                    MUXNEGR::VSCALE => 5,
                    MUXNEGR::BANDGAP => 6,
                    MUXNEGR::DAC => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MUXNEGR {
                match value {
                    0 => MUXNEGR::PIN0,
                    1 => MUXNEGR::PIN1,
                    2 => MUXNEGR::PIN2,
                    3 => MUXNEGR::PIN3,
                    4 => MUXNEGR::GND,
                    5 => MUXNEGR::VSCALE,
                    6 => MUXNEGR::BANDGAP,
                    7 => MUXNEGR::DAC,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `PIN0`"]
            #[inline(always)]
            pub fn is_pin0(&self) -> bool {
                *self == MUXNEGR::PIN0
            }
            #[doc = "Checks if the value of the field is `PIN1`"]
            #[inline(always)]
            pub fn is_pin1(&self) -> bool {
                *self == MUXNEGR::PIN1
            }
            #[doc = "Checks if the value of the field is `PIN2`"]
            #[inline(always)]
            pub fn is_pin2(&self) -> bool {
                *self == MUXNEGR::PIN2
            }
            #[doc = "Checks if the value of the field is `PIN3`"]
            #[inline(always)]
            pub fn is_pin3(&self) -> bool {
                *self == MUXNEGR::PIN3
            }
            #[doc = "Checks if the value of the field is `GND`"]
            #[inline(always)]
            pub fn is_gnd(&self) -> bool {
                *self == MUXNEGR::GND
            }
            #[doc = "Checks if the value of the field is `VSCALE`"]
            #[inline(always)]
            pub fn is_vscale(&self) -> bool {
                *self == MUXNEGR::VSCALE
            }
            #[doc = "Checks if the value of the field is `BANDGAP`"]
            #[inline(always)]
            pub fn is_bandgap(&self) -> bool {
                *self == MUXNEGR::BANDGAP
            }
            #[doc = "Checks if the value of the field is `DAC`"]
            #[inline(always)]
            pub fn is_dac(&self) -> bool {
                *self == MUXNEGR::DAC
            }
        }
        #[doc = "Possible values of the field `MUXPOS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MUXPOSR {
            #[doc = "I/O pin 0"]
            PIN0,
            #[doc = "I/O pin 1"]
            PIN1,
            #[doc = "I/O pin 2"]
            PIN2,
            #[doc = "I/O pin 3"]
            PIN3,
        }
        impl MUXPOSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MUXPOSR::PIN0 => 0,
                    MUXPOSR::PIN1 => 1,
                    MUXPOSR::PIN2 => 2,
                    MUXPOSR::PIN3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MUXPOSR {
                match value {
                    0 => MUXPOSR::PIN0,
                    1 => MUXPOSR::PIN1,
                    2 => MUXPOSR::PIN2,
                    3 => MUXPOSR::PIN3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `PIN0`"]
            #[inline(always)]
            pub fn is_pin0(&self) -> bool {
                *self == MUXPOSR::PIN0
            }
            #[doc = "Checks if the value of the field is `PIN1`"]
            #[inline(always)]
            pub fn is_pin1(&self) -> bool {
                *self == MUXPOSR::PIN1
            }
            #[doc = "Checks if the value of the field is `PIN2`"]
            #[inline(always)]
            pub fn is_pin2(&self) -> bool {
                *self == MUXPOSR::PIN2
            }
            #[doc = "Checks if the value of the field is `PIN3`"]
            #[inline(always)]
            pub fn is_pin3(&self) -> bool {
                *self == MUXPOSR::PIN3
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWAPR {
            bits: bool,
        }
        impl SWAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `OUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTR {
            #[doc = "The output of COMPn is not routed to the COMPn I/O port"]
            OFF,
            #[doc = "The asynchronous output of COMPn is routed to the COMPn I/O port"]
            ASYNC,
            #[doc = "The synchronous output (including filtering) of COMPn is routed to the COMPn I/O port"]
            SYNC,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl OUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    OUTR::OFF => 0,
                    OUTR::ASYNC => 1,
                    OUTR::SYNC => 2,
                    OUTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> OUTR {
                match value {
                    0 => OUTR::OFF,
                    1 => OUTR::ASYNC,
                    2 => OUTR::SYNC,
                    i => OUTR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == OUTR::OFF
            }
            #[doc = "Checks if the value of the field is `ASYNC`"]
            #[inline(always)]
            pub fn is_async(&self) -> bool {
                *self == OUTR::ASYNC
            }
            #[doc = "Checks if the value of the field is `SYNC`"]
            #[inline(always)]
            pub fn is_sync(&self) -> bool {
                *self == OUTR::SYNC
            }
        }
        #[doc = r" Value of the field"]
        pub struct HYSTR {
            bits: bool,
        }
        impl HYSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `FLEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLENR {
            #[doc = "No filtering"]
            OFF,
            #[doc = "3-bit majority function (2 of 3)"]
            MAJ3,
            #[doc = "5-bit majority function (3 of 5)"]
            MAJ5,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FLENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    FLENR::OFF => 0,
                    FLENR::MAJ3 => 1,
                    FLENR::MAJ5 => 2,
                    FLENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> FLENR {
                match value {
                    0 => FLENR::OFF,
                    1 => FLENR::MAJ3,
                    2 => FLENR::MAJ5,
                    i => FLENR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == FLENR::OFF
            }
            #[doc = "Checks if the value of the field is `MAJ3`"]
            #[inline(always)]
            pub fn is_maj3(&self) -> bool {
                *self == FLENR::MAJ3
            }
            #[doc = "Checks if the value of the field is `MAJ5`"]
            #[inline(always)]
            pub fn is_maj5(&self) -> bool {
                *self == FLENR::MAJ5
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SINGLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SINGLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPEED`"]
        pub enum SPEEDW {
            #[doc = "Low speed"]
            LOW,
            #[doc = "High speed"]
            HIGH,
        }
        impl SPEEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SPEEDW::LOW => 0,
                    SPEEDW::HIGH => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPEEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPEEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPEEDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(SPEEDW::LOW)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(SPEEDW::HIGH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INTSEL`"]
        pub enum INTSELW {
            #[doc = "Interrupt on comparator output toggle"]
            TOGGLE,
            #[doc = "Interrupt on comparator output rising"]
            RISING,
            #[doc = "Interrupt on comparator output falling"]
            FALLING,
            #[doc = "Interrupt on end of comparison (single-shot mode only)"]
            EOC,
        }
        impl INTSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    INTSELW::TOGGLE => 0,
                    INTSELW::RISING => 1,
                    INTSELW::FALLING => 2,
                    INTSELW::EOC => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INTSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Interrupt on comparator output toggle"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(INTSELW::TOGGLE)
            }
            #[doc = "Interrupt on comparator output rising"]
            #[inline(always)]
            pub fn rising(self) -> &'a mut W {
                self.variant(INTSELW::RISING)
            }
            #[doc = "Interrupt on comparator output falling"]
            #[inline(always)]
            pub fn falling(self) -> &'a mut W {
                self.variant(INTSELW::FALLING)
            }
            #[doc = "Interrupt on end of comparison (single-shot mode only)"]
            #[inline(always)]
            pub fn eoc(self) -> &'a mut W {
                self.variant(INTSELW::EOC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MUXNEG`"]
        pub enum MUXNEGW {
            #[doc = "I/O pin 0"]
            PIN0,
            #[doc = "I/O pin 1"]
            PIN1,
            #[doc = "I/O pin 2"]
            PIN2,
            #[doc = "I/O pin 3"]
            PIN3,
            #[doc = "Ground"]
            GND,
            #[doc = "VDD scaler"]
            VSCALE,
            #[doc = "Internal bandgap voltage"]
            BANDGAP,
            #[doc = "DAC output"]
            DAC,
        }
        impl MUXNEGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MUXNEGW::PIN0 => 0,
                    MUXNEGW::PIN1 => 1,
                    MUXNEGW::PIN2 => 2,
                    MUXNEGW::PIN3 => 3,
                    MUXNEGW::GND => 4,
                    MUXNEGW::VSCALE => 5,
                    MUXNEGW::BANDGAP => 6,
                    MUXNEGW::DAC => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MUXNEGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MUXNEGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MUXNEGW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "I/O pin 0"]
            #[inline(always)]
            pub fn pin0(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN0)
            }
            #[doc = "I/O pin 1"]
            #[inline(always)]
            pub fn pin1(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN1)
            }
            #[doc = "I/O pin 2"]
            #[inline(always)]
            pub fn pin2(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN2)
            }
            #[doc = "I/O pin 3"]
            #[inline(always)]
            pub fn pin3(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN3)
            }
            #[doc = "Ground"]
            #[inline(always)]
            pub fn gnd(self) -> &'a mut W {
                self.variant(MUXNEGW::GND)
            }
            #[doc = "VDD scaler"]
            #[inline(always)]
            pub fn vscale(self) -> &'a mut W {
                self.variant(MUXNEGW::VSCALE)
            }
            #[doc = "Internal bandgap voltage"]
            #[inline(always)]
            pub fn bandgap(self) -> &'a mut W {
                self.variant(MUXNEGW::BANDGAP)
            }
            #[doc = "DAC output"]
            #[inline(always)]
            pub fn dac(self) -> &'a mut W {
                self.variant(MUXNEGW::DAC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MUXPOS`"]
        pub enum MUXPOSW {
            #[doc = "I/O pin 0"]
            PIN0,
            #[doc = "I/O pin 1"]
            PIN1,
            #[doc = "I/O pin 2"]
            PIN2,
            #[doc = "I/O pin 3"]
            PIN3,
        }
        impl MUXPOSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MUXPOSW::PIN0 => 0,
                    MUXPOSW::PIN1 => 1,
                    MUXPOSW::PIN2 => 2,
                    MUXPOSW::PIN3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MUXPOSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MUXPOSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MUXPOSW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "I/O pin 0"]
            #[inline(always)]
            pub fn pin0(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN0)
            }
            #[doc = "I/O pin 1"]
            #[inline(always)]
            pub fn pin1(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN1)
            }
            #[doc = "I/O pin 2"]
            #[inline(always)]
            pub fn pin2(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN2)
            }
            #[doc = "I/O pin 3"]
            #[inline(always)]
            pub fn pin3(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUT`"]
        pub enum OUTW {
            #[doc = "The output of COMPn is not routed to the COMPn I/O port"]
            OFF,
            #[doc = "The asynchronous output of COMPn is routed to the COMPn I/O port"]
            ASYNC,
            #[doc = "The synchronous output (including filtering) of COMPn is routed to the COMPn I/O port"]
            SYNC,
        }
        impl OUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OUTW::OFF => 0,
                    OUTW::ASYNC => 1,
                    OUTW::SYNC => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "The output of COMPn is not routed to the COMPn I/O port"]
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(OUTW::OFF)
            }
            #[doc = "The asynchronous output of COMPn is routed to the COMPn I/O port"]
            #[inline(always)]
            pub fn async(self) -> &'a mut W {
                self.variant(OUTW::ASYNC)
            }
            #[doc = "The synchronous output (including filtering) of COMPn is routed to the COMPn I/O port"]
            #[inline(always)]
            pub fn sync(self) -> &'a mut W {
                self.variant(OUTW::SYNC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLEN`"]
        pub enum FLENW {
            #[doc = "No filtering"]
            OFF,
            #[doc = "3-bit majority function (2 of 3)"]
            MAJ3,
            #[doc = "5-bit majority function (3 of 5)"]
            MAJ5,
        }
        impl FLENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FLENW::OFF => 0,
                    FLENW::MAJ3 => 1,
                    FLENW::MAJ5 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FLENW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No filtering"]
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(FLENW::OFF)
            }
            #[doc = "3-bit majority function (2 of 3)"]
            #[inline(always)]
            pub fn maj3(self) -> &'a mut W {
                self.variant(FLENW::MAJ3)
            }
            #[doc = "5-bit majority function (3 of 5)"]
            #[inline(always)]
            pub fn maj5(self) -> &'a mut W {
                self.variant(FLENW::MAJ5)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 1 - Single-Shot Mode"]
            #[inline(always)]
            pub fn single(&self) -> SINGLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SINGLER { bits }
            }
            #[doc = "Bits 2:3 - Speed Selection"]
            #[inline(always)]
            pub fn speed(&self) -> SPEEDR {
                SPEEDR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 5:6 - Interrupt Selection"]
            #[inline(always)]
            pub fn intsel(&self) -> INTSELR {
                INTSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:10 - Negative Input Mux Selection"]
            #[inline(always)]
            pub fn muxneg(&self) -> MUXNEGR {
                MUXNEGR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:13 - Positive Input Mux Selection"]
            #[inline(always)]
            pub fn muxpos(&self) -> MUXPOSR {
                MUXPOSR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 15 - Swap Inputs and Invert"]
            #[inline(always)]
            pub fn swap(&self) -> SWAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWAPR { bits }
            }
            #[doc = "Bits 16:17 - Output"]
            #[inline(always)]
            pub fn out(&self) -> OUTR {
                OUTR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 19 - Hysteresis Enable"]
            #[inline(always)]
            pub fn hyst(&self) -> HYSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HYSTR { bits }
            }
            #[doc = "Bits 24:26 - Filter Length"]
            #[inline(always)]
            pub fn flen(&self) -> FLENR {
                FLENR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 1 - Single-Shot Mode"]
            #[inline(always)]
            pub fn single(&mut self) -> _SINGLEW {
                _SINGLEW { w: self }
            }
            #[doc = "Bits 2:3 - Speed Selection"]
            #[inline(always)]
            pub fn speed(&mut self) -> _SPEEDW {
                _SPEEDW { w: self }
            }
            #[doc = "Bits 5:6 - Interrupt Selection"]
            #[inline(always)]
            pub fn intsel(&mut self) -> _INTSELW {
                _INTSELW { w: self }
            }
            #[doc = "Bits 8:10 - Negative Input Mux Selection"]
            #[inline(always)]
            pub fn muxneg(&mut self) -> _MUXNEGW {
                _MUXNEGW { w: self }
            }
            #[doc = "Bits 12:13 - Positive Input Mux Selection"]
            #[inline(always)]
            pub fn muxpos(&mut self) -> _MUXPOSW {
                _MUXPOSW { w: self }
            }
            #[doc = "Bit 15 - Swap Inputs and Invert"]
            #[inline(always)]
            pub fn swap(&mut self) -> _SWAPW {
                _SWAPW { w: self }
            }
            #[doc = "Bits 16:17 - Output"]
            #[inline(always)]
            pub fn out(&mut self) -> _OUTW {
                _OUTW { w: self }
            }
            #[doc = "Bit 19 - Hysteresis Enable"]
            #[inline(always)]
            pub fn hyst(&mut self) -> _HYSTW {
                _HYSTW { w: self }
            }
            #[doc = "Bits 24:26 - Filter Length"]
            #[inline(always)]
            pub fn flen(&mut self) -> _FLENW {
                _FLENW { w: self }
            }
        }
    }
    #[doc = "Control A"]
    pub struct CTRLA {
        register: VolatileCell<u8>,
    }
    #[doc = "Control A"]
    pub mod ctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LPMUXR {
            bits: bool,
        }
        impl LPMUXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LPMUXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LPMUXW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 7 - Low-Power Mux"]
            #[inline(always)]
            pub fn lpmux(&self) -> LPMUXR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                LPMUXR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 7 - Low-Power Mux"]
            #[inline(always)]
            pub fn lpmux(&mut self) -> _LPMUXW {
                _LPMUXW { w: self }
            }
        }
    }
    #[doc = "Control B"]
    pub struct CTRLB {
        register: VolatileCell<u8>,
    }
    #[doc = "Control B"]
    pub mod ctrlb {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLB {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _START0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _START0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _START1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _START1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comparator 0 Start Comparison"]
            #[inline(always)]
            pub fn start0(&mut self) -> _START0W {
                _START0W { w: self }
            }
            #[doc = "Bit 1 - Comparator 1 Start Comparison"]
            #[inline(always)]
            pub fn start1(&mut self) -> _START1W {
                _START1W { w: self }
            }
        }
    }
    #[doc = "Event Control"]
    pub struct EVCTRL {
        register: VolatileCell<u16>,
    }
    #[doc = "Event Control"]
    pub mod evctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::EVCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMPEO0R {
            bits: bool,
        }
        impl COMPEO0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMPEO1R {
            bits: bool,
        }
        impl COMPEO1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINEO0R {
            bits: bool,
        }
        impl WINEO0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMPEI0R {
            bits: bool,
        }
        impl COMPEI0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMPEI1R {
            bits: bool,
        }
        impl COMPEI1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPEO0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPEO0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPEO1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPEO1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINEO0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINEO0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPEI0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPEI0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPEI1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPEI1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0 Event Output Enable"]
            #[inline(always)]
            pub fn compeo0(&self) -> COMPEO0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                COMPEO0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1 Event Output Enable"]
            #[inline(always)]
            pub fn compeo1(&self) -> COMPEO1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                COMPEO1R { bits }
            }
            #[doc = "Bit 4 - Window 0 Event Output Enable"]
            #[inline(always)]
            pub fn wineo0(&self) -> WINEO0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                WINEO0R { bits }
            }
            #[doc = "Bit 8 - Comparator 0 Event Input"]
            #[inline(always)]
            pub fn compei0(&self) -> COMPEI0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                COMPEI0R { bits }
            }
            #[doc = "Bit 9 - Comparator 1 Event Input"]
            #[inline(always)]
            pub fn compei1(&self) -> COMPEI1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                COMPEI1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comparator 0 Event Output Enable"]
            #[inline(always)]
            pub fn compeo0(&mut self) -> _COMPEO0W {
                _COMPEO0W { w: self }
            }
            #[doc = "Bit 1 - Comparator 1 Event Output Enable"]
            #[inline(always)]
            pub fn compeo1(&mut self) -> _COMPEO1W {
                _COMPEO1W { w: self }
            }
            #[doc = "Bit 4 - Window 0 Event Output Enable"]
            #[inline(always)]
            pub fn wineo0(&mut self) -> _WINEO0W {
                _WINEO0W { w: self }
            }
            #[doc = "Bit 8 - Comparator 0 Event Input"]
            #[inline(always)]
            pub fn compei0(&mut self) -> _COMPEI0W {
                _COMPEI0W { w: self }
            }
            #[doc = "Bit 9 - Comparator 1 Event Input"]
            #[inline(always)]
            pub fn compei1(&mut self) -> _COMPEI1W {
                _COMPEI1W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMP0R {
            bits: bool,
        }
        impl COMP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMP1R {
            bits: bool,
        }
        impl COMP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WIN0R {
            bits: bool,
        }
        impl WIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0 Interrupt Enable"]
            #[inline(always)]
            pub fn comp0(&self) -> COMP0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                COMP0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1 Interrupt Enable"]
            #[inline(always)]
            pub fn comp1(&self) -> COMP1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                COMP1R { bits }
            }
            #[doc = "Bit 4 - Window 0 Interrupt Enable"]
            #[inline(always)]
            pub fn win0(&self) -> WIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WIN0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comparator 0 Interrupt Enable"]
            #[inline(always)]
            pub fn comp0(&mut self) -> _COMP0W {
                _COMP0W { w: self }
            }
            #[doc = "Bit 1 - Comparator 1 Interrupt Enable"]
            #[inline(always)]
            pub fn comp1(&mut self) -> _COMP1W {
                _COMP1W { w: self }
            }
            #[doc = "Bit 4 - Window 0 Interrupt Enable"]
            #[inline(always)]
            pub fn win0(&mut self) -> _WIN0W {
                _WIN0W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMP0R {
            bits: bool,
        }
        impl COMP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMP1R {
            bits: bool,
        }
        impl COMP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WIN0R {
            bits: bool,
        }
        impl WIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0 Interrupt Enable"]
            #[inline(always)]
            pub fn comp0(&self) -> COMP0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                COMP0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1 Interrupt Enable"]
            #[inline(always)]
            pub fn comp1(&self) -> COMP1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                COMP1R { bits }
            }
            #[doc = "Bit 4 - Window 0 Interrupt Enable"]
            #[inline(always)]
            pub fn win0(&self) -> WIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WIN0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comparator 0 Interrupt Enable"]
            #[inline(always)]
            pub fn comp0(&mut self) -> _COMP0W {
                _COMP0W { w: self }
            }
            #[doc = "Bit 1 - Comparator 1 Interrupt Enable"]
            #[inline(always)]
            pub fn comp1(&mut self) -> _COMP1W {
                _COMP1W { w: self }
            }
            #[doc = "Bit 4 - Window 0 Interrupt Enable"]
            #[inline(always)]
            pub fn win0(&mut self) -> _WIN0W {
                _WIN0W { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMP0R {
            bits: bool,
        }
        impl COMP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMP1R {
            bits: bool,
        }
        impl COMP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WIN0R {
            bits: bool,
        }
        impl WIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0"]
            #[inline(always)]
            pub fn comp0(&self) -> COMP0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                COMP0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1"]
            #[inline(always)]
            pub fn comp1(&self) -> COMP1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                COMP1R { bits }
            }
            #[doc = "Bit 4 - Window 0"]
            #[inline(always)]
            pub fn win0(&self) -> WIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WIN0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comparator 0"]
            #[inline(always)]
            pub fn comp0(&mut self) -> _COMP0W {
                _COMP0W { w: self }
            }
            #[doc = "Bit 1 - Comparator 1"]
            #[inline(always)]
            pub fn comp1(&mut self) -> _COMP1W {
                _COMP1W { w: self }
            }
            #[doc = "Bit 4 - Window 0"]
            #[inline(always)]
            pub fn win0(&mut self) -> _WIN0W {
                _WIN0W { w: self }
            }
        }
    }
    #[doc = "Scaler n"]
    pub struct SCALER {
        register: VolatileCell<u8>,
    }
    #[doc = "Scaler n"]
    pub mod scaler {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::SCALER {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u8,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:5 - Scaler Value"]
            #[inline(always)]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                VALUER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - Scaler Value"]
            #[inline(always)]
            pub fn value(&mut self) -> _VALUEW {
                _VALUEW { w: self }
            }
        }
    }
    #[doc = "Status A"]
    pub struct STATUSA {
        register: VolatileCell<u8>,
    }
    #[doc = "Status A"]
    pub mod statusa {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUSA {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATE0R {
            bits: bool,
        }
        impl STATE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATE1R {
            bits: bool,
        }
        impl STATE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `WSTATE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WSTATE0R {
            #[doc = "Signal is above window"]
            ABOVE,
            #[doc = "Signal is inside window"]
            INSIDE,
            #[doc = "Signal is below window"]
            BELOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl WSTATE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    WSTATE0R::ABOVE => 0,
                    WSTATE0R::INSIDE => 1,
                    WSTATE0R::BELOW => 2,
                    WSTATE0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> WSTATE0R {
                match value {
                    0 => WSTATE0R::ABOVE,
                    1 => WSTATE0R::INSIDE,
                    2 => WSTATE0R::BELOW,
                    i => WSTATE0R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `ABOVE`"]
            #[inline(always)]
            pub fn is_above(&self) -> bool {
                *self == WSTATE0R::ABOVE
            }
            #[doc = "Checks if the value of the field is `INSIDE`"]
            #[inline(always)]
            pub fn is_inside(&self) -> bool {
                *self == WSTATE0R::INSIDE
            }
            #[doc = "Checks if the value of the field is `BELOW`"]
            #[inline(always)]
            pub fn is_below(&self) -> bool {
                *self == WSTATE0R::BELOW
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0 Current State"]
            #[inline(always)]
            pub fn state0(&self) -> STATE0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STATE0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1 Current State"]
            #[inline(always)]
            pub fn state1(&self) -> STATE1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STATE1R { bits }
            }
            #[doc = "Bits 4:5 - Window 0 Current State"]
            #[inline(always)]
            pub fn wstate0(&self) -> WSTATE0R {
                WSTATE0R::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
    }
    #[doc = "Status B"]
    pub struct STATUSB {
        register: VolatileCell<u8>,
    }
    #[doc = "Status B"]
    pub mod statusb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUSB {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct READY0R {
            bits: bool,
        }
        impl READY0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct READY1R {
            bits: bool,
        }
        impl READY1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0 Ready"]
            #[inline(always)]
            pub fn ready0(&self) -> READY0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                READY0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1 Ready"]
            #[inline(always)]
            pub fn ready1(&self) -> READY1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                READY1R { bits }
            }
            #[doc = "Bit 7 - Synchronization Busy"]
            #[inline(always)]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCBUSYR { bits }
            }
        }
    }
    #[doc = "Status C"]
    pub struct STATUSC {
        register: VolatileCell<u8>,
    }
    #[doc = "Status C"]
    pub mod statusc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUSC {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATE0R {
            bits: bool,
        }
        impl STATE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATE1R {
            bits: bool,
        }
        impl STATE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `WSTATE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WSTATE0R {
            #[doc = "Signal is above window"]
            ABOVE,
            #[doc = "Signal is inside window"]
            INSIDE,
            #[doc = "Signal is below window"]
            BELOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl WSTATE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    WSTATE0R::ABOVE => 0,
                    WSTATE0R::INSIDE => 1,
                    WSTATE0R::BELOW => 2,
                    WSTATE0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> WSTATE0R {
                match value {
                    0 => WSTATE0R::ABOVE,
                    1 => WSTATE0R::INSIDE,
                    2 => WSTATE0R::BELOW,
                    i => WSTATE0R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `ABOVE`"]
            #[inline(always)]
            pub fn is_above(&self) -> bool {
                *self == WSTATE0R::ABOVE
            }
            #[doc = "Checks if the value of the field is `INSIDE`"]
            #[inline(always)]
            pub fn is_inside(&self) -> bool {
                *self == WSTATE0R::INSIDE
            }
            #[doc = "Checks if the value of the field is `BELOW`"]
            #[inline(always)]
            pub fn is_below(&self) -> bool {
                *self == WSTATE0R::BELOW
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0 Current State"]
            #[inline(always)]
            pub fn state0(&self) -> STATE0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STATE0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1 Current State"]
            #[inline(always)]
            pub fn state1(&self) -> STATE1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STATE1R { bits }
            }
            #[doc = "Bits 4:5 - Window 0 Current State"]
            #[inline(always)]
            pub fn wstate0(&self) -> WSTATE0R {
                WSTATE0R::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
    }
    #[doc = "Window Control"]
    pub struct WINCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Window Control"]
    pub mod winctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::WINCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WEN0R {
            bits: bool,
        }
        impl WEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `WINTSEL0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WINTSEL0R {
            #[doc = "Interrupt on signal above window"]
            ABOVE,
            #[doc = "Interrupt on signal inside window"]
            INSIDE,
            #[doc = "Interrupt on signal below window"]
            BELOW,
            #[doc = "Interrupt on signal outside window"]
            OUTSIDE,
        }
        impl WINTSEL0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    WINTSEL0R::ABOVE => 0,
                    WINTSEL0R::INSIDE => 1,
                    WINTSEL0R::BELOW => 2,
                    WINTSEL0R::OUTSIDE => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> WINTSEL0R {
                match value {
                    0 => WINTSEL0R::ABOVE,
                    1 => WINTSEL0R::INSIDE,
                    2 => WINTSEL0R::BELOW,
                    3 => WINTSEL0R::OUTSIDE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ABOVE`"]
            #[inline(always)]
            pub fn is_above(&self) -> bool {
                *self == WINTSEL0R::ABOVE
            }
            #[doc = "Checks if the value of the field is `INSIDE`"]
            #[inline(always)]
            pub fn is_inside(&self) -> bool {
                *self == WINTSEL0R::INSIDE
            }
            #[doc = "Checks if the value of the field is `BELOW`"]
            #[inline(always)]
            pub fn is_below(&self) -> bool {
                *self == WINTSEL0R::BELOW
            }
            #[doc = "Checks if the value of the field is `OUTSIDE`"]
            #[inline(always)]
            pub fn is_outside(&self) -> bool {
                *self == WINTSEL0R::OUTSIDE
            }
        }
        #[doc = r" Proxy"]
        pub struct _WEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WINTSEL0`"]
        pub enum WINTSEL0W {
            #[doc = "Interrupt on signal above window"]
            ABOVE,
            #[doc = "Interrupt on signal inside window"]
            INSIDE,
            #[doc = "Interrupt on signal below window"]
            BELOW,
            #[doc = "Interrupt on signal outside window"]
            OUTSIDE,
        }
        impl WINTSEL0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WINTSEL0W::ABOVE => 0,
                    WINTSEL0W::INSIDE => 1,
                    WINTSEL0W::BELOW => 2,
                    WINTSEL0W::OUTSIDE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINTSEL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINTSEL0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WINTSEL0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Interrupt on signal above window"]
            #[inline(always)]
            pub fn above(self) -> &'a mut W {
                self.variant(WINTSEL0W::ABOVE)
            }
            #[doc = "Interrupt on signal inside window"]
            #[inline(always)]
            pub fn inside(self) -> &'a mut W {
                self.variant(WINTSEL0W::INSIDE)
            }
            #[doc = "Interrupt on signal below window"]
            #[inline(always)]
            pub fn below(self) -> &'a mut W {
                self.variant(WINTSEL0W::BELOW)
            }
            #[doc = "Interrupt on signal outside window"]
            #[inline(always)]
            pub fn outside(self) -> &'a mut W {
                self.variant(WINTSEL0W::OUTSIDE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Window 0 Mode Enable"]
            #[inline(always)]
            pub fn wen0(&self) -> WEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WEN0R { bits }
            }
            #[doc = "Bits 1:2 - Window 0 Interrupt Selection"]
            #[inline(always)]
            pub fn wintsel0(&self) -> WINTSEL0R {
                WINTSEL0R::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Window 0 Mode Enable"]
            #[inline(always)]
            pub fn wen0(&mut self) -> _WEN0W {
                _WEN0W { w: self }
            }
            #[doc = "Bits 1:2 - Window 0 Interrupt Selection"]
            #[inline(always)]
            pub fn wintsel0(&mut self) -> _WINTSEL0W {
                _WINTSEL0W { w: self }
            }
        }
    }
}
#[doc = "Analog Comparators"]
pub struct AC {
    register_block: ac::RegisterBlock,
}
impl Deref for AC {
    type Target = ac::RegisterBlock;
    fn deref(&self) -> &ac::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Analog Digital Converter"]
pub const ADC: Peripheral<ADC> = unsafe { Peripheral::new(1107312640) };
#[doc = "Analog Digital Converter"]
pub mod adc {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control A"]
        pub ctrla: CTRLA,
        #[doc = "0x01 - Reference Control"]
        pub refctrl: REFCTRL,
        #[doc = "0x02 - Average Control"]
        pub avgctrl: AVGCTRL,
        #[doc = "0x03 - Sampling Time Control"]
        pub sampctrl: SAMPCTRL,
        #[doc = "0x04 - Control B"]
        pub ctrlb: CTRLB,
        _reserved0: [u8; 2usize],
        #[doc = "0x08 - Window Monitor Control"]
        pub winctrl: WINCTRL,
        _reserved1: [u8; 3usize],
        #[doc = "0x0c - Software Trigger"]
        pub swtrig: SWTRIG,
        _reserved2: [u8; 3usize],
        #[doc = "0x10 - Input Control"]
        pub inputctrl: INPUTCTRL,
        #[doc = "0x14 - Event Control"]
        pub evctrl: EVCTRL,
        _reserved3: [u8; 1usize],
        #[doc = "0x16 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x17 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x18 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        #[doc = "0x19 - Status"]
        pub status: STATUS,
        #[doc = "0x1a - Result"]
        pub result: RESULT,
        #[doc = "0x1c - Window Monitor Lower Threshold"]
        pub winlt: WINLT,
        _reserved4: [u8; 2usize],
        #[doc = "0x20 - Window Monitor Upper Threshold"]
        pub winut: WINUT,
        _reserved5: [u8; 2usize],
        #[doc = "0x24 - Gain Correction"]
        pub gaincorr: GAINCORR,
        #[doc = "0x26 - Offset Correction"]
        pub offsetcorr: OFFSETCORR,
        #[doc = "0x28 - Calibration"]
        pub calib: CALIB,
        #[doc = "0x2a - Debug Control"]
        pub dbgctrl: DBGCTRL,
    }
    #[doc = "Average Control"]
    pub struct AVGCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Average Control"]
    pub mod avgctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::AVGCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SAMPLENUM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SAMPLENUMR {
            #[doc = "1 sample"]
            _1,
            #[doc = "2 samples"]
            _2,
            #[doc = "4 samples"]
            _4,
            #[doc = "8 samples"]
            _8,
            #[doc = "16 samples"]
            _16,
            #[doc = "32 samples"]
            _32,
            #[doc = "64 samples"]
            _64,
            #[doc = "128 samples"]
            _128,
            #[doc = "256 samples"]
            _256,
            #[doc = "512 samples"]
            _512,
            #[doc = "1024 samples"]
            _1024,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SAMPLENUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SAMPLENUMR::_1 => 0,
                    SAMPLENUMR::_2 => 1,
                    SAMPLENUMR::_4 => 2,
                    SAMPLENUMR::_8 => 3,
                    SAMPLENUMR::_16 => 4,
                    SAMPLENUMR::_32 => 5,
                    SAMPLENUMR::_64 => 6,
                    SAMPLENUMR::_128 => 7,
                    SAMPLENUMR::_256 => 8,
                    SAMPLENUMR::_512 => 9,
                    SAMPLENUMR::_1024 => 10,
                    SAMPLENUMR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SAMPLENUMR {
                match value {
                    0 => SAMPLENUMR::_1,
                    1 => SAMPLENUMR::_2,
                    2 => SAMPLENUMR::_4,
                    3 => SAMPLENUMR::_8,
                    4 => SAMPLENUMR::_16,
                    5 => SAMPLENUMR::_32,
                    6 => SAMPLENUMR::_64,
                    7 => SAMPLENUMR::_128,
                    8 => SAMPLENUMR::_256,
                    9 => SAMPLENUMR::_512,
                    10 => SAMPLENUMR::_1024,
                    i => SAMPLENUMR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_1`"]
            #[inline(always)]
            pub fn is_1(&self) -> bool {
                *self == SAMPLENUMR::_1
            }
            #[doc = "Checks if the value of the field is `_2`"]
            #[inline(always)]
            pub fn is_2(&self) -> bool {
                *self == SAMPLENUMR::_2
            }
            #[doc = "Checks if the value of the field is `_4`"]
            #[inline(always)]
            pub fn is_4(&self) -> bool {
                *self == SAMPLENUMR::_4
            }
            #[doc = "Checks if the value of the field is `_8`"]
            #[inline(always)]
            pub fn is_8(&self) -> bool {
                *self == SAMPLENUMR::_8
            }
            #[doc = "Checks if the value of the field is `_16`"]
            #[inline(always)]
            pub fn is_16(&self) -> bool {
                *self == SAMPLENUMR::_16
            }
            #[doc = "Checks if the value of the field is `_32`"]
            #[inline(always)]
            pub fn is_32(&self) -> bool {
                *self == SAMPLENUMR::_32
            }
            #[doc = "Checks if the value of the field is `_64`"]
            #[inline(always)]
            pub fn is_64(&self) -> bool {
                *self == SAMPLENUMR::_64
            }
            #[doc = "Checks if the value of the field is `_128`"]
            #[inline(always)]
            pub fn is_128(&self) -> bool {
                *self == SAMPLENUMR::_128
            }
            #[doc = "Checks if the value of the field is `_256`"]
            #[inline(always)]
            pub fn is_256(&self) -> bool {
                *self == SAMPLENUMR::_256
            }
            #[doc = "Checks if the value of the field is `_512`"]
            #[inline(always)]
            pub fn is_512(&self) -> bool {
                *self == SAMPLENUMR::_512
            }
            #[doc = "Checks if the value of the field is `_1024`"]
            #[inline(always)]
            pub fn is_1024(&self) -> bool {
                *self == SAMPLENUMR::_1024
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADJRESR {
            bits: u8,
        }
        impl ADJRESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `SAMPLENUM`"]
        pub enum SAMPLENUMW {
            #[doc = "1 sample"]
            _1,
            #[doc = "2 samples"]
            _2,
            #[doc = "4 samples"]
            _4,
            #[doc = "8 samples"]
            _8,
            #[doc = "16 samples"]
            _16,
            #[doc = "32 samples"]
            _32,
            #[doc = "64 samples"]
            _64,
            #[doc = "128 samples"]
            _128,
            #[doc = "256 samples"]
            _256,
            #[doc = "512 samples"]
            _512,
            #[doc = "1024 samples"]
            _1024,
        }
        impl SAMPLENUMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SAMPLENUMW::_1 => 0,
                    SAMPLENUMW::_2 => 1,
                    SAMPLENUMW::_4 => 2,
                    SAMPLENUMW::_8 => 3,
                    SAMPLENUMW::_16 => 4,
                    SAMPLENUMW::_32 => 5,
                    SAMPLENUMW::_64 => 6,
                    SAMPLENUMW::_128 => 7,
                    SAMPLENUMW::_256 => 8,
                    SAMPLENUMW::_512 => 9,
                    SAMPLENUMW::_1024 => 10,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SAMPLENUMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SAMPLENUMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SAMPLENUMW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "1 sample"]
            #[inline(always)]
            pub fn _1(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_1)
            }
            #[doc = "2 samples"]
            #[inline(always)]
            pub fn _2(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_2)
            }
            #[doc = "4 samples"]
            #[inline(always)]
            pub fn _4(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_4)
            }
            #[doc = "8 samples"]
            #[inline(always)]
            pub fn _8(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_8)
            }
            #[doc = "16 samples"]
            #[inline(always)]
            pub fn _16(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_16)
            }
            #[doc = "32 samples"]
            #[inline(always)]
            pub fn _32(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_32)
            }
            #[doc = "64 samples"]
            #[inline(always)]
            pub fn _64(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_64)
            }
            #[doc = "128 samples"]
            #[inline(always)]
            pub fn _128(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_128)
            }
            #[doc = "256 samples"]
            #[inline(always)]
            pub fn _256(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_256)
            }
            #[doc = "512 samples"]
            #[inline(always)]
            pub fn _512(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_512)
            }
            #[doc = "1024 samples"]
            #[inline(always)]
            pub fn _1024(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_1024)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADJRESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADJRESW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:3 - Number of Samples to be Collected"]
            #[inline(always)]
            pub fn samplenum(&self) -> SAMPLENUMR {
                SAMPLENUMR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bits 4:6 - Adjusting Result / Division Coefficient"]
            #[inline(always)]
            pub fn adjres(&self) -> ADJRESR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                ADJRESR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Number of Samples to be Collected"]
            #[inline(always)]
            pub fn samplenum(&mut self) -> _SAMPLENUMW {
                _SAMPLENUMW { w: self }
            }
            #[doc = "Bits 4:6 - Adjusting Result / Division Coefficient"]
            #[inline(always)]
            pub fn adjres(&mut self) -> _ADJRESW {
                _ADJRESW { w: self }
            }
        }
    }
    #[doc = "Calibration"]
    pub struct CALIB {
        register: VolatileCell<u16>,
    }
    #[doc = "Calibration"]
    pub mod calib {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::CALIB {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LINEARITY_CALR {
            bits: u8,
        }
        impl LINEARITY_CALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BIAS_CALR {
            bits: u8,
        }
        impl BIAS_CALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LINEARITY_CALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LINEARITY_CALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIAS_CALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIAS_CALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:7 - Linearity Calibration Value"]
            #[inline(always)]
            pub fn linearity_cal(&self) -> LINEARITY_CALR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                LINEARITY_CALR { bits }
            }
            #[doc = "Bits 8:10 - Bias Calibration Value"]
            #[inline(always)]
            pub fn bias_cal(&self) -> BIAS_CALR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                BIAS_CALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Linearity Calibration Value"]
            #[inline(always)]
            pub fn linearity_cal(&mut self) -> _LINEARITY_CALW {
                _LINEARITY_CALW { w: self }
            }
            #[doc = "Bits 8:10 - Bias Calibration Value"]
            #[inline(always)]
            pub fn bias_cal(&mut self) -> _BIAS_CALW {
                _BIAS_CALW { w: self }
            }
        }
    }
    #[doc = "Control A"]
    pub struct CTRLA {
        register: VolatileCell<u8>,
    }
    #[doc = "Control A"]
    pub mod ctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SWRSTR { bits }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RUNSTDBYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
        }
    }
    #[doc = "Control B"]
    pub struct CTRLB {
        register: VolatileCell<u16>,
    }
    #[doc = "Control B"]
    pub mod ctrlb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::CTRLB {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIFFMODER {
            bits: bool,
        }
        impl DIFFMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LEFTADJR {
            bits: bool,
        }
        impl LEFTADJR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FREERUNR {
            bits: bool,
        }
        impl FREERUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CORRENR {
            bits: bool,
        }
        impl CORRENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `RESSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESSELR {
            #[doc = "12-bit result"]
            _12BIT,
            #[doc = "For averaging mode output"]
            _16BIT,
            #[doc = "10-bit result"]
            _10BIT,
            #[doc = "8-bit result"]
            _8BIT,
        }
        impl RESSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    RESSELR::_12BIT => 0,
                    RESSELR::_16BIT => 1,
                    RESSELR::_10BIT => 2,
                    RESSELR::_8BIT => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> RESSELR {
                match value {
                    0 => RESSELR::_12BIT,
                    1 => RESSELR::_16BIT,
                    2 => RESSELR::_10BIT,
                    3 => RESSELR::_8BIT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_12BIT`"]
            #[inline(always)]
            pub fn is_12bit(&self) -> bool {
                *self == RESSELR::_12BIT
            }
            #[doc = "Checks if the value of the field is `_16BIT`"]
            #[inline(always)]
            pub fn is_16bit(&self) -> bool {
                *self == RESSELR::_16BIT
            }
            #[doc = "Checks if the value of the field is `_10BIT`"]
            #[inline(always)]
            pub fn is_10bit(&self) -> bool {
                *self == RESSELR::_10BIT
            }
            #[doc = "Checks if the value of the field is `_8BIT`"]
            #[inline(always)]
            pub fn is_8bit(&self) -> bool {
                *self == RESSELR::_8BIT
            }
        }
        #[doc = "Possible values of the field `PRESCALER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PRESCALERR {
            #[doc = "Peripheral clock divided by 4"]
            DIV4,
            #[doc = "Peripheral clock divided by 8"]
            DIV8,
            #[doc = "Peripheral clock divided by 16"]
            DIV16,
            #[doc = "Peripheral clock divided by 32"]
            DIV32,
            #[doc = "Peripheral clock divided by 64"]
            DIV64,
            #[doc = "Peripheral clock divided by 128"]
            DIV128,
            #[doc = "Peripheral clock divided by 256"]
            DIV256,
            #[doc = "Peripheral clock divided by 512"]
            DIV512,
        }
        impl PRESCALERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    PRESCALERR::DIV4 => 0,
                    PRESCALERR::DIV8 => 1,
                    PRESCALERR::DIV16 => 2,
                    PRESCALERR::DIV32 => 3,
                    PRESCALERR::DIV64 => 4,
                    PRESCALERR::DIV128 => 5,
                    PRESCALERR::DIV256 => 6,
                    PRESCALERR::DIV512 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> PRESCALERR {
                match value {
                    0 => PRESCALERR::DIV4,
                    1 => PRESCALERR::DIV8,
                    2 => PRESCALERR::DIV16,
                    3 => PRESCALERR::DIV32,
                    4 => PRESCALERR::DIV64,
                    5 => PRESCALERR::DIV128,
                    6 => PRESCALERR::DIV256,
                    7 => PRESCALERR::DIV512,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == PRESCALERR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == PRESCALERR::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == PRESCALERR::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == PRESCALERR::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == PRESCALERR::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == PRESCALERR::DIV128
            }
            #[doc = "Checks if the value of the field is `DIV256`"]
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == PRESCALERR::DIV256
            }
            #[doc = "Checks if the value of the field is `DIV512`"]
            #[inline(always)]
            pub fn is_div512(&self) -> bool {
                *self == PRESCALERR::DIV512
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIFFMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIFFMODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LEFTADJW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LEFTADJW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FREERUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FREERUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CORRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CORRENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RESSEL`"]
        pub enum RESSELW {
            #[doc = "12-bit result"]
            _12BIT,
            #[doc = "For averaging mode output"]
            _16BIT,
            #[doc = "10-bit result"]
            _10BIT,
            #[doc = "8-bit result"]
            _8BIT,
        }
        impl RESSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RESSELW::_12BIT => 0,
                    RESSELW::_16BIT => 1,
                    RESSELW::_10BIT => 2,
                    RESSELW::_8BIT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RESSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "12-bit result"]
            #[inline(always)]
            pub fn _12bit(self) -> &'a mut W {
                self.variant(RESSELW::_12BIT)
            }
            #[doc = "For averaging mode output"]
            #[inline(always)]
            pub fn _16bit(self) -> &'a mut W {
                self.variant(RESSELW::_16BIT)
            }
            #[doc = "10-bit result"]
            #[inline(always)]
            pub fn _10bit(self) -> &'a mut W {
                self.variant(RESSELW::_10BIT)
            }
            #[doc = "8-bit result"]
            #[inline(always)]
            pub fn _8bit(self) -> &'a mut W {
                self.variant(RESSELW::_8BIT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PRESCALER`"]
        pub enum PRESCALERW {
            #[doc = "Peripheral clock divided by 4"]
            DIV4,
            #[doc = "Peripheral clock divided by 8"]
            DIV8,
            #[doc = "Peripheral clock divided by 16"]
            DIV16,
            #[doc = "Peripheral clock divided by 32"]
            DIV32,
            #[doc = "Peripheral clock divided by 64"]
            DIV64,
            #[doc = "Peripheral clock divided by 128"]
            DIV128,
            #[doc = "Peripheral clock divided by 256"]
            DIV256,
            #[doc = "Peripheral clock divided by 512"]
            DIV512,
        }
        impl PRESCALERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PRESCALERW::DIV4 => 0,
                    PRESCALERW::DIV8 => 1,
                    PRESCALERW::DIV16 => 2,
                    PRESCALERW::DIV32 => 3,
                    PRESCALERW::DIV64 => 4,
                    PRESCALERW::DIV128 => 5,
                    PRESCALERW::DIV256 => 6,
                    PRESCALERW::DIV512 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRESCALERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRESCALERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PRESCALERW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Peripheral clock divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV4)
            }
            #[doc = "Peripheral clock divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV8)
            }
            #[doc = "Peripheral clock divided by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV16)
            }
            #[doc = "Peripheral clock divided by 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV32)
            }
            #[doc = "Peripheral clock divided by 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV64)
            }
            #[doc = "Peripheral clock divided by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV128)
            }
            #[doc = "Peripheral clock divided by 256"]
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV256)
            }
            #[doc = "Peripheral clock divided by 512"]
            #[inline(always)]
            pub fn div512(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV512)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Differential Mode"]
            #[inline(always)]
            pub fn diffmode(&self) -> DIFFMODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                DIFFMODER { bits }
            }
            #[doc = "Bit 1 - Left-Adjusted Result"]
            #[inline(always)]
            pub fn leftadj(&self) -> LEFTADJR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                LEFTADJR { bits }
            }
            #[doc = "Bit 2 - Free Running Mode"]
            #[inline(always)]
            pub fn freerun(&self) -> FREERUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                FREERUNR { bits }
            }
            #[doc = "Bit 3 - Digital Correction Logic Enabled"]
            #[inline(always)]
            pub fn corren(&self) -> CORRENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                CORRENR { bits }
            }
            #[doc = "Bits 4:5 - Conversion Result Resolution"]
            #[inline(always)]
            pub fn ressel(&self) -> RESSELR {
                RESSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 8:10 - Prescaler Configuration"]
            #[inline(always)]
            pub fn prescaler(&self) -> PRESCALERR {
                PRESCALERR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Differential Mode"]
            #[inline(always)]
            pub fn diffmode(&mut self) -> _DIFFMODEW {
                _DIFFMODEW { w: self }
            }
            #[doc = "Bit 1 - Left-Adjusted Result"]
            #[inline(always)]
            pub fn leftadj(&mut self) -> _LEFTADJW {
                _LEFTADJW { w: self }
            }
            #[doc = "Bit 2 - Free Running Mode"]
            #[inline(always)]
            pub fn freerun(&mut self) -> _FREERUNW {
                _FREERUNW { w: self }
            }
            #[doc = "Bit 3 - Digital Correction Logic Enabled"]
            #[inline(always)]
            pub fn corren(&mut self) -> _CORRENW {
                _CORRENW { w: self }
            }
            #[doc = "Bits 4:5 - Conversion Result Resolution"]
            #[inline(always)]
            pub fn ressel(&mut self) -> _RESSELW {
                _RESSELW { w: self }
            }
            #[doc = "Bits 8:10 - Prescaler Configuration"]
            #[inline(always)]
            pub fn prescaler(&mut self) -> _PRESCALERW {
                _PRESCALERW { w: self }
            }
        }
    }
    #[doc = "Debug Control"]
    pub struct DBGCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Debug Control"]
    pub mod dbgctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::DBGCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBGRUNR {
            bits: bool,
        }
        impl DBGRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBGRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBGRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Debug Run"]
            #[inline(always)]
            pub fn dbgrun(&self) -> DBGRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DBGRUNR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Debug Run"]
            #[inline(always)]
            pub fn dbgrun(&mut self) -> _DBGRUNW {
                _DBGRUNW { w: self }
            }
        }
    }
    #[doc = "Event Control"]
    pub struct EVCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Event Control"]
    pub mod evctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::EVCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTEIR {
            bits: bool,
        }
        impl STARTEIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCEIR {
            bits: bool,
        }
        impl SYNCEIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESRDYEOR {
            bits: bool,
        }
        impl RESRDYEOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINMONEOR {
            bits: bool,
        }
        impl WINMONEOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTEIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTEIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCEIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCEIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESRDYEOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESRDYEOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINMONEOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINMONEOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Start Conversion Event In"]
            #[inline(always)]
            pub fn startei(&self) -> STARTEIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STARTEIR { bits }
            }
            #[doc = "Bit 1 - Synchronization Event In"]
            #[inline(always)]
            pub fn syncei(&self) -> SYNCEIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCEIR { bits }
            }
            #[doc = "Bit 4 - Result Ready Event Out"]
            #[inline(always)]
            pub fn resrdyeo(&self) -> RESRDYEOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RESRDYEOR { bits }
            }
            #[doc = "Bit 5 - Window Monitor Event Out"]
            #[inline(always)]
            pub fn winmoneo(&self) -> WINMONEOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WINMONEOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Start Conversion Event In"]
            #[inline(always)]
            pub fn startei(&mut self) -> _STARTEIW {
                _STARTEIW { w: self }
            }
            #[doc = "Bit 1 - Synchronization Event In"]
            #[inline(always)]
            pub fn syncei(&mut self) -> _SYNCEIW {
                _SYNCEIW { w: self }
            }
            #[doc = "Bit 4 - Result Ready Event Out"]
            #[inline(always)]
            pub fn resrdyeo(&mut self) -> _RESRDYEOW {
                _RESRDYEOW { w: self }
            }
            #[doc = "Bit 5 - Window Monitor Event Out"]
            #[inline(always)]
            pub fn winmoneo(&mut self) -> _WINMONEOW {
                _WINMONEOW { w: self }
            }
        }
    }
    #[doc = "Gain Correction"]
    pub struct GAINCORR {
        register: VolatileCell<u16>,
    }
    #[doc = "Gain Correction"]
    pub mod gaincorr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::GAINCORR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct GAINCORRR {
            bits: u16,
        }
        impl GAINCORRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _GAINCORRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GAINCORRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:11 - Gain Correction Value"]
            #[inline(always)]
            pub fn gaincorr(&self) -> GAINCORRR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                GAINCORRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Gain Correction Value"]
            #[inline(always)]
            pub fn gaincorr(&mut self) -> _GAINCORRW {
                _GAINCORRW { w: self }
            }
        }
    }
    #[doc = "Input Control"]
    pub struct INPUTCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Input Control"]
    pub mod inputctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INPUTCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MUXPOS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MUXPOSR {
            #[doc = "ADC AIN0 Pin"]
            PIN0,
            #[doc = "ADC AIN1 Pin"]
            PIN1,
            #[doc = "ADC AIN2 Pin"]
            PIN2,
            #[doc = "ADC AIN3 Pin"]
            PIN3,
            #[doc = "ADC AIN4 Pin"]
            PIN4,
            #[doc = "ADC AIN5 Pin"]
            PIN5,
            #[doc = "ADC AIN6 Pin"]
            PIN6,
            #[doc = "ADC AIN7 Pin"]
            PIN7,
            #[doc = "ADC AIN8 Pin"]
            PIN8,
            #[doc = "ADC AIN9 Pin"]
            PIN9,
            #[doc = "ADC AIN10 Pin"]
            PIN10,
            #[doc = "ADC AIN11 Pin"]
            PIN11,
            #[doc = "ADC AIN12 Pin"]
            PIN12,
            #[doc = "ADC AIN13 Pin"]
            PIN13,
            #[doc = "ADC AIN14 Pin"]
            PIN14,
            #[doc = "ADC AIN15 Pin"]
            PIN15,
            #[doc = "ADC AIN16 Pin"]
            PIN16,
            #[doc = "ADC AIN17 Pin"]
            PIN17,
            #[doc = "ADC AIN18 Pin"]
            PIN18,
            #[doc = "ADC AIN19 Pin"]
            PIN19,
            #[doc = "Temperature Reference"]
            TEMP,
            #[doc = "Bandgap Voltage"]
            BANDGAP,
            #[doc = "1/4  Scaled Core Supply"]
            SCALEDCOREVCC,
            #[doc = "1/4  Scaled I/O Supply"]
            SCALEDIOVCC,
            #[doc = "DAC Output"]
            DAC,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MUXPOSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MUXPOSR::PIN0 => 0,
                    MUXPOSR::PIN1 => 1,
                    MUXPOSR::PIN2 => 2,
                    MUXPOSR::PIN3 => 3,
                    MUXPOSR::PIN4 => 4,
                    MUXPOSR::PIN5 => 5,
                    MUXPOSR::PIN6 => 6,
                    MUXPOSR::PIN7 => 7,
                    MUXPOSR::PIN8 => 8,
                    MUXPOSR::PIN9 => 9,
                    MUXPOSR::PIN10 => 10,
                    MUXPOSR::PIN11 => 11,
                    MUXPOSR::PIN12 => 12,
                    MUXPOSR::PIN13 => 13,
                    MUXPOSR::PIN14 => 14,
                    MUXPOSR::PIN15 => 15,
                    MUXPOSR::PIN16 => 16,
                    MUXPOSR::PIN17 => 17,
                    MUXPOSR::PIN18 => 18,
                    MUXPOSR::PIN19 => 19,
                    MUXPOSR::TEMP => 24,
                    MUXPOSR::BANDGAP => 25,
                    MUXPOSR::SCALEDCOREVCC => 26,
                    MUXPOSR::SCALEDIOVCC => 27,
                    MUXPOSR::DAC => 28,
                    MUXPOSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MUXPOSR {
                match value {
                    0 => MUXPOSR::PIN0,
                    1 => MUXPOSR::PIN1,
                    2 => MUXPOSR::PIN2,
                    3 => MUXPOSR::PIN3,
                    4 => MUXPOSR::PIN4,
                    5 => MUXPOSR::PIN5,
                    6 => MUXPOSR::PIN6,
                    7 => MUXPOSR::PIN7,
                    8 => MUXPOSR::PIN8,
                    9 => MUXPOSR::PIN9,
                    10 => MUXPOSR::PIN10,
                    11 => MUXPOSR::PIN11,
                    12 => MUXPOSR::PIN12,
                    13 => MUXPOSR::PIN13,
                    14 => MUXPOSR::PIN14,
                    15 => MUXPOSR::PIN15,
                    16 => MUXPOSR::PIN16,
                    17 => MUXPOSR::PIN17,
                    18 => MUXPOSR::PIN18,
                    19 => MUXPOSR::PIN19,
                    24 => MUXPOSR::TEMP,
                    25 => MUXPOSR::BANDGAP,
                    26 => MUXPOSR::SCALEDCOREVCC,
                    27 => MUXPOSR::SCALEDIOVCC,
                    28 => MUXPOSR::DAC,
                    i => MUXPOSR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIN0`"]
            #[inline(always)]
            pub fn is_pin0(&self) -> bool {
                *self == MUXPOSR::PIN0
            }
            #[doc = "Checks if the value of the field is `PIN1`"]
            #[inline(always)]
            pub fn is_pin1(&self) -> bool {
                *self == MUXPOSR::PIN1
            }
            #[doc = "Checks if the value of the field is `PIN2`"]
            #[inline(always)]
            pub fn is_pin2(&self) -> bool {
                *self == MUXPOSR::PIN2
            }
            #[doc = "Checks if the value of the field is `PIN3`"]
            #[inline(always)]
            pub fn is_pin3(&self) -> bool {
                *self == MUXPOSR::PIN3
            }
            #[doc = "Checks if the value of the field is `PIN4`"]
            #[inline(always)]
            pub fn is_pin4(&self) -> bool {
                *self == MUXPOSR::PIN4
            }
            #[doc = "Checks if the value of the field is `PIN5`"]
            #[inline(always)]
            pub fn is_pin5(&self) -> bool {
                *self == MUXPOSR::PIN5
            }
            #[doc = "Checks if the value of the field is `PIN6`"]
            #[inline(always)]
            pub fn is_pin6(&self) -> bool {
                *self == MUXPOSR::PIN6
            }
            #[doc = "Checks if the value of the field is `PIN7`"]
            #[inline(always)]
            pub fn is_pin7(&self) -> bool {
                *self == MUXPOSR::PIN7
            }
            #[doc = "Checks if the value of the field is `PIN8`"]
            #[inline(always)]
            pub fn is_pin8(&self) -> bool {
                *self == MUXPOSR::PIN8
            }
            #[doc = "Checks if the value of the field is `PIN9`"]
            #[inline(always)]
            pub fn is_pin9(&self) -> bool {
                *self == MUXPOSR::PIN9
            }
            #[doc = "Checks if the value of the field is `PIN10`"]
            #[inline(always)]
            pub fn is_pin10(&self) -> bool {
                *self == MUXPOSR::PIN10
            }
            #[doc = "Checks if the value of the field is `PIN11`"]
            #[inline(always)]
            pub fn is_pin11(&self) -> bool {
                *self == MUXPOSR::PIN11
            }
            #[doc = "Checks if the value of the field is `PIN12`"]
            #[inline(always)]
            pub fn is_pin12(&self) -> bool {
                *self == MUXPOSR::PIN12
            }
            #[doc = "Checks if the value of the field is `PIN13`"]
            #[inline(always)]
            pub fn is_pin13(&self) -> bool {
                *self == MUXPOSR::PIN13
            }
            #[doc = "Checks if the value of the field is `PIN14`"]
            #[inline(always)]
            pub fn is_pin14(&self) -> bool {
                *self == MUXPOSR::PIN14
            }
            #[doc = "Checks if the value of the field is `PIN15`"]
            #[inline(always)]
            pub fn is_pin15(&self) -> bool {
                *self == MUXPOSR::PIN15
            }
            #[doc = "Checks if the value of the field is `PIN16`"]
            #[inline(always)]
            pub fn is_pin16(&self) -> bool {
                *self == MUXPOSR::PIN16
            }
            #[doc = "Checks if the value of the field is `PIN17`"]
            #[inline(always)]
            pub fn is_pin17(&self) -> bool {
                *self == MUXPOSR::PIN17
            }
            #[doc = "Checks if the value of the field is `PIN18`"]
            #[inline(always)]
            pub fn is_pin18(&self) -> bool {
                *self == MUXPOSR::PIN18
            }
            #[doc = "Checks if the value of the field is `PIN19`"]
            #[inline(always)]
            pub fn is_pin19(&self) -> bool {
                *self == MUXPOSR::PIN19
            }
            #[doc = "Checks if the value of the field is `TEMP`"]
            #[inline(always)]
            pub fn is_temp(&self) -> bool {
                *self == MUXPOSR::TEMP
            }
            #[doc = "Checks if the value of the field is `BANDGAP`"]
            #[inline(always)]
            pub fn is_bandgap(&self) -> bool {
                *self == MUXPOSR::BANDGAP
            }
            #[doc = "Checks if the value of the field is `SCALEDCOREVCC`"]
            #[inline(always)]
            pub fn is_scaledcorevcc(&self) -> bool {
                *self == MUXPOSR::SCALEDCOREVCC
            }
            #[doc = "Checks if the value of the field is `SCALEDIOVCC`"]
            #[inline(always)]
            pub fn is_scalediovcc(&self) -> bool {
                *self == MUXPOSR::SCALEDIOVCC
            }
            #[doc = "Checks if the value of the field is `DAC`"]
            #[inline(always)]
            pub fn is_dac(&self) -> bool {
                *self == MUXPOSR::DAC
            }
        }
        #[doc = "Possible values of the field `MUXNEG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MUXNEGR {
            #[doc = "ADC AIN0 Pin"]
            PIN0,
            #[doc = "ADC AIN1 Pin"]
            PIN1,
            #[doc = "ADC AIN2 Pin"]
            PIN2,
            #[doc = "ADC AIN3 Pin"]
            PIN3,
            #[doc = "ADC AIN4 Pin"]
            PIN4,
            #[doc = "ADC AIN5 Pin"]
            PIN5,
            #[doc = "ADC AIN6 Pin"]
            PIN6,
            #[doc = "ADC AIN7 Pin"]
            PIN7,
            #[doc = "Internal Ground"]
            GND,
            #[doc = "I/O Ground"]
            IOGND,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MUXNEGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MUXNEGR::PIN0 => 0,
                    MUXNEGR::PIN1 => 1,
                    MUXNEGR::PIN2 => 2,
                    MUXNEGR::PIN3 => 3,
                    MUXNEGR::PIN4 => 4,
                    MUXNEGR::PIN5 => 5,
                    MUXNEGR::PIN6 => 6,
                    MUXNEGR::PIN7 => 7,
                    MUXNEGR::GND => 24,
                    MUXNEGR::IOGND => 25,
                    MUXNEGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MUXNEGR {
                match value {
                    0 => MUXNEGR::PIN0,
                    1 => MUXNEGR::PIN1,
                    2 => MUXNEGR::PIN2,
                    3 => MUXNEGR::PIN3,
                    4 => MUXNEGR::PIN4,
                    5 => MUXNEGR::PIN5,
                    6 => MUXNEGR::PIN6,
                    7 => MUXNEGR::PIN7,
                    24 => MUXNEGR::GND,
                    25 => MUXNEGR::IOGND,
                    i => MUXNEGR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIN0`"]
            #[inline(always)]
            pub fn is_pin0(&self) -> bool {
                *self == MUXNEGR::PIN0
            }
            #[doc = "Checks if the value of the field is `PIN1`"]
            #[inline(always)]
            pub fn is_pin1(&self) -> bool {
                *self == MUXNEGR::PIN1
            }
            #[doc = "Checks if the value of the field is `PIN2`"]
            #[inline(always)]
            pub fn is_pin2(&self) -> bool {
                *self == MUXNEGR::PIN2
            }
            #[doc = "Checks if the value of the field is `PIN3`"]
            #[inline(always)]
            pub fn is_pin3(&self) -> bool {
                *self == MUXNEGR::PIN3
            }
            #[doc = "Checks if the value of the field is `PIN4`"]
            #[inline(always)]
            pub fn is_pin4(&self) -> bool {
                *self == MUXNEGR::PIN4
            }
            #[doc = "Checks if the value of the field is `PIN5`"]
            #[inline(always)]
            pub fn is_pin5(&self) -> bool {
                *self == MUXNEGR::PIN5
            }
            #[doc = "Checks if the value of the field is `PIN6`"]
            #[inline(always)]
            pub fn is_pin6(&self) -> bool {
                *self == MUXNEGR::PIN6
            }
            #[doc = "Checks if the value of the field is `PIN7`"]
            #[inline(always)]
            pub fn is_pin7(&self) -> bool {
                *self == MUXNEGR::PIN7
            }
            #[doc = "Checks if the value of the field is `GND`"]
            #[inline(always)]
            pub fn is_gnd(&self) -> bool {
                *self == MUXNEGR::GND
            }
            #[doc = "Checks if the value of the field is `IOGND`"]
            #[inline(always)]
            pub fn is_iognd(&self) -> bool {
                *self == MUXNEGR::IOGND
            }
        }
        #[doc = r" Value of the field"]
        pub struct INPUTSCANR {
            bits: u8,
        }
        impl INPUTSCANR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct INPUTOFFSETR {
            bits: u8,
        }
        impl INPUTOFFSETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `GAIN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GAINR {
            #[doc = "1x"]
            _1X,
            #[doc = "2x"]
            _2X,
            #[doc = "4x"]
            _4X,
            #[doc = "8x"]
            _8X,
            #[doc = "16x"]
            _16X,
            #[doc = "1/2x"]
            DIV2,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl GAINR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    GAINR::_1X => 0,
                    GAINR::_2X => 1,
                    GAINR::_4X => 2,
                    GAINR::_8X => 3,
                    GAINR::_16X => 4,
                    GAINR::DIV2 => 15,
                    GAINR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> GAINR {
                match value {
                    0 => GAINR::_1X,
                    1 => GAINR::_2X,
                    2 => GAINR::_4X,
                    3 => GAINR::_8X,
                    4 => GAINR::_16X,
                    15 => GAINR::DIV2,
                    i => GAINR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_1X`"]
            #[inline(always)]
            pub fn is_1x(&self) -> bool {
                *self == GAINR::_1X
            }
            #[doc = "Checks if the value of the field is `_2X`"]
            #[inline(always)]
            pub fn is_2x(&self) -> bool {
                *self == GAINR::_2X
            }
            #[doc = "Checks if the value of the field is `_4X`"]
            #[inline(always)]
            pub fn is_4x(&self) -> bool {
                *self == GAINR::_4X
            }
            #[doc = "Checks if the value of the field is `_8X`"]
            #[inline(always)]
            pub fn is_8x(&self) -> bool {
                *self == GAINR::_8X
            }
            #[doc = "Checks if the value of the field is `_16X`"]
            #[inline(always)]
            pub fn is_16x(&self) -> bool {
                *self == GAINR::_16X
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == GAINR::DIV2
            }
        }
        #[doc = "Values that can be written to the field `MUXPOS`"]
        pub enum MUXPOSW {
            #[doc = "ADC AIN0 Pin"]
            PIN0,
            #[doc = "ADC AIN1 Pin"]
            PIN1,
            #[doc = "ADC AIN2 Pin"]
            PIN2,
            #[doc = "ADC AIN3 Pin"]
            PIN3,
            #[doc = "ADC AIN4 Pin"]
            PIN4,
            #[doc = "ADC AIN5 Pin"]
            PIN5,
            #[doc = "ADC AIN6 Pin"]
            PIN6,
            #[doc = "ADC AIN7 Pin"]
            PIN7,
            #[doc = "ADC AIN8 Pin"]
            PIN8,
            #[doc = "ADC AIN9 Pin"]
            PIN9,
            #[doc = "ADC AIN10 Pin"]
            PIN10,
            #[doc = "ADC AIN11 Pin"]
            PIN11,
            #[doc = "ADC AIN12 Pin"]
            PIN12,
            #[doc = "ADC AIN13 Pin"]
            PIN13,
            #[doc = "ADC AIN14 Pin"]
            PIN14,
            #[doc = "ADC AIN15 Pin"]
            PIN15,
            #[doc = "ADC AIN16 Pin"]
            PIN16,
            #[doc = "ADC AIN17 Pin"]
            PIN17,
            #[doc = "ADC AIN18 Pin"]
            PIN18,
            #[doc = "ADC AIN19 Pin"]
            PIN19,
            #[doc = "Temperature Reference"]
            TEMP,
            #[doc = "Bandgap Voltage"]
            BANDGAP,
            #[doc = "1/4  Scaled Core Supply"]
            SCALEDCOREVCC,
            #[doc = "1/4  Scaled I/O Supply"]
            SCALEDIOVCC,
            #[doc = "DAC Output"]
            DAC,
        }
        impl MUXPOSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MUXPOSW::PIN0 => 0,
                    MUXPOSW::PIN1 => 1,
                    MUXPOSW::PIN2 => 2,
                    MUXPOSW::PIN3 => 3,
                    MUXPOSW::PIN4 => 4,
                    MUXPOSW::PIN5 => 5,
                    MUXPOSW::PIN6 => 6,
                    MUXPOSW::PIN7 => 7,
                    MUXPOSW::PIN8 => 8,
                    MUXPOSW::PIN9 => 9,
                    MUXPOSW::PIN10 => 10,
                    MUXPOSW::PIN11 => 11,
                    MUXPOSW::PIN12 => 12,
                    MUXPOSW::PIN13 => 13,
                    MUXPOSW::PIN14 => 14,
                    MUXPOSW::PIN15 => 15,
                    MUXPOSW::PIN16 => 16,
                    MUXPOSW::PIN17 => 17,
                    MUXPOSW::PIN18 => 18,
                    MUXPOSW::PIN19 => 19,
                    MUXPOSW::TEMP => 24,
                    MUXPOSW::BANDGAP => 25,
                    MUXPOSW::SCALEDCOREVCC => 26,
                    MUXPOSW::SCALEDIOVCC => 27,
                    MUXPOSW::DAC => 28,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MUXPOSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MUXPOSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MUXPOSW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "ADC AIN0 Pin"]
            #[inline(always)]
            pub fn pin0(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN0)
            }
            #[doc = "ADC AIN1 Pin"]
            #[inline(always)]
            pub fn pin1(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN1)
            }
            #[doc = "ADC AIN2 Pin"]
            #[inline(always)]
            pub fn pin2(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN2)
            }
            #[doc = "ADC AIN3 Pin"]
            #[inline(always)]
            pub fn pin3(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN3)
            }
            #[doc = "ADC AIN4 Pin"]
            #[inline(always)]
            pub fn pin4(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN4)
            }
            #[doc = "ADC AIN5 Pin"]
            #[inline(always)]
            pub fn pin5(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN5)
            }
            #[doc = "ADC AIN6 Pin"]
            #[inline(always)]
            pub fn pin6(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN6)
            }
            #[doc = "ADC AIN7 Pin"]
            #[inline(always)]
            pub fn pin7(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN7)
            }
            #[doc = "ADC AIN8 Pin"]
            #[inline(always)]
            pub fn pin8(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN8)
            }
            #[doc = "ADC AIN9 Pin"]
            #[inline(always)]
            pub fn pin9(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN9)
            }
            #[doc = "ADC AIN10 Pin"]
            #[inline(always)]
            pub fn pin10(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN10)
            }
            #[doc = "ADC AIN11 Pin"]
            #[inline(always)]
            pub fn pin11(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN11)
            }
            #[doc = "ADC AIN12 Pin"]
            #[inline(always)]
            pub fn pin12(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN12)
            }
            #[doc = "ADC AIN13 Pin"]
            #[inline(always)]
            pub fn pin13(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN13)
            }
            #[doc = "ADC AIN14 Pin"]
            #[inline(always)]
            pub fn pin14(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN14)
            }
            #[doc = "ADC AIN15 Pin"]
            #[inline(always)]
            pub fn pin15(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN15)
            }
            #[doc = "ADC AIN16 Pin"]
            #[inline(always)]
            pub fn pin16(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN16)
            }
            #[doc = "ADC AIN17 Pin"]
            #[inline(always)]
            pub fn pin17(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN17)
            }
            #[doc = "ADC AIN18 Pin"]
            #[inline(always)]
            pub fn pin18(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN18)
            }
            #[doc = "ADC AIN19 Pin"]
            #[inline(always)]
            pub fn pin19(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN19)
            }
            #[doc = "Temperature Reference"]
            #[inline(always)]
            pub fn temp(self) -> &'a mut W {
                self.variant(MUXPOSW::TEMP)
            }
            #[doc = "Bandgap Voltage"]
            #[inline(always)]
            pub fn bandgap(self) -> &'a mut W {
                self.variant(MUXPOSW::BANDGAP)
            }
            #[doc = "1/4 Scaled Core Supply"]
            #[inline(always)]
            pub fn scaledcorevcc(self) -> &'a mut W {
                self.variant(MUXPOSW::SCALEDCOREVCC)
            }
            #[doc = "1/4 Scaled I/O Supply"]
            #[inline(always)]
            pub fn scalediovcc(self) -> &'a mut W {
                self.variant(MUXPOSW::SCALEDIOVCC)
            }
            #[doc = "DAC Output"]
            #[inline(always)]
            pub fn dac(self) -> &'a mut W {
                self.variant(MUXPOSW::DAC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MUXNEG`"]
        pub enum MUXNEGW {
            #[doc = "ADC AIN0 Pin"]
            PIN0,
            #[doc = "ADC AIN1 Pin"]
            PIN1,
            #[doc = "ADC AIN2 Pin"]
            PIN2,
            #[doc = "ADC AIN3 Pin"]
            PIN3,
            #[doc = "ADC AIN4 Pin"]
            PIN4,
            #[doc = "ADC AIN5 Pin"]
            PIN5,
            #[doc = "ADC AIN6 Pin"]
            PIN6,
            #[doc = "ADC AIN7 Pin"]
            PIN7,
            #[doc = "Internal Ground"]
            GND,
            #[doc = "I/O Ground"]
            IOGND,
        }
        impl MUXNEGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MUXNEGW::PIN0 => 0,
                    MUXNEGW::PIN1 => 1,
                    MUXNEGW::PIN2 => 2,
                    MUXNEGW::PIN3 => 3,
                    MUXNEGW::PIN4 => 4,
                    MUXNEGW::PIN5 => 5,
                    MUXNEGW::PIN6 => 6,
                    MUXNEGW::PIN7 => 7,
                    MUXNEGW::GND => 24,
                    MUXNEGW::IOGND => 25,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MUXNEGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MUXNEGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MUXNEGW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "ADC AIN0 Pin"]
            #[inline(always)]
            pub fn pin0(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN0)
            }
            #[doc = "ADC AIN1 Pin"]
            #[inline(always)]
            pub fn pin1(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN1)
            }
            #[doc = "ADC AIN2 Pin"]
            #[inline(always)]
            pub fn pin2(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN2)
            }
            #[doc = "ADC AIN3 Pin"]
            #[inline(always)]
            pub fn pin3(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN3)
            }
            #[doc = "ADC AIN4 Pin"]
            #[inline(always)]
            pub fn pin4(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN4)
            }
            #[doc = "ADC AIN5 Pin"]
            #[inline(always)]
            pub fn pin5(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN5)
            }
            #[doc = "ADC AIN6 Pin"]
            #[inline(always)]
            pub fn pin6(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN6)
            }
            #[doc = "ADC AIN7 Pin"]
            #[inline(always)]
            pub fn pin7(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN7)
            }
            #[doc = "Internal Ground"]
            #[inline(always)]
            pub fn gnd(self) -> &'a mut W {
                self.variant(MUXNEGW::GND)
            }
            #[doc = "I/O Ground"]
            #[inline(always)]
            pub fn iognd(self) -> &'a mut W {
                self.variant(MUXNEGW::IOGND)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INPUTSCANW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INPUTSCANW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INPUTOFFSETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INPUTOFFSETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GAIN`"]
        pub enum GAINW {
            #[doc = "1x"]
            _1X,
            #[doc = "2x"]
            _2X,
            #[doc = "4x"]
            _4X,
            #[doc = "8x"]
            _8X,
            #[doc = "16x"]
            _16X,
            #[doc = "1/2x"]
            DIV2,
        }
        impl GAINW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    GAINW::_1X => 0,
                    GAINW::_2X => 1,
                    GAINW::_4X => 2,
                    GAINW::_8X => 3,
                    GAINW::_16X => 4,
                    GAINW::DIV2 => 15,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GAINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GAINW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: GAINW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "1x"]
            #[inline(always)]
            pub fn _1x(self) -> &'a mut W {
                self.variant(GAINW::_1X)
            }
            #[doc = "2x"]
            #[inline(always)]
            pub fn _2x(self) -> &'a mut W {
                self.variant(GAINW::_2X)
            }
            #[doc = "4x"]
            #[inline(always)]
            pub fn _4x(self) -> &'a mut W {
                self.variant(GAINW::_4X)
            }
            #[doc = "8x"]
            #[inline(always)]
            pub fn _8x(self) -> &'a mut W {
                self.variant(GAINW::_8X)
            }
            #[doc = "16x"]
            #[inline(always)]
            pub fn _16x(self) -> &'a mut W {
                self.variant(GAINW::_16X)
            }
            #[doc = "1/2x"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(GAINW::DIV2)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - Positive Mux Input Selection"]
            #[inline(always)]
            pub fn muxpos(&self) -> MUXPOSR {
                MUXPOSR::_from({
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:12 - Negative Mux Input Selection"]
            #[inline(always)]
            pub fn muxneg(&self) -> MUXNEGR {
                MUXNEGR::_from({
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 16:19 - Number of Input Channels Included in Scan"]
            #[inline(always)]
            pub fn inputscan(&self) -> INPUTSCANR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                INPUTSCANR { bits }
            }
            #[doc = "Bits 20:23 - Positive Mux Setting Offset"]
            #[inline(always)]
            pub fn inputoffset(&self) -> INPUTOFFSETR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                INPUTOFFSETR { bits }
            }
            #[doc = "Bits 24:27 - Gain Factor Selection"]
            #[inline(always)]
            pub fn gain(&self) -> GAINR {
                GAINR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Positive Mux Input Selection"]
            #[inline(always)]
            pub fn muxpos(&mut self) -> _MUXPOSW {
                _MUXPOSW { w: self }
            }
            #[doc = "Bits 8:12 - Negative Mux Input Selection"]
            #[inline(always)]
            pub fn muxneg(&mut self) -> _MUXNEGW {
                _MUXNEGW { w: self }
            }
            #[doc = "Bits 16:19 - Number of Input Channels Included in Scan"]
            #[inline(always)]
            pub fn inputscan(&mut self) -> _INPUTSCANW {
                _INPUTSCANW { w: self }
            }
            #[doc = "Bits 20:23 - Positive Mux Setting Offset"]
            #[inline(always)]
            pub fn inputoffset(&mut self) -> _INPUTOFFSETW {
                _INPUTOFFSETW { w: self }
            }
            #[doc = "Bits 24:27 - Gain Factor Selection"]
            #[inline(always)]
            pub fn gain(&mut self) -> _GAINW {
                _GAINW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESRDYR {
            bits: bool,
        }
        impl RESRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNR {
            bits: bool,
        }
        impl OVERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINMONR {
            bits: bool,
        }
        impl WINMONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINMONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINMONW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Result Ready Interrupt Enable"]
            #[inline(always)]
            pub fn resrdy(&self) -> RESRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RESRDYR { bits }
            }
            #[doc = "Bit 1 - Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn overrun(&self) -> OVERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                OVERRUNR { bits }
            }
            #[doc = "Bit 2 - Window Monitor Interrupt Enable"]
            #[inline(always)]
            pub fn winmon(&self) -> WINMONR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WINMONR { bits }
            }
            #[doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
            #[inline(always)]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Result Ready Interrupt Enable"]
            #[inline(always)]
            pub fn resrdy(&mut self) -> _RESRDYW {
                _RESRDYW { w: self }
            }
            #[doc = "Bit 1 - Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn overrun(&mut self) -> _OVERRUNW {
                _OVERRUNW { w: self }
            }
            #[doc = "Bit 2 - Window Monitor Interrupt Enable"]
            #[inline(always)]
            pub fn winmon(&mut self) -> _WINMONW {
                _WINMONW { w: self }
            }
            #[doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
            #[inline(always)]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESRDYR {
            bits: bool,
        }
        impl RESRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNR {
            bits: bool,
        }
        impl OVERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINMONR {
            bits: bool,
        }
        impl WINMONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINMONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINMONW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Result Ready Interrupt Enable"]
            #[inline(always)]
            pub fn resrdy(&self) -> RESRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RESRDYR { bits }
            }
            #[doc = "Bit 1 - Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn overrun(&self) -> OVERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                OVERRUNR { bits }
            }
            #[doc = "Bit 2 - Window Monitor Interrupt Enable"]
            #[inline(always)]
            pub fn winmon(&self) -> WINMONR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WINMONR { bits }
            }
            #[doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
            #[inline(always)]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Result Ready Interrupt Enable"]
            #[inline(always)]
            pub fn resrdy(&mut self) -> _RESRDYW {
                _RESRDYW { w: self }
            }
            #[doc = "Bit 1 - Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn overrun(&mut self) -> _OVERRUNW {
                _OVERRUNW { w: self }
            }
            #[doc = "Bit 2 - Window Monitor Interrupt Enable"]
            #[inline(always)]
            pub fn winmon(&mut self) -> _WINMONW {
                _WINMONW { w: self }
            }
            #[doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
            #[inline(always)]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESRDYR {
            bits: bool,
        }
        impl RESRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNR {
            bits: bool,
        }
        impl OVERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINMONR {
            bits: bool,
        }
        impl WINMONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINMONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINMONW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Result Ready"]
            #[inline(always)]
            pub fn resrdy(&self) -> RESRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RESRDYR { bits }
            }
            #[doc = "Bit 1 - Overrun"]
            #[inline(always)]
            pub fn overrun(&self) -> OVERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                OVERRUNR { bits }
            }
            #[doc = "Bit 2 - Window Monitor"]
            #[inline(always)]
            pub fn winmon(&self) -> WINMONR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WINMONR { bits }
            }
            #[doc = "Bit 3 - Synchronization Ready"]
            #[inline(always)]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Result Ready"]
            #[inline(always)]
            pub fn resrdy(&mut self) -> _RESRDYW {
                _RESRDYW { w: self }
            }
            #[doc = "Bit 1 - Overrun"]
            #[inline(always)]
            pub fn overrun(&mut self) -> _OVERRUNW {
                _OVERRUNW { w: self }
            }
            #[doc = "Bit 2 - Window Monitor"]
            #[inline(always)]
            pub fn winmon(&mut self) -> _WINMONW {
                _WINMONW { w: self }
            }
            #[doc = "Bit 3 - Synchronization Ready"]
            #[inline(always)]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
        }
    }
    #[doc = "Offset Correction"]
    pub struct OFFSETCORR {
        register: VolatileCell<u16>,
    }
    #[doc = "Offset Correction"]
    pub mod offsetcorr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::OFFSETCORR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OFFSETCORRR {
            bits: u16,
        }
        impl OFFSETCORRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OFFSETCORRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OFFSETCORRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:11 - Offset Correction Value"]
            #[inline(always)]
            pub fn offsetcorr(&self) -> OFFSETCORRR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                OFFSETCORRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Offset Correction Value"]
            #[inline(always)]
            pub fn offsetcorr(&mut self) -> _OFFSETCORRW {
                _OFFSETCORRW { w: self }
            }
        }
    }
    #[doc = "Reference Control"]
    pub struct REFCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Reference Control"]
    pub mod refctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::REFCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `REFSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REFSELR {
            #[doc = "1.0V voltage reference"]
            INT1V,
            #[doc = "1/1.48 VDDANA"]
            INTVCC0,
            #[doc = "1/2 VDDANA (only for VDDANA > 2.0V)"]
            INTVCC1,
            #[doc = "External reference"]
            AREFA,
            #[doc = "External reference"]
            AREFB,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl REFSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    REFSELR::INT1V => 0,
                    REFSELR::INTVCC0 => 1,
                    REFSELR::INTVCC1 => 2,
                    REFSELR::AREFA => 3,
                    REFSELR::AREFB => 4,
                    REFSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> REFSELR {
                match value {
                    0 => REFSELR::INT1V,
                    1 => REFSELR::INTVCC0,
                    2 => REFSELR::INTVCC1,
                    3 => REFSELR::AREFA,
                    4 => REFSELR::AREFB,
                    i => REFSELR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `INT1V`"]
            #[inline(always)]
            pub fn is_int1v(&self) -> bool {
                *self == REFSELR::INT1V
            }
            #[doc = "Checks if the value of the field is `INTVCC0`"]
            #[inline(always)]
            pub fn is_intvcc0(&self) -> bool {
                *self == REFSELR::INTVCC0
            }
            #[doc = "Checks if the value of the field is `INTVCC1`"]
            #[inline(always)]
            pub fn is_intvcc1(&self) -> bool {
                *self == REFSELR::INTVCC1
            }
            #[doc = "Checks if the value of the field is `AREFA`"]
            #[inline(always)]
            pub fn is_arefa(&self) -> bool {
                *self == REFSELR::AREFA
            }
            #[doc = "Checks if the value of the field is `AREFB`"]
            #[inline(always)]
            pub fn is_arefb(&self) -> bool {
                *self == REFSELR::AREFB
            }
        }
        #[doc = r" Value of the field"]
        pub struct REFCOMPR {
            bits: bool,
        }
        impl REFCOMPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `REFSEL`"]
        pub enum REFSELW {
            #[doc = "1.0V voltage reference"]
            INT1V,
            #[doc = "1/1.48 VDDANA"]
            INTVCC0,
            #[doc = "1/2 VDDANA (only for VDDANA > 2.0V)"]
            INTVCC1,
            #[doc = "External reference"]
            AREFA,
            #[doc = "External reference"]
            AREFB,
        }
        impl REFSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    REFSELW::INT1V => 0,
                    REFSELW::INTVCC0 => 1,
                    REFSELW::INTVCC1 => 2,
                    REFSELW::AREFA => 3,
                    REFSELW::AREFB => 4,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REFSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REFSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: REFSELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "1.0V voltage reference"]
            #[inline(always)]
            pub fn int1v(self) -> &'a mut W {
                self.variant(REFSELW::INT1V)
            }
            #[doc = "1/1.48 VDDANA"]
            #[inline(always)]
            pub fn intvcc0(self) -> &'a mut W {
                self.variant(REFSELW::INTVCC0)
            }
            #[doc = "1/2 VDDANA (only for VDDANA > 2.0V)"]
            #[inline(always)]
            pub fn intvcc1(self) -> &'a mut W {
                self.variant(REFSELW::INTVCC1)
            }
            #[doc = "External reference"]
            #[inline(always)]
            pub fn arefa(self) -> &'a mut W {
                self.variant(REFSELW::AREFA)
            }
            #[doc = "External reference"]
            #[inline(always)]
            pub fn arefb(self) -> &'a mut W {
                self.variant(REFSELW::AREFB)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _REFCOMPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REFCOMPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:3 - Reference Selection"]
            #[inline(always)]
            pub fn refsel(&self) -> REFSELR {
                REFSELR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bit 7 - Reference Buffer Offset Compensation Enable"]
            #[inline(always)]
            pub fn refcomp(&self) -> REFCOMPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                REFCOMPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Reference Selection"]
            #[inline(always)]
            pub fn refsel(&mut self) -> _REFSELW {
                _REFSELW { w: self }
            }
            #[doc = "Bit 7 - Reference Buffer Offset Compensation Enable"]
            #[inline(always)]
            pub fn refcomp(&mut self) -> _REFCOMPW {
                _REFCOMPW { w: self }
            }
        }
    }
    #[doc = "Result"]
    pub struct RESULT {
        register: VolatileCell<u16>,
    }
    #[doc = "Result"]
    pub mod result {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        impl super::RESULT {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESULTR {
            bits: u16,
        }
        impl RESULTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Result Conversion Value"]
            #[inline(always)]
            pub fn result(&self) -> RESULTR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                RESULTR { bits }
            }
        }
    }
    #[doc = "Sampling Time Control"]
    pub struct SAMPCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Sampling Time Control"]
    pub mod sampctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::SAMPCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SAMPLENR {
            bits: u8,
        }
        impl SAMPLENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SAMPLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SAMPLENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:5 - Sampling Time Length"]
            #[inline(always)]
            pub fn samplen(&self) -> SAMPLENR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                SAMPLENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - Sampling Time Length"]
            #[inline(always)]
            pub fn samplen(&mut self) -> _SAMPLENW {
                _SAMPLENW { w: self }
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 7 - Synchronization Busy"]
            #[inline(always)]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCBUSYR { bits }
            }
        }
    }
    #[doc = "Software Trigger"]
    pub struct SWTRIG {
        register: VolatileCell<u8>,
    }
    #[doc = "Software Trigger"]
    pub mod swtrig {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::SWTRIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FLUSHR {
            bits: bool,
        }
        impl FLUSHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTR {
            bits: bool,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLUSHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLUSHW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - ADC Conversion Flush"]
            #[inline(always)]
            pub fn flush(&self) -> FLUSHR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                FLUSHR { bits }
            }
            #[doc = "Bit 1 - ADC Start Conversion"]
            #[inline(always)]
            pub fn start(&self) -> STARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STARTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - ADC Conversion Flush"]
            #[inline(always)]
            pub fn flush(&mut self) -> _FLUSHW {
                _FLUSHW { w: self }
            }
            #[doc = "Bit 1 - ADC Start Conversion"]
            #[inline(always)]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
        }
    }
    #[doc = "Window Monitor Control"]
    pub struct WINCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Window Monitor Control"]
    pub mod winctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::WINCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WINMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WINMODER {
            #[doc = "No window mode (default)"]
            DISABLE,
            #[doc = "Mode 1: RESULT > WINLT"]
            MODE1,
            #[doc = "Mode 2: RESULT < WINUT"]
            MODE2,
            #[doc = "Mode 3: WINLT < RESULT < WINUT"]
            MODE3,
            #[doc = "Mode 4: !(WINLT < RESULT < WINUT)"]
            MODE4,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl WINMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    WINMODER::DISABLE => 0,
                    WINMODER::MODE1 => 1,
                    WINMODER::MODE2 => 2,
                    WINMODER::MODE3 => 3,
                    WINMODER::MODE4 => 4,
                    WINMODER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> WINMODER {
                match value {
                    0 => WINMODER::DISABLE,
                    1 => WINMODER::MODE1,
                    2 => WINMODER::MODE2,
                    3 => WINMODER::MODE3,
                    4 => WINMODER::MODE4,
                    i => WINMODER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == WINMODER::DISABLE
            }
            #[doc = "Checks if the value of the field is `MODE1`"]
            #[inline(always)]
            pub fn is_mode1(&self) -> bool {
                *self == WINMODER::MODE1
            }
            #[doc = "Checks if the value of the field is `MODE2`"]
            #[inline(always)]
            pub fn is_mode2(&self) -> bool {
                *self == WINMODER::MODE2
            }
            #[doc = "Checks if the value of the field is `MODE3`"]
            #[inline(always)]
            pub fn is_mode3(&self) -> bool {
                *self == WINMODER::MODE3
            }
            #[doc = "Checks if the value of the field is `MODE4`"]
            #[inline(always)]
            pub fn is_mode4(&self) -> bool {
                *self == WINMODER::MODE4
            }
        }
        #[doc = "Values that can be written to the field `WINMODE`"]
        pub enum WINMODEW {
            #[doc = "No window mode (default)"]
            DISABLE,
            #[doc = "Mode 1: RESULT > WINLT"]
            MODE1,
            #[doc = "Mode 2: RESULT < WINUT"]
            MODE2,
            #[doc = "Mode 3: WINLT < RESULT < WINUT"]
            MODE3,
            #[doc = "Mode 4: !(WINLT < RESULT < WINUT)"]
            MODE4,
        }
        impl WINMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WINMODEW::DISABLE => 0,
                    WINMODEW::MODE1 => 1,
                    WINMODEW::MODE2 => 2,
                    WINMODEW::MODE3 => 3,
                    WINMODEW::MODE4 => 4,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WINMODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No window mode (default)"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(WINMODEW::DISABLE)
            }
            #[doc = "Mode 1: RESULT > WINLT"]
            #[inline(always)]
            pub fn mode1(self) -> &'a mut W {
                self.variant(WINMODEW::MODE1)
            }
            #[doc = "Mode 2: RESULT < WINUT"]
            #[inline(always)]
            pub fn mode2(self) -> &'a mut W {
                self.variant(WINMODEW::MODE2)
            }
            #[doc = "Mode 3: WINLT < RESULT < WINUT"]
            #[inline(always)]
            pub fn mode3(self) -> &'a mut W {
                self.variant(WINMODEW::MODE3)
            }
            #[doc = "Mode 4: !(WINLT < RESULT < WINUT)"]
            #[inline(always)]
            pub fn mode4(self) -> &'a mut W {
                self.variant(WINMODEW::MODE4)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:2 - Window Monitor Mode"]
            #[inline(always)]
            pub fn winmode(&self) -> WINMODER {
                WINMODER::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Window Monitor Mode"]
            #[inline(always)]
            pub fn winmode(&mut self) -> _WINMODEW {
                _WINMODEW { w: self }
            }
        }
    }
    #[doc = "Window Monitor Lower Threshold"]
    pub struct WINLT {
        register: VolatileCell<u16>,
    }
    #[doc = "Window Monitor Lower Threshold"]
    pub mod winlt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::WINLT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINLTR {
            bits: u16,
        }
        impl WINLTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINLTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINLTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Window Lower Threshold"]
            #[inline(always)]
            pub fn winlt(&self) -> WINLTR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                WINLTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Window Lower Threshold"]
            #[inline(always)]
            pub fn winlt(&mut self) -> _WINLTW {
                _WINLTW { w: self }
            }
        }
    }
    #[doc = "Window Monitor Upper Threshold"]
    pub struct WINUT {
        register: VolatileCell<u16>,
    }
    #[doc = "Window Monitor Upper Threshold"]
    pub mod winut {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::WINUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINUTR {
            bits: u16,
        }
        impl WINUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINUTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Window Upper Threshold"]
            #[inline(always)]
            pub fn winut(&self) -> WINUTR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                WINUTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Window Upper Threshold"]
            #[inline(always)]
            pub fn winut(&mut self) -> _WINUTW {
                _WINUTW { w: self }
            }
        }
    }
}
#[doc = "Analog Digital Converter"]
pub struct ADC {
    register_block: adc::RegisterBlock,
}
impl Deref for ADC {
    type Target = adc::RegisterBlock;
    fn deref(&self) -> &adc::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Digital Analog Converter"]
pub const DAC: Peripheral<DAC> = unsafe { Peripheral::new(1107314688) };
#[doc = "Digital Analog Converter"]
pub mod dac {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control A"]
        pub ctrla: CTRLA,
        #[doc = "0x01 - Control B"]
        pub ctrlb: CTRLB,
        #[doc = "0x02 - Event Control"]
        pub evctrl: EVCTRL,
        _reserved0: [u8; 1usize],
        #[doc = "0x04 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x05 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x06 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        #[doc = "0x07 - Status"]
        pub status: STATUS,
        #[doc = "0x08 - Data"]
        pub data: DATA,
        _reserved1: [u8; 2usize],
        #[doc = "0x0c - Data Buffer"]
        pub databuf: DATABUF,
    }
    #[doc = "Control A"]
    pub struct CTRLA {
        register: VolatileCell<u8>,
    }
    #[doc = "Control A"]
    pub mod ctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SWRSTR { bits }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RUNSTDBYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
        }
    }
    #[doc = "Control B"]
    pub struct CTRLB {
        register: VolatileCell<u8>,
    }
    #[doc = "Control B"]
    pub mod ctrlb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLB {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EOENR {
            bits: bool,
        }
        impl EOENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IOENR {
            bits: bool,
        }
        impl IOENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LEFTADJR {
            bits: bool,
        }
        impl LEFTADJR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct VPDR {
            bits: bool,
        }
        impl VPDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BDWPR {
            bits: bool,
        }
        impl BDWPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `REFSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REFSELR {
            #[doc = "Internal 1.0V reference"]
            INT1V,
            #[doc = "AVCC"]
            AVCC,
            #[doc = "External reference"]
            VREFP,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl REFSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    REFSELR::INT1V => 0,
                    REFSELR::AVCC => 1,
                    REFSELR::VREFP => 2,
                    REFSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> REFSELR {
                match value {
                    0 => REFSELR::INT1V,
                    1 => REFSELR::AVCC,
                    2 => REFSELR::VREFP,
                    i => REFSELR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `INT1V`"]
            #[inline(always)]
            pub fn is_int1v(&self) -> bool {
                *self == REFSELR::INT1V
            }
            #[doc = "Checks if the value of the field is `AVCC`"]
            #[inline(always)]
            pub fn is_avcc(&self) -> bool {
                *self == REFSELR::AVCC
            }
            #[doc = "Checks if the value of the field is `VREFP`"]
            #[inline(always)]
            pub fn is_vrefp(&self) -> bool {
                *self == REFSELR::VREFP
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LEFTADJW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LEFTADJW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _VPDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VPDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BDWPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BDWPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `REFSEL`"]
        pub enum REFSELW {
            #[doc = "Internal 1.0V reference"]
            INT1V,
            #[doc = "AVCC"]
            AVCC,
            #[doc = "External reference"]
            VREFP,
        }
        impl REFSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    REFSELW::INT1V => 0,
                    REFSELW::AVCC => 1,
                    REFSELW::VREFP => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REFSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REFSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: REFSELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Internal 1.0V reference"]
            #[inline(always)]
            pub fn int1v(self) -> &'a mut W {
                self.variant(REFSELW::INT1V)
            }
            #[doc = "AVCC"]
            #[inline(always)]
            pub fn avcc(self) -> &'a mut W {
                self.variant(REFSELW::AVCC)
            }
            #[doc = "External reference"]
            #[inline(always)]
            pub fn vrefp(self) -> &'a mut W {
                self.variant(REFSELW::VREFP)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - External Output Enable"]
            #[inline(always)]
            pub fn eoen(&self) -> EOENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EOENR { bits }
            }
            #[doc = "Bit 1 - Internal Output Enable"]
            #[inline(always)]
            pub fn ioen(&self) -> IOENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                IOENR { bits }
            }
            #[doc = "Bit 2 - Left Adjusted Data"]
            #[inline(always)]
            pub fn leftadj(&self) -> LEFTADJR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                LEFTADJR { bits }
            }
            #[doc = "Bit 3 - Voltage Pump Disable"]
            #[inline(always)]
            pub fn vpd(&self) -> VPDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                VPDR { bits }
            }
            #[doc = "Bit 4 - Bypass DATABUF Write Protection"]
            #[inline(always)]
            pub fn bdwp(&self) -> BDWPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                BDWPR { bits }
            }
            #[doc = "Bits 6:7 - Reference Selection"]
            #[inline(always)]
            pub fn refsel(&self) -> REFSELR {
                REFSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Output Enable"]
            #[inline(always)]
            pub fn eoen(&mut self) -> _EOENW {
                _EOENW { w: self }
            }
            #[doc = "Bit 1 - Internal Output Enable"]
            #[inline(always)]
            pub fn ioen(&mut self) -> _IOENW {
                _IOENW { w: self }
            }
            #[doc = "Bit 2 - Left Adjusted Data"]
            #[inline(always)]
            pub fn leftadj(&mut self) -> _LEFTADJW {
                _LEFTADJW { w: self }
            }
            #[doc = "Bit 3 - Voltage Pump Disable"]
            #[inline(always)]
            pub fn vpd(&mut self) -> _VPDW {
                _VPDW { w: self }
            }
            #[doc = "Bit 4 - Bypass DATABUF Write Protection"]
            #[inline(always)]
            pub fn bdwp(&mut self) -> _BDWPW {
                _BDWPW { w: self }
            }
            #[doc = "Bits 6:7 - Reference Selection"]
            #[inline(always)]
            pub fn refsel(&mut self) -> _REFSELW {
                _REFSELW { w: self }
            }
        }
    }
    #[doc = "Data"]
    pub struct DATA {
        register: VolatileCell<u16>,
    }
    #[doc = "Data"]
    pub mod data {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::DATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u16,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Data value to be converted"]
            #[inline(always)]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Data value to be converted"]
            #[inline(always)]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "Data Buffer"]
    pub struct DATABUF {
        register: VolatileCell<u16>,
    }
    #[doc = "Data Buffer"]
    pub mod databuf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::DATABUF {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATABUFR {
            bits: u16,
        }
        impl DATABUFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATABUFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATABUFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Data Buffer"]
            #[inline(always)]
            pub fn databuf(&self) -> DATABUFR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                DATABUFR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Data Buffer"]
            #[inline(always)]
            pub fn databuf(&mut self) -> _DATABUFW {
                _DATABUFW { w: self }
            }
        }
    }
    #[doc = "Event Control"]
    pub struct EVCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Event Control"]
    pub mod evctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::EVCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTEIR {
            bits: bool,
        }
        impl STARTEIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EMPTYEOR {
            bits: bool,
        }
        impl EMPTYEOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTEIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTEIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMPTYEOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMPTYEOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Start Conversion Event Input"]
            #[inline(always)]
            pub fn startei(&self) -> STARTEIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STARTEIR { bits }
            }
            #[doc = "Bit 1 - Data Buffer Empty Event Output"]
            #[inline(always)]
            pub fn emptyeo(&self) -> EMPTYEOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EMPTYEOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Start Conversion Event Input"]
            #[inline(always)]
            pub fn startei(&mut self) -> _STARTEIW {
                _STARTEIW { w: self }
            }
            #[doc = "Bit 1 - Data Buffer Empty Event Output"]
            #[inline(always)]
            pub fn emptyeo(&mut self) -> _EMPTYEOW {
                _EMPTYEOW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct UNDERRUNR {
            bits: bool,
        }
        impl UNDERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EMPTYR {
            bits: bool,
        }
        impl EMPTYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _UNDERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UNDERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMPTYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMPTYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Underrun Interrupt Enable"]
            #[inline(always)]
            pub fn underrun(&self) -> UNDERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                UNDERRUNR { bits }
            }
            #[doc = "Bit 1 - Data Buffer Empty Interrupt Enable"]
            #[inline(always)]
            pub fn empty(&self) -> EMPTYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EMPTYR { bits }
            }
            #[doc = "Bit 2 - Synchronization Ready Interrupt Enable"]
            #[inline(always)]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Underrun Interrupt Enable"]
            #[inline(always)]
            pub fn underrun(&mut self) -> _UNDERRUNW {
                _UNDERRUNW { w: self }
            }
            #[doc = "Bit 1 - Data Buffer Empty Interrupt Enable"]
            #[inline(always)]
            pub fn empty(&mut self) -> _EMPTYW {
                _EMPTYW { w: self }
            }
            #[doc = "Bit 2 - Synchronization Ready Interrupt Enable"]
            #[inline(always)]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct UNDERRUNR {
            bits: bool,
        }
        impl UNDERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EMPTYR {
            bits: bool,
        }
        impl EMPTYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _UNDERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UNDERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMPTYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMPTYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Underrun Interrupt Enable"]
            #[inline(always)]
            pub fn underrun(&self) -> UNDERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                UNDERRUNR { bits }
            }
            #[doc = "Bit 1 - Data Buffer Empty Interrupt Enable"]
            #[inline(always)]
            pub fn empty(&self) -> EMPTYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EMPTYR { bits }
            }
            #[doc = "Bit 2 - Synchronization Ready Interrupt Enable"]
            #[inline(always)]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Underrun Interrupt Enable"]
            #[inline(always)]
            pub fn underrun(&mut self) -> _UNDERRUNW {
                _UNDERRUNW { w: self }
            }
            #[doc = "Bit 1 - Data Buffer Empty Interrupt Enable"]
            #[inline(always)]
            pub fn empty(&mut self) -> _EMPTYW {
                _EMPTYW { w: self }
            }
            #[doc = "Bit 2 - Synchronization Ready Interrupt Enable"]
            #[inline(always)]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct UNDERRUNR {
            bits: bool,
        }
        impl UNDERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EMPTYR {
            bits: bool,
        }
        impl EMPTYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _UNDERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UNDERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMPTYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMPTYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Underrun"]
            #[inline(always)]
            pub fn underrun(&self) -> UNDERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                UNDERRUNR { bits }
            }
            #[doc = "Bit 1 - Data Buffer Empty"]
            #[inline(always)]
            pub fn empty(&self) -> EMPTYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EMPTYR { bits }
            }
            #[doc = "Bit 2 - Synchronization Ready"]
            #[inline(always)]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Underrun"]
            #[inline(always)]
            pub fn underrun(&mut self) -> _UNDERRUNW {
                _UNDERRUNW { w: self }
            }
            #[doc = "Bit 1 - Data Buffer Empty"]
            #[inline(always)]
            pub fn empty(&mut self) -> _EMPTYW {
                _EMPTYW { w: self }
            }
            #[doc = "Bit 2 - Synchronization Ready"]
            #[inline(always)]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 7 - Synchronization Busy Status"]
            #[inline(always)]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCBUSYR { bits }
            }
        }
    }
}
#[doc = "Digital Analog Converter"]
pub struct DAC {
    register_block: dac::RegisterBlock,
}
impl Deref for DAC {
    type Target = dac::RegisterBlock;
    fn deref(&self) -> &dac::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Direct Memory Access Controller"]
pub const DMAC: Peripheral<DMAC> = unsafe { Peripheral::new(1090537472) };
#[doc = "Direct Memory Access Controller"]
pub mod dmac {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctrl: CTRL,
        #[doc = "0x02 - CRC Control"]
        pub crcctrl: CRCCTRL,
        #[doc = "0x04 - CRC Data Input"]
        pub crcdatain: CRCDATAIN,
        #[doc = "0x08 - CRC Checksum"]
        pub crcchksum: CRCCHKSUM,
        #[doc = "0x0c - CRC Status"]
        pub crcstatus: CRCSTATUS,
        #[doc = "0x0d - Debug Control"]
        pub dbgctrl: DBGCTRL,
        _reserved0: [u8; 2usize],
        #[doc = "0x10 - Software Trigger Control"]
        pub swtrigctrl: SWTRIGCTRL,
        #[doc = "0x14 - Priority Control 0"]
        pub prictrl0: PRICTRL0,
        _reserved1: [u8; 8usize],
        #[doc = "0x20 - Interrupt Pending"]
        pub intpend: INTPEND,
        _reserved2: [u8; 2usize],
        #[doc = "0x24 - Interrupt Status"]
        pub intstatus: INTSTATUS,
        #[doc = "0x28 - Busy Channels"]
        pub busych: BUSYCH,
        #[doc = "0x2c - Pending Channels"]
        pub pendch: PENDCH,
        #[doc = "0x30 - Active Channel and Levels"]
        pub active: ACTIVE,
        #[doc = "0x34 - Descriptor Memory Section Base Address"]
        pub baseaddr: BASEADDR,
        #[doc = "0x38 - Write-Back Memory Section Base Address"]
        pub wrbaddr: WRBADDR,
        _reserved3: [u8; 3usize],
        #[doc = "0x3f - Channel ID"]
        pub chid: CHID,
        #[doc = "0x40 - Channel Control A"]
        pub chctrla: CHCTRLA,
        _reserved4: [u8; 3usize],
        #[doc = "0x44 - Channel Control B"]
        pub chctrlb: CHCTRLB,
        _reserved5: [u8; 4usize],
        #[doc = "0x4c - Channel Interrupt Enable Clear"]
        pub chintenclr: CHINTENCLR,
        #[doc = "0x4d - Channel Interrupt Enable Set"]
        pub chintenset: CHINTENSET,
        #[doc = "0x4e - Channel Interrupt Flag Status and Clear"]
        pub chintflag: CHINTFLAG,
        #[doc = "0x4f - Channel Status"]
        pub chstatus: CHSTATUS,
    }
    #[doc = "Active Channel and Levels"]
    pub struct ACTIVE {
        register: VolatileCell<u32>,
    }
    #[doc = "Active Channel and Levels"]
    pub mod active {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::ACTIVE {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct LVLEX0R {
            bits: bool,
        }
        impl LVLEX0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LVLEX1R {
            bits: bool,
        }
        impl LVLEX1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LVLEX2R {
            bits: bool,
        }
        impl LVLEX2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LVLEX3R {
            bits: bool,
        }
        impl LVLEX3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDR {
            bits: u8,
        }
        impl IDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ABUSYR {
            bits: bool,
        }
        impl ABUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BTCNTR {
            bits: u16,
        }
        impl BTCNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Level 0 Channel Trigger Request Executing"]
            #[inline(always)]
            pub fn lvlex0(&self) -> LVLEX0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LVLEX0R { bits }
            }
            #[doc = "Bit 1 - Level 1 Channel Trigger Request Executing"]
            #[inline(always)]
            pub fn lvlex1(&self) -> LVLEX1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LVLEX1R { bits }
            }
            #[doc = "Bit 2 - Level 2 Channel Trigger Request Executing"]
            #[inline(always)]
            pub fn lvlex2(&self) -> LVLEX2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LVLEX2R { bits }
            }
            #[doc = "Bit 3 - Level 3 Channel Trigger Request Executing"]
            #[inline(always)]
            pub fn lvlex3(&self) -> LVLEX3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LVLEX3R { bits }
            }
            #[doc = "Bits 8:12 - Active Channel ID"]
            #[inline(always)]
            pub fn id(&self) -> IDR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IDR { bits }
            }
            #[doc = "Bit 15 - Active Channel Busy"]
            #[inline(always)]
            pub fn abusy(&self) -> ABUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ABUSYR { bits }
            }
            #[doc = "Bits 16:31 - Active Channel Block Transfer Count"]
            #[inline(always)]
            pub fn btcnt(&self) -> BTCNTR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                BTCNTR { bits }
            }
        }
    }
    #[doc = "Descriptor Memory Section Base Address"]
    pub struct BASEADDR {
        register: VolatileCell<u32>,
    }
    #[doc = "Descriptor Memory Section Base Address"]
    pub mod baseaddr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BASEADDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct BASEADDRR {
            bits: u32,
        }
        impl BASEADDRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _BASEADDRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BASEADDRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Descriptor Memory Base Address"]
            #[inline(always)]
            pub fn baseaddr(&self) -> BASEADDRR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                BASEADDRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Descriptor Memory Base Address"]
            #[inline(always)]
            pub fn baseaddr(&mut self) -> _BASEADDRW {
                _BASEADDRW { w: self }
            }
        }
    }
    #[doc = "Busy Channels"]
    pub struct BUSYCH {
        register: VolatileCell<u32>,
    }
    #[doc = "Busy Channels"]
    pub mod busych {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::BUSYCH {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYCH0R {
            bits: bool,
        }
        impl BUSYCH0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYCH1R {
            bits: bool,
        }
        impl BUSYCH1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYCH2R {
            bits: bool,
        }
        impl BUSYCH2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYCH3R {
            bits: bool,
        }
        impl BUSYCH3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYCH4R {
            bits: bool,
        }
        impl BUSYCH4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYCH5R {
            bits: bool,
        }
        impl BUSYCH5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYCH6R {
            bits: bool,
        }
        impl BUSYCH6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYCH7R {
            bits: bool,
        }
        impl BUSYCH7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYCH8R {
            bits: bool,
        }
        impl BUSYCH8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYCH9R {
            bits: bool,
        }
        impl BUSYCH9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYCH10R {
            bits: bool,
        }
        impl BUSYCH10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYCH11R {
            bits: bool,
        }
        impl BUSYCH11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Busy Channel 0"]
            #[inline(always)]
            pub fn busych0(&self) -> BUSYCH0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSYCH0R { bits }
            }
            #[doc = "Bit 1 - Busy Channel 1"]
            #[inline(always)]
            pub fn busych1(&self) -> BUSYCH1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSYCH1R { bits }
            }
            #[doc = "Bit 2 - Busy Channel 2"]
            #[inline(always)]
            pub fn busych2(&self) -> BUSYCH2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSYCH2R { bits }
            }
            #[doc = "Bit 3 - Busy Channel 3"]
            #[inline(always)]
            pub fn busych3(&self) -> BUSYCH3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSYCH3R { bits }
            }
            #[doc = "Bit 4 - Busy Channel 4"]
            #[inline(always)]
            pub fn busych4(&self) -> BUSYCH4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSYCH4R { bits }
            }
            #[doc = "Bit 5 - Busy Channel 5"]
            #[inline(always)]
            pub fn busych5(&self) -> BUSYCH5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSYCH5R { bits }
            }
            #[doc = "Bit 6 - Busy Channel 6"]
            #[inline(always)]
            pub fn busych6(&self) -> BUSYCH6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSYCH6R { bits }
            }
            #[doc = "Bit 7 - Busy Channel 7"]
            #[inline(always)]
            pub fn busych7(&self) -> BUSYCH7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSYCH7R { bits }
            }
            #[doc = "Bit 8 - Busy Channel 8"]
            #[inline(always)]
            pub fn busych8(&self) -> BUSYCH8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSYCH8R { bits }
            }
            #[doc = "Bit 9 - Busy Channel 9"]
            #[inline(always)]
            pub fn busych9(&self) -> BUSYCH9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSYCH9R { bits }
            }
            #[doc = "Bit 10 - Busy Channel 10"]
            #[inline(always)]
            pub fn busych10(&self) -> BUSYCH10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSYCH10R { bits }
            }
            #[doc = "Bit 11 - Busy Channel 11"]
            #[inline(always)]
            pub fn busych11(&self) -> BUSYCH11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSYCH11R { bits }
            }
        }
    }
    #[doc = "Channel Control A"]
    pub struct CHCTRLA {
        register: VolatileCell<u8>,
    }
    #[doc = "Channel Control A"]
    pub mod chctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CHCTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Channel Software Reset"]
            #[inline(always)]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SWRSTR { bits }
            }
            #[doc = "Bit 1 - Channel Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel Software Reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - Channel Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "Channel Control B"]
    pub struct CHCTRLB {
        register: VolatileCell<u32>,
    }
    #[doc = "Channel Control B"]
    pub mod chctrlb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CHCTRLB {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `EVACT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EVACTR {
            #[doc = "No action"]
            NOACT,
            #[doc = "Transfer and periodic transfer trigger"]
            TRIG,
            #[doc = "Conditional transfer trigger"]
            CTRIG,
            #[doc = "Conditional block transfer"]
            CBLOCK,
            #[doc = "Channel suspend operation"]
            SUSPEND,
            #[doc = "Channel resume operation"]
            RESUME,
            #[doc = "Skip next block suspend action"]
            SSKIP,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl EVACTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    EVACTR::NOACT => 0,
                    EVACTR::TRIG => 1,
                    EVACTR::CTRIG => 2,
                    EVACTR::CBLOCK => 3,
                    EVACTR::SUSPEND => 4,
                    EVACTR::RESUME => 5,
                    EVACTR::SSKIP => 6,
                    EVACTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> EVACTR {
                match value {
                    0 => EVACTR::NOACT,
                    1 => EVACTR::TRIG,
                    2 => EVACTR::CTRIG,
                    3 => EVACTR::CBLOCK,
                    4 => EVACTR::SUSPEND,
                    5 => EVACTR::RESUME,
                    6 => EVACTR::SSKIP,
                    i => EVACTR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NOACT`"]
            #[inline(always)]
            pub fn is_noact(&self) -> bool {
                *self == EVACTR::NOACT
            }
            #[doc = "Checks if the value of the field is `TRIG`"]
            #[inline(always)]
            pub fn is_trig(&self) -> bool {
                *self == EVACTR::TRIG
            }
            #[doc = "Checks if the value of the field is `CTRIG`"]
            #[inline(always)]
            pub fn is_ctrig(&self) -> bool {
                *self == EVACTR::CTRIG
            }
            #[doc = "Checks if the value of the field is `CBLOCK`"]
            #[inline(always)]
            pub fn is_cblock(&self) -> bool {
                *self == EVACTR::CBLOCK
            }
            #[doc = "Checks if the value of the field is `SUSPEND`"]
            #[inline(always)]
            pub fn is_suspend(&self) -> bool {
                *self == EVACTR::SUSPEND
            }
            #[doc = "Checks if the value of the field is `RESUME`"]
            #[inline(always)]
            pub fn is_resume(&self) -> bool {
                *self == EVACTR::RESUME
            }
            #[doc = "Checks if the value of the field is `SSKIP`"]
            #[inline(always)]
            pub fn is_sskip(&self) -> bool {
                *self == EVACTR::SSKIP
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVIER {
            bits: bool,
        }
        impl EVIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVOER {
            bits: bool,
        }
        impl EVOER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LVLR {
            bits: u8,
        }
        impl LVLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `TRIGSRC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TRIGSRCR {
            #[doc = "Only software/event triggers"]
            DISABLE,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl TRIGSRCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    TRIGSRCR::DISABLE => 0,
                    TRIGSRCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> TRIGSRCR {
                match value {
                    0 => TRIGSRCR::DISABLE,
                    i => TRIGSRCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == TRIGSRCR::DISABLE
            }
        }
        #[doc = "Possible values of the field `TRIGACT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TRIGACTR {
            #[doc = "One trigger required for each block transfer"]
            BLOCK,
            #[doc = "One trigger required for each beat transfer"]
            BEAT,
            #[doc = "One trigger required for each transaction"]
            TRANSACTION,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl TRIGACTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    TRIGACTR::BLOCK => 0,
                    TRIGACTR::BEAT => 2,
                    TRIGACTR::TRANSACTION => 3,
                    TRIGACTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> TRIGACTR {
                match value {
                    0 => TRIGACTR::BLOCK,
                    2 => TRIGACTR::BEAT,
                    3 => TRIGACTR::TRANSACTION,
                    i => TRIGACTR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `BLOCK`"]
            #[inline(always)]
            pub fn is_block(&self) -> bool {
                *self == TRIGACTR::BLOCK
            }
            #[doc = "Checks if the value of the field is `BEAT`"]
            #[inline(always)]
            pub fn is_beat(&self) -> bool {
                *self == TRIGACTR::BEAT
            }
            #[doc = "Checks if the value of the field is `TRANSACTION`"]
            #[inline(always)]
            pub fn is_transaction(&self) -> bool {
                *self == TRIGACTR::TRANSACTION
            }
        }
        #[doc = "Possible values of the field `CMD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMDR {
            #[doc = "No action"]
            NOACT,
            #[doc = "Channel suspend operation"]
            SUSPEND,
            #[doc = "Channel resume operation"]
            RESUME,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CMDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMDR::NOACT => 0,
                    CMDR::SUSPEND => 1,
                    CMDR::RESUME => 2,
                    CMDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CMDR {
                match value {
                    0 => CMDR::NOACT,
                    1 => CMDR::SUSPEND,
                    2 => CMDR::RESUME,
                    i => CMDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NOACT`"]
            #[inline(always)]
            pub fn is_noact(&self) -> bool {
                *self == CMDR::NOACT
            }
            #[doc = "Checks if the value of the field is `SUSPEND`"]
            #[inline(always)]
            pub fn is_suspend(&self) -> bool {
                *self == CMDR::SUSPEND
            }
            #[doc = "Checks if the value of the field is `RESUME`"]
            #[inline(always)]
            pub fn is_resume(&self) -> bool {
                *self == CMDR::RESUME
            }
        }
        #[doc = "Values that can be written to the field `EVACT`"]
        pub enum EVACTW {
            #[doc = "No action"]
            NOACT,
            #[doc = "Transfer and periodic transfer trigger"]
            TRIG,
            #[doc = "Conditional transfer trigger"]
            CTRIG,
            #[doc = "Conditional block transfer"]
            CBLOCK,
            #[doc = "Channel suspend operation"]
            SUSPEND,
            #[doc = "Channel resume operation"]
            RESUME,
            #[doc = "Skip next block suspend action"]
            SSKIP,
        }
        impl EVACTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EVACTW::NOACT => 0,
                    EVACTW::TRIG => 1,
                    EVACTW::CTRIG => 2,
                    EVACTW::CBLOCK => 3,
                    EVACTW::SUSPEND => 4,
                    EVACTW::RESUME => 5,
                    EVACTW::SSKIP => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVACTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVACTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EVACTW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No action"]
            #[inline(always)]
            pub fn noact(self) -> &'a mut W {
                self.variant(EVACTW::NOACT)
            }
            #[doc = "Transfer and periodic transfer trigger"]
            #[inline(always)]
            pub fn trig(self) -> &'a mut W {
                self.variant(EVACTW::TRIG)
            }
            #[doc = "Conditional transfer trigger"]
            #[inline(always)]
            pub fn ctrig(self) -> &'a mut W {
                self.variant(EVACTW::CTRIG)
            }
            #[doc = "Conditional block transfer"]
            #[inline(always)]
            pub fn cblock(self) -> &'a mut W {
                self.variant(EVACTW::CBLOCK)
            }
            #[doc = "Channel suspend operation"]
            #[inline(always)]
            pub fn suspend(self) -> &'a mut W {
                self.variant(EVACTW::SUSPEND)
            }
            #[doc = "Channel resume operation"]
            #[inline(always)]
            pub fn resume(self) -> &'a mut W {
                self.variant(EVACTW::RESUME)
            }
            #[doc = "Skip next block suspend action"]
            #[inline(always)]
            pub fn sskip(self) -> &'a mut W {
                self.variant(EVACTW::SSKIP)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVOEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LVLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LVLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TRIGSRC`"]
        pub enum TRIGSRCW {
            #[doc = "Only software/event triggers"]
            DISABLE,
        }
        impl TRIGSRCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TRIGSRCW::DISABLE => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRIGSRCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRIGSRCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TRIGSRCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Only software/event triggers"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(TRIGSRCW::DISABLE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TRIGACT`"]
        pub enum TRIGACTW {
            #[doc = "One trigger required for each block transfer"]
            BLOCK,
            #[doc = "One trigger required for each beat transfer"]
            BEAT,
            #[doc = "One trigger required for each transaction"]
            TRANSACTION,
        }
        impl TRIGACTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TRIGACTW::BLOCK => 0,
                    TRIGACTW::BEAT => 2,
                    TRIGACTW::TRANSACTION => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRIGACTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRIGACTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TRIGACTW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "One trigger required for each block transfer"]
            #[inline(always)]
            pub fn block(self) -> &'a mut W {
                self.variant(TRIGACTW::BLOCK)
            }
            #[doc = "One trigger required for each beat transfer"]
            #[inline(always)]
            pub fn beat(self) -> &'a mut W {
                self.variant(TRIGACTW::BEAT)
            }
            #[doc = "One trigger required for each transaction"]
            #[inline(always)]
            pub fn transaction(self) -> &'a mut W {
                self.variant(TRIGACTW::TRANSACTION)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CMD`"]
        pub enum CMDW {
            #[doc = "No action"]
            NOACT,
            #[doc = "Channel suspend operation"]
            SUSPEND,
            #[doc = "Channel resume operation"]
            RESUME,
        }
        impl CMDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMDW::NOACT => 0,
                    CMDW::SUSPEND => 1,
                    CMDW::RESUME => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No action"]
            #[inline(always)]
            pub fn noact(self) -> &'a mut W {
                self.variant(CMDW::NOACT)
            }
            #[doc = "Channel suspend operation"]
            #[inline(always)]
            pub fn suspend(self) -> &'a mut W {
                self.variant(CMDW::SUSPEND)
            }
            #[doc = "Channel resume operation"]
            #[inline(always)]
            pub fn resume(self) -> &'a mut W {
                self.variant(CMDW::RESUME)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Event Input Action"]
            #[inline(always)]
            pub fn evact(&self) -> EVACTR {
                EVACTR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 3 - Channel Event Input Enable"]
            #[inline(always)]
            pub fn evie(&self) -> EVIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVIER { bits }
            }
            #[doc = "Bit 4 - Channel Event Output Enable"]
            #[inline(always)]
            pub fn evoe(&self) -> EVOER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVOER { bits }
            }
            #[doc = "Bits 5:6 - Channel Arbitration Level"]
            #[inline(always)]
            pub fn lvl(&self) -> LVLR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LVLR { bits }
            }
            #[doc = "Bits 8:13 - Peripheral Trigger Source"]
            #[inline(always)]
            pub fn trigsrc(&self) -> TRIGSRCR {
                TRIGSRCR::_from({
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 22:23 - Trigger Action"]
            #[inline(always)]
            pub fn trigact(&self) -> TRIGACTR {
                TRIGACTR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 24:25 - Software Command"]
            #[inline(always)]
            pub fn cmd(&self) -> CMDR {
                CMDR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Event Input Action"]
            #[inline(always)]
            pub fn evact(&mut self) -> _EVACTW {
                _EVACTW { w: self }
            }
            #[doc = "Bit 3 - Channel Event Input Enable"]
            #[inline(always)]
            pub fn evie(&mut self) -> _EVIEW {
                _EVIEW { w: self }
            }
            #[doc = "Bit 4 - Channel Event Output Enable"]
            #[inline(always)]
            pub fn evoe(&mut self) -> _EVOEW {
                _EVOEW { w: self }
            }
            #[doc = "Bits 5:6 - Channel Arbitration Level"]
            #[inline(always)]
            pub fn lvl(&mut self) -> _LVLW {
                _LVLW { w: self }
            }
            #[doc = "Bits 8:13 - Peripheral Trigger Source"]
            #[inline(always)]
            pub fn trigsrc(&mut self) -> _TRIGSRCW {
                _TRIGSRCW { w: self }
            }
            #[doc = "Bits 22:23 - Trigger Action"]
            #[inline(always)]
            pub fn trigact(&mut self) -> _TRIGACTW {
                _TRIGACTW { w: self }
            }
            #[doc = "Bits 24:25 - Software Command"]
            #[inline(always)]
            pub fn cmd(&mut self) -> _CMDW {
                _CMDW { w: self }
            }
        }
    }
    #[doc = "Channel ID"]
    pub struct CHID {
        register: VolatileCell<u8>,
    }
    #[doc = "Channel ID"]
    pub mod chid {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CHID {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDR {
            bits: u8,
        }
        impl IDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:3 - Channel ID"]
            #[inline(always)]
            pub fn id(&self) -> IDR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                IDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Channel ID"]
            #[inline(always)]
            pub fn id(&mut self) -> _IDW {
                _IDW { w: self }
            }
        }
    }
    #[doc = "Channel Interrupt Enable Clear"]
    pub struct CHINTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Channel Interrupt Enable Clear"]
    pub mod chintenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CHINTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TERRR {
            bits: bool,
        }
        impl TERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCMPLR {
            bits: bool,
        }
        impl TCMPLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SUSPR {
            bits: bool,
        }
        impl SUSPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCMPLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCMPLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SUSPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SUSPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Transfer Error Interrupt Enable"]
            #[inline(always)]
            pub fn terr(&self) -> TERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                TERRR { bits }
            }
            #[doc = "Bit 1 - Transfer Complete Interrupt Enable"]
            #[inline(always)]
            pub fn tcmpl(&self) -> TCMPLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                TCMPLR { bits }
            }
            #[doc = "Bit 2 - Channel Suspend Interrupt Enable"]
            #[inline(always)]
            pub fn susp(&self) -> SUSPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SUSPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Transfer Error Interrupt Enable"]
            #[inline(always)]
            pub fn terr(&mut self) -> _TERRW {
                _TERRW { w: self }
            }
            #[doc = "Bit 1 - Transfer Complete Interrupt Enable"]
            #[inline(always)]
            pub fn tcmpl(&mut self) -> _TCMPLW {
                _TCMPLW { w: self }
            }
            #[doc = "Bit 2 - Channel Suspend Interrupt Enable"]
            #[inline(always)]
            pub fn susp(&mut self) -> _SUSPW {
                _SUSPW { w: self }
            }
        }
    }
    #[doc = "Channel Interrupt Enable Set"]
    pub struct CHINTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Channel Interrupt Enable Set"]
    pub mod chintenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CHINTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TERRR {
            bits: bool,
        }
        impl TERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCMPLR {
            bits: bool,
        }
        impl TCMPLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SUSPR {
            bits: bool,
        }
        impl SUSPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCMPLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCMPLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SUSPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SUSPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Transfer Error Interrupt Enable"]
            #[inline(always)]
            pub fn terr(&self) -> TERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                TERRR { bits }
            }
            #[doc = "Bit 1 - Transfer Complete Interrupt Enable"]
            #[inline(always)]
            pub fn tcmpl(&self) -> TCMPLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                TCMPLR { bits }
            }
            #[doc = "Bit 2 - Channel Suspend Interrupt Enable"]
            #[inline(always)]
            pub fn susp(&self) -> SUSPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SUSPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Transfer Error Interrupt Enable"]
            #[inline(always)]
            pub fn terr(&mut self) -> _TERRW {
                _TERRW { w: self }
            }
            #[doc = "Bit 1 - Transfer Complete Interrupt Enable"]
            #[inline(always)]
            pub fn tcmpl(&mut self) -> _TCMPLW {
                _TCMPLW { w: self }
            }
            #[doc = "Bit 2 - Channel Suspend Interrupt Enable"]
            #[inline(always)]
            pub fn susp(&mut self) -> _SUSPW {
                _SUSPW { w: self }
            }
        }
    }
    #[doc = "Channel Interrupt Flag Status and Clear"]
    pub struct CHINTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Channel Interrupt Flag Status and Clear"]
    pub mod chintflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CHINTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TERRR {
            bits: bool,
        }
        impl TERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCMPLR {
            bits: bool,
        }
        impl TCMPLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SUSPR {
            bits: bool,
        }
        impl SUSPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCMPLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCMPLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SUSPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SUSPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Transfer Error"]
            #[inline(always)]
            pub fn terr(&self) -> TERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                TERRR { bits }
            }
            #[doc = "Bit 1 - Transfer Complete"]
            #[inline(always)]
            pub fn tcmpl(&self) -> TCMPLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                TCMPLR { bits }
            }
            #[doc = "Bit 2 - Channel Suspend"]
            #[inline(always)]
            pub fn susp(&self) -> SUSPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SUSPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Transfer Error"]
            #[inline(always)]
            pub fn terr(&mut self) -> _TERRW {
                _TERRW { w: self }
            }
            #[doc = "Bit 1 - Transfer Complete"]
            #[inline(always)]
            pub fn tcmpl(&mut self) -> _TCMPLW {
                _TCMPLW { w: self }
            }
            #[doc = "Bit 2 - Channel Suspend"]
            #[inline(always)]
            pub fn susp(&mut self) -> _SUSPW {
                _SUSPW { w: self }
            }
        }
    }
    #[doc = "Channel Status"]
    pub struct CHSTATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "Channel Status"]
    pub mod chstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::CHSTATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDR {
            bits: bool,
        }
        impl PENDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYR {
            bits: bool,
        }
        impl BUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FERRR {
            bits: bool,
        }
        impl FERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Channel Pending"]
            #[inline(always)]
            pub fn pend(&self) -> PENDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                PENDR { bits }
            }
            #[doc = "Bit 1 - Channel Busy"]
            #[inline(always)]
            pub fn busy(&self) -> BUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                BUSYR { bits }
            }
            #[doc = "Bit 2 - Fetch Error"]
            #[inline(always)]
            pub fn ferr(&self) -> FERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                FERRR { bits }
            }
        }
    }
    #[doc = "CRC Checksum"]
    pub struct CRCCHKSUM {
        register: VolatileCell<u32>,
    }
    #[doc = "CRC Checksum"]
    pub mod crcchksum {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CRCCHKSUM {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRCCHKSUMR {
            bits: u32,
        }
        impl CRCCHKSUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCCHKSUMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCCHKSUMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - CRC Checksum"]
            #[inline(always)]
            pub fn crcchksum(&self) -> CRCCHKSUMR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CRCCHKSUMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - CRC Checksum"]
            #[inline(always)]
            pub fn crcchksum(&mut self) -> _CRCCHKSUMW {
                _CRCCHKSUMW { w: self }
            }
        }
    }
    #[doc = "CRC Control"]
    pub struct CRCCTRL {
        register: VolatileCell<u16>,
    }
    #[doc = "CRC Control"]
    pub mod crcctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::CRCCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CRCBEATSIZE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCBEATSIZER {
            #[doc = "Byte bus access"]
            BYTE,
            #[doc = "Half-word bus access"]
            HWORD,
            #[doc = "Word bus access"]
            WORD,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CRCBEATSIZER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CRCBEATSIZER::BYTE => 0,
                    CRCBEATSIZER::HWORD => 1,
                    CRCBEATSIZER::WORD => 2,
                    CRCBEATSIZER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CRCBEATSIZER {
                match value {
                    0 => CRCBEATSIZER::BYTE,
                    1 => CRCBEATSIZER::HWORD,
                    2 => CRCBEATSIZER::WORD,
                    i => CRCBEATSIZER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `BYTE`"]
            #[inline(always)]
            pub fn is_byte(&self) -> bool {
                *self == CRCBEATSIZER::BYTE
            }
            #[doc = "Checks if the value of the field is `HWORD`"]
            #[inline(always)]
            pub fn is_hword(&self) -> bool {
                *self == CRCBEATSIZER::HWORD
            }
            #[doc = "Checks if the value of the field is `WORD`"]
            #[inline(always)]
            pub fn is_word(&self) -> bool {
                *self == CRCBEATSIZER::WORD
            }
        }
        #[doc = "Possible values of the field `CRCPOLY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCPOLYR {
            #[doc = "CRC-16 (CRC-CCITT)"]
            CRC16,
            #[doc = "CRC32 (IEEE 802.3)"]
            CRC32,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CRCPOLYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CRCPOLYR::CRC16 => 0,
                    CRCPOLYR::CRC32 => 1,
                    CRCPOLYR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CRCPOLYR {
                match value {
                    0 => CRCPOLYR::CRC16,
                    1 => CRCPOLYR::CRC32,
                    i => CRCPOLYR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `CRC16`"]
            #[inline(always)]
            pub fn is_crc16(&self) -> bool {
                *self == CRCPOLYR::CRC16
            }
            #[doc = "Checks if the value of the field is `CRC32`"]
            #[inline(always)]
            pub fn is_crc32(&self) -> bool {
                *self == CRCPOLYR::CRC32
            }
        }
        #[doc = "Possible values of the field `CRCSRC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCSRCR {
            #[doc = "No action"]
            NOACT,
            #[doc = "I/O interface"]
            IO,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CRCSRCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CRCSRCR::NOACT => 0,
                    CRCSRCR::IO => 1,
                    CRCSRCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CRCSRCR {
                match value {
                    0 => CRCSRCR::NOACT,
                    1 => CRCSRCR::IO,
                    i => CRCSRCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NOACT`"]
            #[inline(always)]
            pub fn is_noact(&self) -> bool {
                *self == CRCSRCR::NOACT
            }
            #[doc = "Checks if the value of the field is `IO`"]
            #[inline(always)]
            pub fn is_io(&self) -> bool {
                *self == CRCSRCR::IO
            }
        }
        #[doc = "Values that can be written to the field `CRCBEATSIZE`"]
        pub enum CRCBEATSIZEW {
            #[doc = "Byte bus access"]
            BYTE,
            #[doc = "Half-word bus access"]
            HWORD,
            #[doc = "Word bus access"]
            WORD,
        }
        impl CRCBEATSIZEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CRCBEATSIZEW::BYTE => 0,
                    CRCBEATSIZEW::HWORD => 1,
                    CRCBEATSIZEW::WORD => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCBEATSIZEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCBEATSIZEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCBEATSIZEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Byte bus access"]
            #[inline(always)]
            pub fn byte(self) -> &'a mut W {
                self.variant(CRCBEATSIZEW::BYTE)
            }
            #[doc = "Half-word bus access"]
            #[inline(always)]
            pub fn hword(self) -> &'a mut W {
                self.variant(CRCBEATSIZEW::HWORD)
            }
            #[doc = "Word bus access"]
            #[inline(always)]
            pub fn word(self) -> &'a mut W {
                self.variant(CRCBEATSIZEW::WORD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CRCPOLY`"]
        pub enum CRCPOLYW {
            #[doc = "CRC-16 (CRC-CCITT)"]
            CRC16,
            #[doc = "CRC32 (IEEE 802.3)"]
            CRC32,
        }
        impl CRCPOLYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CRCPOLYW::CRC16 => 0,
                    CRCPOLYW::CRC32 => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCPOLYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCPOLYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCPOLYW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "CRC-16 (CRC-CCITT)"]
            #[inline(always)]
            pub fn crc16(self) -> &'a mut W {
                self.variant(CRCPOLYW::CRC16)
            }
            #[doc = "CRC32 (IEEE 802.3)"]
            #[inline(always)]
            pub fn crc32(self) -> &'a mut W {
                self.variant(CRCPOLYW::CRC32)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CRCSRC`"]
        pub enum CRCSRCW {
            #[doc = "No action"]
            NOACT,
            #[doc = "I/O interface"]
            IO,
        }
        impl CRCSRCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CRCSRCW::NOACT => 0,
                    CRCSRCW::IO => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCSRCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCSRCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCSRCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No action"]
            #[inline(always)]
            pub fn noact(self) -> &'a mut W {
                self.variant(CRCSRCW::NOACT)
            }
            #[doc = "I/O interface"]
            #[inline(always)]
            pub fn io(self) -> &'a mut W {
                self.variant(CRCSRCW::IO)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:1 - CRC Beat Size"]
            #[inline(always)]
            pub fn crcbeatsize(&self) -> CRCBEATSIZER {
                CRCBEATSIZER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 2:3 - CRC Polynomial Type"]
            #[inline(always)]
            pub fn crcpoly(&self) -> CRCPOLYR {
                CRCPOLYR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 8:13 - CRC Input Source"]
            #[inline(always)]
            pub fn crcsrc(&self) -> CRCSRCR {
                CRCSRCR::_from({
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - CRC Beat Size"]
            #[inline(always)]
            pub fn crcbeatsize(&mut self) -> _CRCBEATSIZEW {
                _CRCBEATSIZEW { w: self }
            }
            #[doc = "Bits 2:3 - CRC Polynomial Type"]
            #[inline(always)]
            pub fn crcpoly(&mut self) -> _CRCPOLYW {
                _CRCPOLYW { w: self }
            }
            #[doc = "Bits 8:13 - CRC Input Source"]
            #[inline(always)]
            pub fn crcsrc(&mut self) -> _CRCSRCW {
                _CRCSRCW { w: self }
            }
        }
    }
    #[doc = "CRC Data Input"]
    pub struct CRCDATAIN {
        register: VolatileCell<u32>,
    }
    #[doc = "CRC Data Input"]
    pub mod crcdatain {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CRCDATAIN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRCDATAINR {
            bits: u32,
        }
        impl CRCDATAINR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCDATAINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCDATAINW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - CRC Data Input"]
            #[inline(always)]
            pub fn crcdatain(&self) -> CRCDATAINR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CRCDATAINR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - CRC Data Input"]
            #[inline(always)]
            pub fn crcdatain(&mut self) -> _CRCDATAINW {
                _CRCDATAINW { w: self }
            }
        }
    }
    #[doc = "CRC Status"]
    pub struct CRCSTATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "CRC Status"]
    pub mod crcstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CRCSTATUS {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRCBUSYR {
            bits: bool,
        }
        impl CRCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRCZEROR {
            bits: bool,
        }
        impl CRCZEROR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCBUSYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCBUSYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - CRC Module Busy"]
            #[inline(always)]
            pub fn crcbusy(&self) -> CRCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CRCBUSYR { bits }
            }
            #[doc = "Bit 1 - CRC Zero"]
            #[inline(always)]
            pub fn crczero(&self) -> CRCZEROR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CRCZEROR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - CRC Module Busy"]
            #[inline(always)]
            pub fn crcbusy(&mut self) -> _CRCBUSYW {
                _CRCBUSYW { w: self }
            }
        }
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u16>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMAENABLER {
            bits: bool,
        }
        impl DMAENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRCENABLER {
            bits: bool,
        }
        impl CRCENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LVLEN0R {
            bits: bool,
        }
        impl LVLEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LVLEN1R {
            bits: bool,
        }
        impl LVLEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LVLEN2R {
            bits: bool,
        }
        impl LVLEN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LVLEN3R {
            bits: bool,
        }
        impl LVLEN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMAENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMAENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LVLEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LVLEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LVLEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LVLEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LVLEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LVLEN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LVLEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LVLEN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                SWRSTR { bits }
            }
            #[doc = "Bit 1 - DMA Enable"]
            #[inline(always)]
            pub fn dmaenable(&self) -> DMAENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                DMAENABLER { bits }
            }
            #[doc = "Bit 2 - CRC Enable"]
            #[inline(always)]
            pub fn crcenable(&self) -> CRCENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                CRCENABLER { bits }
            }
            #[doc = "Bit 8 - Priority Level 0 Enable"]
            #[inline(always)]
            pub fn lvlen0(&self) -> LVLEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                LVLEN0R { bits }
            }
            #[doc = "Bit 9 - Priority Level 1 Enable"]
            #[inline(always)]
            pub fn lvlen1(&self) -> LVLEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                LVLEN1R { bits }
            }
            #[doc = "Bit 10 - Priority Level 2 Enable"]
            #[inline(always)]
            pub fn lvlen2(&self) -> LVLEN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                LVLEN2R { bits }
            }
            #[doc = "Bit 11 - Priority Level 3 Enable"]
            #[inline(always)]
            pub fn lvlen3(&self) -> LVLEN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                LVLEN3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - DMA Enable"]
            #[inline(always)]
            pub fn dmaenable(&mut self) -> _DMAENABLEW {
                _DMAENABLEW { w: self }
            }
            #[doc = "Bit 2 - CRC Enable"]
            #[inline(always)]
            pub fn crcenable(&mut self) -> _CRCENABLEW {
                _CRCENABLEW { w: self }
            }
            #[doc = "Bit 8 - Priority Level 0 Enable"]
            #[inline(always)]
            pub fn lvlen0(&mut self) -> _LVLEN0W {
                _LVLEN0W { w: self }
            }
            #[doc = "Bit 9 - Priority Level 1 Enable"]
            #[inline(always)]
            pub fn lvlen1(&mut self) -> _LVLEN1W {
                _LVLEN1W { w: self }
            }
            #[doc = "Bit 10 - Priority Level 2 Enable"]
            #[inline(always)]
            pub fn lvlen2(&mut self) -> _LVLEN2W {
                _LVLEN2W { w: self }
            }
            #[doc = "Bit 11 - Priority Level 3 Enable"]
            #[inline(always)]
            pub fn lvlen3(&mut self) -> _LVLEN3W {
                _LVLEN3W { w: self }
            }
        }
    }
    #[doc = "Debug Control"]
    pub struct DBGCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Debug Control"]
    pub mod dbgctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::DBGCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBGRUNR {
            bits: bool,
        }
        impl DBGRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBGRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBGRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Debug Run"]
            #[inline(always)]
            pub fn dbgrun(&self) -> DBGRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DBGRUNR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Debug Run"]
            #[inline(always)]
            pub fn dbgrun(&mut self) -> _DBGRUNW {
                _DBGRUNW { w: self }
            }
        }
    }
    #[doc = "Interrupt Pending"]
    pub struct INTPEND {
        register: VolatileCell<u16>,
    }
    #[doc = "Interrupt Pending"]
    pub mod intpend {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::INTPEND {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDR {
            bits: u8,
        }
        impl IDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TERRR {
            bits: bool,
        }
        impl TERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCMPLR {
            bits: bool,
        }
        impl TCMPLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SUSPR {
            bits: bool,
        }
        impl SUSPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FERRR {
            bits: bool,
        }
        impl FERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYR {
            bits: bool,
        }
        impl BUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDR {
            bits: bool,
        }
        impl PENDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCMPLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCMPLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SUSPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SUSPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:3 - Channel ID"]
            #[inline(always)]
            pub fn id(&self) -> IDR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                IDR { bits }
            }
            #[doc = "Bit 8 - Transfer Error"]
            #[inline(always)]
            pub fn terr(&self) -> TERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TERRR { bits }
            }
            #[doc = "Bit 9 - Transfer Complete"]
            #[inline(always)]
            pub fn tcmpl(&self) -> TCMPLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TCMPLR { bits }
            }
            #[doc = "Bit 10 - Channel Suspend"]
            #[inline(always)]
            pub fn susp(&self) -> SUSPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                SUSPR { bits }
            }
            #[doc = "Bit 13 - Fetch Error"]
            #[inline(always)]
            pub fn ferr(&self) -> FERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                FERRR { bits }
            }
            #[doc = "Bit 14 - Busy"]
            #[inline(always)]
            pub fn busy(&self) -> BUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                BUSYR { bits }
            }
            #[doc = "Bit 15 - Pending"]
            #[inline(always)]
            pub fn pend(&self) -> PENDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PENDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Channel ID"]
            #[inline(always)]
            pub fn id(&mut self) -> _IDW {
                _IDW { w: self }
            }
            #[doc = "Bit 8 - Transfer Error"]
            #[inline(always)]
            pub fn terr(&mut self) -> _TERRW {
                _TERRW { w: self }
            }
            #[doc = "Bit 9 - Transfer Complete"]
            #[inline(always)]
            pub fn tcmpl(&mut self) -> _TCMPLW {
                _TCMPLW { w: self }
            }
            #[doc = "Bit 10 - Channel Suspend"]
            #[inline(always)]
            pub fn susp(&mut self) -> _SUSPW {
                _SUSPW { w: self }
            }
        }
    }
    #[doc = "Interrupt Status"]
    pub struct INTSTATUS {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Status"]
    pub mod intstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::INTSTATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHINT0R {
            bits: bool,
        }
        impl CHINT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHINT1R {
            bits: bool,
        }
        impl CHINT1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHINT2R {
            bits: bool,
        }
        impl CHINT2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHINT3R {
            bits: bool,
        }
        impl CHINT3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHINT4R {
            bits: bool,
        }
        impl CHINT4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHINT5R {
            bits: bool,
        }
        impl CHINT5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHINT6R {
            bits: bool,
        }
        impl CHINT6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHINT7R {
            bits: bool,
        }
        impl CHINT7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHINT8R {
            bits: bool,
        }
        impl CHINT8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHINT9R {
            bits: bool,
        }
        impl CHINT9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHINT10R {
            bits: bool,
        }
        impl CHINT10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHINT11R {
            bits: bool,
        }
        impl CHINT11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel 0 Pending Interrupt"]
            #[inline(always)]
            pub fn chint0(&self) -> CHINT0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHINT0R { bits }
            }
            #[doc = "Bit 1 - Channel 1 Pending Interrupt"]
            #[inline(always)]
            pub fn chint1(&self) -> CHINT1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHINT1R { bits }
            }
            #[doc = "Bit 2 - Channel 2 Pending Interrupt"]
            #[inline(always)]
            pub fn chint2(&self) -> CHINT2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHINT2R { bits }
            }
            #[doc = "Bit 3 - Channel 3 Pending Interrupt"]
            #[inline(always)]
            pub fn chint3(&self) -> CHINT3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHINT3R { bits }
            }
            #[doc = "Bit 4 - Channel 4 Pending Interrupt"]
            #[inline(always)]
            pub fn chint4(&self) -> CHINT4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHINT4R { bits }
            }
            #[doc = "Bit 5 - Channel 5 Pending Interrupt"]
            #[inline(always)]
            pub fn chint5(&self) -> CHINT5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHINT5R { bits }
            }
            #[doc = "Bit 6 - Channel 6 Pending Interrupt"]
            #[inline(always)]
            pub fn chint6(&self) -> CHINT6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHINT6R { bits }
            }
            #[doc = "Bit 7 - Channel 7 Pending Interrupt"]
            #[inline(always)]
            pub fn chint7(&self) -> CHINT7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHINT7R { bits }
            }
            #[doc = "Bit 8 - Channel 8 Pending Interrupt"]
            #[inline(always)]
            pub fn chint8(&self) -> CHINT8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHINT8R { bits }
            }
            #[doc = "Bit 9 - Channel 9 Pending Interrupt"]
            #[inline(always)]
            pub fn chint9(&self) -> CHINT9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHINT9R { bits }
            }
            #[doc = "Bit 10 - Channel 10 Pending Interrupt"]
            #[inline(always)]
            pub fn chint10(&self) -> CHINT10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHINT10R { bits }
            }
            #[doc = "Bit 11 - Channel 11 Pending Interrupt"]
            #[inline(always)]
            pub fn chint11(&self) -> CHINT11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHINT11R { bits }
            }
        }
    }
    #[doc = "Pending Channels"]
    pub struct PENDCH {
        register: VolatileCell<u32>,
    }
    #[doc = "Pending Channels"]
    pub mod pendch {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PENDCH {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDCH0R {
            bits: bool,
        }
        impl PENDCH0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDCH1R {
            bits: bool,
        }
        impl PENDCH1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDCH2R {
            bits: bool,
        }
        impl PENDCH2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDCH3R {
            bits: bool,
        }
        impl PENDCH3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDCH4R {
            bits: bool,
        }
        impl PENDCH4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDCH5R {
            bits: bool,
        }
        impl PENDCH5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDCH6R {
            bits: bool,
        }
        impl PENDCH6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDCH7R {
            bits: bool,
        }
        impl PENDCH7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDCH8R {
            bits: bool,
        }
        impl PENDCH8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDCH9R {
            bits: bool,
        }
        impl PENDCH9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDCH10R {
            bits: bool,
        }
        impl PENDCH10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PENDCH11R {
            bits: bool,
        }
        impl PENDCH11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Pending Channel 0"]
            #[inline(always)]
            pub fn pendch0(&self) -> PENDCH0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PENDCH0R { bits }
            }
            #[doc = "Bit 1 - Pending Channel 1"]
            #[inline(always)]
            pub fn pendch1(&self) -> PENDCH1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PENDCH1R { bits }
            }
            #[doc = "Bit 2 - Pending Channel 2"]
            #[inline(always)]
            pub fn pendch2(&self) -> PENDCH2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PENDCH2R { bits }
            }
            #[doc = "Bit 3 - Pending Channel 3"]
            #[inline(always)]
            pub fn pendch3(&self) -> PENDCH3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PENDCH3R { bits }
            }
            #[doc = "Bit 4 - Pending Channel 4"]
            #[inline(always)]
            pub fn pendch4(&self) -> PENDCH4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PENDCH4R { bits }
            }
            #[doc = "Bit 5 - Pending Channel 5"]
            #[inline(always)]
            pub fn pendch5(&self) -> PENDCH5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PENDCH5R { bits }
            }
            #[doc = "Bit 6 - Pending Channel 6"]
            #[inline(always)]
            pub fn pendch6(&self) -> PENDCH6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PENDCH6R { bits }
            }
            #[doc = "Bit 7 - Pending Channel 7"]
            #[inline(always)]
            pub fn pendch7(&self) -> PENDCH7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PENDCH7R { bits }
            }
            #[doc = "Bit 8 - Pending Channel 8"]
            #[inline(always)]
            pub fn pendch8(&self) -> PENDCH8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PENDCH8R { bits }
            }
            #[doc = "Bit 9 - Pending Channel 9"]
            #[inline(always)]
            pub fn pendch9(&self) -> PENDCH9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PENDCH9R { bits }
            }
            #[doc = "Bit 10 - Pending Channel 10"]
            #[inline(always)]
            pub fn pendch10(&self) -> PENDCH10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PENDCH10R { bits }
            }
            #[doc = "Bit 11 - Pending Channel 11"]
            #[inline(always)]
            pub fn pendch11(&self) -> PENDCH11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PENDCH11R { bits }
            }
        }
    }
    #[doc = "Priority Control 0"]
    pub struct PRICTRL0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Priority Control 0"]
    pub mod prictrl0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PRICTRL0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LVLPRI0R {
            bits: u8,
        }
        impl LVLPRI0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RRLVLEN0R {
            bits: bool,
        }
        impl RRLVLEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LVLPRI1R {
            bits: u8,
        }
        impl LVLPRI1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RRLVLEN1R {
            bits: bool,
        }
        impl RRLVLEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LVLPRI2R {
            bits: u8,
        }
        impl LVLPRI2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RRLVLEN2R {
            bits: bool,
        }
        impl RRLVLEN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LVLPRI3R {
            bits: u8,
        }
        impl LVLPRI3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RRLVLEN3R {
            bits: bool,
        }
        impl RRLVLEN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _LVLPRI0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LVLPRI0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RRLVLEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RRLVLEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LVLPRI1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LVLPRI1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RRLVLEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RRLVLEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LVLPRI2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LVLPRI2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RRLVLEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RRLVLEN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LVLPRI3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LVLPRI3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RRLVLEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RRLVLEN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Level 0 Channel Priority Number"]
            #[inline(always)]
            pub fn lvlpri0(&self) -> LVLPRI0R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LVLPRI0R { bits }
            }
            #[doc = "Bit 7 - Level 0 Round-Robin Scheduling Enable"]
            #[inline(always)]
            pub fn rrlvlen0(&self) -> RRLVLEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RRLVLEN0R { bits }
            }
            #[doc = "Bits 8:11 - Level 1 Channel Priority Number"]
            #[inline(always)]
            pub fn lvlpri1(&self) -> LVLPRI1R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LVLPRI1R { bits }
            }
            #[doc = "Bit 15 - Level 1 Round-Robin Scheduling Enable"]
            #[inline(always)]
            pub fn rrlvlen1(&self) -> RRLVLEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RRLVLEN1R { bits }
            }
            #[doc = "Bits 16:19 - Level 2 Channel Priority Number"]
            #[inline(always)]
            pub fn lvlpri2(&self) -> LVLPRI2R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LVLPRI2R { bits }
            }
            #[doc = "Bit 23 - Level 2 Round-Robin Scheduling Enable"]
            #[inline(always)]
            pub fn rrlvlen2(&self) -> RRLVLEN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RRLVLEN2R { bits }
            }
            #[doc = "Bits 24:27 - Level 3 Channel Priority Number"]
            #[inline(always)]
            pub fn lvlpri3(&self) -> LVLPRI3R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LVLPRI3R { bits }
            }
            #[doc = "Bit 31 - Level 3 Round-Robin Scheduling Enable"]
            #[inline(always)]
            pub fn rrlvlen3(&self) -> RRLVLEN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RRLVLEN3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Level 0 Channel Priority Number"]
            #[inline(always)]
            pub fn lvlpri0(&mut self) -> _LVLPRI0W {
                _LVLPRI0W { w: self }
            }
            #[doc = "Bit 7 - Level 0 Round-Robin Scheduling Enable"]
            #[inline(always)]
            pub fn rrlvlen0(&mut self) -> _RRLVLEN0W {
                _RRLVLEN0W { w: self }
            }
            #[doc = "Bits 8:11 - Level 1 Channel Priority Number"]
            #[inline(always)]
            pub fn lvlpri1(&mut self) -> _LVLPRI1W {
                _LVLPRI1W { w: self }
            }
            #[doc = "Bit 15 - Level 1 Round-Robin Scheduling Enable"]
            #[inline(always)]
            pub fn rrlvlen1(&mut self) -> _RRLVLEN1W {
                _RRLVLEN1W { w: self }
            }
            #[doc = "Bits 16:19 - Level 2 Channel Priority Number"]
            #[inline(always)]
            pub fn lvlpri2(&mut self) -> _LVLPRI2W {
                _LVLPRI2W { w: self }
            }
            #[doc = "Bit 23 - Level 2 Round-Robin Scheduling Enable"]
            #[inline(always)]
            pub fn rrlvlen2(&mut self) -> _RRLVLEN2W {
                _RRLVLEN2W { w: self }
            }
            #[doc = "Bits 24:27 - Level 3 Channel Priority Number"]
            #[inline(always)]
            pub fn lvlpri3(&mut self) -> _LVLPRI3W {
                _LVLPRI3W { w: self }
            }
            #[doc = "Bit 31 - Level 3 Round-Robin Scheduling Enable"]
            #[inline(always)]
            pub fn rrlvlen3(&mut self) -> _RRLVLEN3W {
                _RRLVLEN3W { w: self }
            }
        }
    }
    #[doc = "Software Trigger Control"]
    pub struct SWTRIGCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Software Trigger Control"]
    pub mod swtrigctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SWTRIGCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWTRIG0R {
            bits: bool,
        }
        impl SWTRIG0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWTRIG1R {
            bits: bool,
        }
        impl SWTRIG1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWTRIG2R {
            bits: bool,
        }
        impl SWTRIG2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWTRIG3R {
            bits: bool,
        }
        impl SWTRIG3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWTRIG4R {
            bits: bool,
        }
        impl SWTRIG4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWTRIG5R {
            bits: bool,
        }
        impl SWTRIG5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWTRIG6R {
            bits: bool,
        }
        impl SWTRIG6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWTRIG7R {
            bits: bool,
        }
        impl SWTRIG7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWTRIG8R {
            bits: bool,
        }
        impl SWTRIG8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWTRIG9R {
            bits: bool,
        }
        impl SWTRIG9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWTRIG10R {
            bits: bool,
        }
        impl SWTRIG10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWTRIG11R {
            bits: bool,
        }
        impl SWTRIG11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel 0 Software Trigger"]
            #[inline(always)]
            pub fn swtrig0(&self) -> SWTRIG0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWTRIG0R { bits }
            }
            #[doc = "Bit 1 - Channel 1 Software Trigger"]
            #[inline(always)]
            pub fn swtrig1(&self) -> SWTRIG1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWTRIG1R { bits }
            }
            #[doc = "Bit 2 - Channel 2 Software Trigger"]
            #[inline(always)]
            pub fn swtrig2(&self) -> SWTRIG2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWTRIG2R { bits }
            }
            #[doc = "Bit 3 - Channel 3 Software Trigger"]
            #[inline(always)]
            pub fn swtrig3(&self) -> SWTRIG3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWTRIG3R { bits }
            }
            #[doc = "Bit 4 - Channel 4 Software Trigger"]
            #[inline(always)]
            pub fn swtrig4(&self) -> SWTRIG4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWTRIG4R { bits }
            }
            #[doc = "Bit 5 - Channel 5 Software Trigger"]
            #[inline(always)]
            pub fn swtrig5(&self) -> SWTRIG5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWTRIG5R { bits }
            }
            #[doc = "Bit 6 - Channel 6 Software Trigger"]
            #[inline(always)]
            pub fn swtrig6(&self) -> SWTRIG6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWTRIG6R { bits }
            }
            #[doc = "Bit 7 - Channel 7 Software Trigger"]
            #[inline(always)]
            pub fn swtrig7(&self) -> SWTRIG7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWTRIG7R { bits }
            }
            #[doc = "Bit 8 - Channel 8 Software Trigger"]
            #[inline(always)]
            pub fn swtrig8(&self) -> SWTRIG8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWTRIG8R { bits }
            }
            #[doc = "Bit 9 - Channel 9 Software Trigger"]
            #[inline(always)]
            pub fn swtrig9(&self) -> SWTRIG9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWTRIG9R { bits }
            }
            #[doc = "Bit 10 - Channel 10 Software Trigger"]
            #[inline(always)]
            pub fn swtrig10(&self) -> SWTRIG10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWTRIG10R { bits }
            }
            #[doc = "Bit 11 - Channel 11 Software Trigger"]
            #[inline(always)]
            pub fn swtrig11(&self) -> SWTRIG11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWTRIG11R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel 0 Software Trigger"]
            #[inline(always)]
            pub fn swtrig0(&mut self) -> _SWTRIG0W {
                _SWTRIG0W { w: self }
            }
            #[doc = "Bit 1 - Channel 1 Software Trigger"]
            #[inline(always)]
            pub fn swtrig1(&mut self) -> _SWTRIG1W {
                _SWTRIG1W { w: self }
            }
            #[doc = "Bit 2 - Channel 2 Software Trigger"]
            #[inline(always)]
            pub fn swtrig2(&mut self) -> _SWTRIG2W {
                _SWTRIG2W { w: self }
            }
            #[doc = "Bit 3 - Channel 3 Software Trigger"]
            #[inline(always)]
            pub fn swtrig3(&mut self) -> _SWTRIG3W {
                _SWTRIG3W { w: self }
            }
            #[doc = "Bit 4 - Channel 4 Software Trigger"]
            #[inline(always)]
            pub fn swtrig4(&mut self) -> _SWTRIG4W {
                _SWTRIG4W { w: self }
            }
            #[doc = "Bit 5 - Channel 5 Software Trigger"]
            #[inline(always)]
            pub fn swtrig5(&mut self) -> _SWTRIG5W {
                _SWTRIG5W { w: self }
            }
            #[doc = "Bit 6 - Channel 6 Software Trigger"]
            #[inline(always)]
            pub fn swtrig6(&mut self) -> _SWTRIG6W {
                _SWTRIG6W { w: self }
            }
            #[doc = "Bit 7 - Channel 7 Software Trigger"]
            #[inline(always)]
            pub fn swtrig7(&mut self) -> _SWTRIG7W {
                _SWTRIG7W { w: self }
            }
            #[doc = "Bit 8 - Channel 8 Software Trigger"]
            #[inline(always)]
            pub fn swtrig8(&mut self) -> _SWTRIG8W {
                _SWTRIG8W { w: self }
            }
            #[doc = "Bit 9 - Channel 9 Software Trigger"]
            #[inline(always)]
            pub fn swtrig9(&mut self) -> _SWTRIG9W {
                _SWTRIG9W { w: self }
            }
            #[doc = "Bit 10 - Channel 10 Software Trigger"]
            #[inline(always)]
            pub fn swtrig10(&mut self) -> _SWTRIG10W {
                _SWTRIG10W { w: self }
            }
            #[doc = "Bit 11 - Channel 11 Software Trigger"]
            #[inline(always)]
            pub fn swtrig11(&mut self) -> _SWTRIG11W {
                _SWTRIG11W { w: self }
            }
        }
    }
    #[doc = "Write-Back Memory Section Base Address"]
    pub struct WRBADDR {
        register: VolatileCell<u32>,
    }
    #[doc = "Write-Back Memory Section Base Address"]
    pub mod wrbaddr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WRBADDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRBADDRR {
            bits: u32,
        }
        impl WRBADDRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRBADDRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRBADDRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Write-Back Memory Base Address"]
            #[inline(always)]
            pub fn wrbaddr(&self) -> WRBADDRR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                WRBADDRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Write-Back Memory Base Address"]
            #[inline(always)]
            pub fn wrbaddr(&mut self) -> _WRBADDRW {
                _WRBADDRW { w: self }
            }
        }
    }
}
#[doc = "Direct Memory Access Controller"]
pub struct DMAC {
    register_block: dmac::RegisterBlock,
}
impl Deref for DMAC {
    type Target = dmac::RegisterBlock;
    fn deref(&self) -> &dmac::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Device Service Unit"]
pub const DSU: Peripheral<DSU> = unsafe { Peripheral::new(1090527232) };
#[doc = "Device Service Unit"]
pub mod dsu {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctrl: CTRL,
        #[doc = "0x01 - Status A"]
        pub statusa: STATUSA,
        #[doc = "0x02 - Status B"]
        pub statusb: STATUSB,
        _reserved0: [u8; 1usize],
        #[doc = "0x04 - Address"]
        pub addr: ADDR,
        #[doc = "0x08 - Length"]
        pub length: LENGTH,
        #[doc = "0x0c - Data"]
        pub data: DATA,
        #[doc = "0x10 - Debug Communication Channel n"]
        pub dcc0: DCC,
        #[doc = "0x14 - Debug Communication Channel n"]
        pub dcc1: DCC,
        #[doc = "0x18 - Device Identification"]
        pub did: DID,
        _reserved1: [u8; 4068usize],
        #[doc = "0x1000 - Coresight ROM Table Entry n"]
        pub entry0: ENTRY,
        #[doc = "0x1004 - Coresight ROM Table Entry n"]
        pub entry1: ENTRY,
        #[doc = "0x1008 - Coresight ROM Table End"]
        pub end: END,
        _reserved2: [u8; 4032usize],
        #[doc = "0x1fcc - Coresight ROM Table Memory Type"]
        pub memtype: MEMTYPE,
        #[doc = "0x1fd0 - Peripheral Identification 4"]
        pub pid4: PID4,
        _reserved3: [u8; 12usize],
        #[doc = "0x1fe0 - Peripheral Identification 0"]
        pub pid0: PID0,
        #[doc = "0x1fe4 - Peripheral Identification 1"]
        pub pid1: PID1,
        #[doc = "0x1fe8 - Peripheral Identification 2"]
        pub pid2: PID2,
        #[doc = "0x1fec - Peripheral Identification 3"]
        pub pid3: PID3,
        #[doc = "0x1ff0 - Component Identification 0"]
        pub cid0: CID0,
        #[doc = "0x1ff4 - Component Identification 1"]
        pub cid1: CID1,
        #[doc = "0x1ff8 - Component Identification 2"]
        pub cid2: CID2,
        #[doc = "0x1ffc - Component Identification 3"]
        pub cid3: CID3,
    }
    #[doc = "Address"]
    pub struct ADDR {
        register: VolatileCell<u32>,
    }
    #[doc = "Address"]
    pub mod addr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ADDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDRR {
            bits: u32,
        }
        impl ADDRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 1073741823;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 2:31 - Address"]
            #[inline(always)]
            pub fn addr(&self) -> ADDRR {
                let bits = {
                    const MASK: u32 = 1073741823;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                ADDRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 2:31 - Address"]
            #[inline(always)]
            pub fn addr(&mut self) -> _ADDRW {
                _ADDRW { w: self }
            }
        }
    }
    #[doc = "Component Identification 0"]
    pub struct CID0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Component Identification 0"]
    pub mod cid0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CID0 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PREAMBLEB0R {
            bits: u8,
        }
        impl PREAMBLEB0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Preamble Byte 0"]
            #[inline(always)]
            pub fn preambleb0(&self) -> PREAMBLEB0R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PREAMBLEB0R { bits }
            }
        }
    }
    #[doc = "Component Identification 1"]
    pub struct CID1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Component Identification 1"]
    pub mod cid1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CID1 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PREAMBLER {
            bits: u8,
        }
        impl PREAMBLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCLASSR {
            bits: u8,
        }
        impl CCLASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Preamble"]
            #[inline(always)]
            pub fn preamble(&self) -> PREAMBLER {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PREAMBLER { bits }
            }
            #[doc = "Bits 4:7 - Component Class"]
            #[inline(always)]
            pub fn cclass(&self) -> CCLASSR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CCLASSR { bits }
            }
        }
    }
    #[doc = "Component Identification 2"]
    pub struct CID2 {
        register: VolatileCell<u32>,
    }
    #[doc = "Component Identification 2"]
    pub mod cid2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CID2 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PREAMBLEB2R {
            bits: u8,
        }
        impl PREAMBLEB2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Preamble Byte 2"]
            #[inline(always)]
            pub fn preambleb2(&self) -> PREAMBLEB2R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PREAMBLEB2R { bits }
            }
        }
    }
    #[doc = "Component Identification 3"]
    pub struct CID3 {
        register: VolatileCell<u32>,
    }
    #[doc = "Component Identification 3"]
    pub mod cid3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CID3 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PREAMBLEB3R {
            bits: u8,
        }
        impl PREAMBLEB3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Preamble Byte 3"]
            #[inline(always)]
            pub fn preambleb3(&self) -> PREAMBLEB3R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PREAMBLEB3R { bits }
            }
        }
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRL {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MBISTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MBISTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 2 - 32-bit Cyclic Redundancy Check"]
            #[inline(always)]
            pub fn crc(&mut self) -> _CRCW {
                _CRCW { w: self }
            }
            #[doc = "Bit 3 - Memory Built-In Self-Test"]
            #[inline(always)]
            pub fn mbist(&mut self) -> _MBISTW {
                _MBISTW { w: self }
            }
            #[doc = "Bit 4 - Chip Erase"]
            #[inline(always)]
            pub fn ce(&mut self) -> _CEW {
                _CEW { w: self }
            }
        }
    }
    #[doc = "Data"]
    pub struct DATA {
        register: VolatileCell<u32>,
    }
    #[doc = "Data"]
    pub mod data {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u32,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Data"]
            #[inline(always)]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Data"]
            #[inline(always)]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "Debug Communication Channel n"]
    pub struct DCC {
        register: VolatileCell<u32>,
    }
    #[doc = "Debug Communication Channel n"]
    pub mod dcc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DCC {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u32,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Data"]
            #[inline(always)]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Data"]
            #[inline(always)]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "Device Identification"]
    pub struct DID {
        register: VolatileCell<u32>,
    }
    #[doc = "Device Identification"]
    pub mod did {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DID {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEVSELR {
            bits: u8,
        }
        impl DEVSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct REVISIONR {
            bits: u8,
        }
        impl REVISIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIER {
            bits: u8,
        }
        impl DIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SERIESR {
            bits: u8,
        }
        impl SERIESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAMILYR {
            bits: u8,
        }
        impl FAMILYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PROCESSORR {
            bits: u8,
        }
        impl PROCESSORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Device Select"]
            #[inline(always)]
            pub fn devsel(&self) -> DEVSELR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DEVSELR { bits }
            }
            #[doc = "Bits 8:11 - Revision"]
            #[inline(always)]
            pub fn revision(&self) -> REVISIONR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REVISIONR { bits }
            }
            #[doc = "Bits 12:15 - Die Identification"]
            #[inline(always)]
            pub fn die(&self) -> DIER {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIER { bits }
            }
            #[doc = "Bits 16:21 - Product Series"]
            #[inline(always)]
            pub fn series(&self) -> SERIESR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SERIESR { bits }
            }
            #[doc = "Bits 23:27 - Product Family"]
            #[inline(always)]
            pub fn family(&self) -> FAMILYR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FAMILYR { bits }
            }
            #[doc = "Bits 28:31 - Processor"]
            #[inline(always)]
            pub fn processor(&self) -> PROCESSORR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PROCESSORR { bits }
            }
        }
    }
    #[doc = "Coresight ROM Table End"]
    pub struct END {
        register: VolatileCell<u32>,
    }
    #[doc = "Coresight ROM Table End"]
    pub mod end {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::END {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENDR {
            bits: u32,
        }
        impl ENDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - End Marker"]
            #[inline(always)]
            pub fn end(&self) -> ENDR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                ENDR { bits }
            }
        }
    }
    #[doc = "Coresight ROM Table Entry n"]
    pub struct ENTRY {
        register: VolatileCell<u32>,
    }
    #[doc = "Coresight ROM Table Entry n"]
    pub mod entry {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::ENTRY {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct EPRESR {
            bits: bool,
        }
        impl EPRESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FMTR {
            bits: bool,
        }
        impl FMTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDOFFR {
            bits: u32,
        }
        impl ADDOFFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Entry Present"]
            #[inline(always)]
            pub fn epres(&self) -> EPRESR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EPRESR { bits }
            }
            #[doc = "Bit 1 - Format"]
            #[inline(always)]
            pub fn fmt(&self) -> FMTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FMTR { bits }
            }
            #[doc = "Bits 12:31 - Address Offset"]
            #[inline(always)]
            pub fn addoff(&self) -> ADDOFFR {
                let bits = {
                    const MASK: u32 = 1048575;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                ADDOFFR { bits }
            }
        }
    }
    #[doc = "Length"]
    pub struct LENGTH {
        register: VolatileCell<u32>,
    }
    #[doc = "Length"]
    pub mod length {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LENGTH {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LENGTHR {
            bits: u32,
        }
        impl LENGTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LENGTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LENGTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 1073741823;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 2:31 - Length"]
            #[inline(always)]
            pub fn length(&self) -> LENGTHR {
                let bits = {
                    const MASK: u32 = 1073741823;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                LENGTHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 2:31 - Length"]
            #[inline(always)]
            pub fn length(&mut self) -> _LENGTHW {
                _LENGTHW { w: self }
            }
        }
    }
    #[doc = "Coresight ROM Table Memory Type"]
    pub struct MEMTYPE {
        register: VolatileCell<u32>,
    }
    #[doc = "Coresight ROM Table Memory Type"]
    pub mod memtype {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::MEMTYPE {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMEMPR {
            bits: bool,
        }
        impl SMEMPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - System Memory Present"]
            #[inline(always)]
            pub fn smemp(&self) -> SMEMPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SMEMPR { bits }
            }
        }
    }
    #[doc = "Peripheral Identification 0"]
    pub struct PID0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Identification 0"]
    pub mod pid0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID0 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PARTNBLR {
            bits: u8,
        }
        impl PARTNBLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Part Number Low"]
            #[inline(always)]
            pub fn partnbl(&self) -> PARTNBLR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PARTNBLR { bits }
            }
        }
    }
    #[doc = "Peripheral Identification 1"]
    pub struct PID1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Identification 1"]
    pub mod pid1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID1 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PARTNBHR {
            bits: u8,
        }
        impl PARTNBHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct JEPIDCLR {
            bits: u8,
        }
        impl JEPIDCLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Part Number High"]
            #[inline(always)]
            pub fn partnbh(&self) -> PARTNBHR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PARTNBHR { bits }
            }
            #[doc = "Bits 4:7 - Low part of the JEP-106 Identity Code"]
            #[inline(always)]
            pub fn jepidcl(&self) -> JEPIDCLR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JEPIDCLR { bits }
            }
        }
    }
    #[doc = "Peripheral Identification 2"]
    pub struct PID2 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Identification 2"]
    pub mod pid2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID2 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct JEPIDCHR {
            bits: u8,
        }
        impl JEPIDCHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct JEPUR {
            bits: bool,
        }
        impl JEPUR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct REVISIONR {
            bits: u8,
        }
        impl REVISIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - JEP-106 Identity Code High"]
            #[inline(always)]
            pub fn jepidch(&self) -> JEPIDCHR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JEPIDCHR { bits }
            }
            #[doc = "Bit 3 - JEP-106 Identity Code is used"]
            #[inline(always)]
            pub fn jepu(&self) -> JEPUR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                JEPUR { bits }
            }
            #[doc = "Bits 4:7 - Revision Number"]
            #[inline(always)]
            pub fn revision(&self) -> REVISIONR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REVISIONR { bits }
            }
        }
    }
    #[doc = "Peripheral Identification 3"]
    pub struct PID3 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Identification 3"]
    pub mod pid3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID3 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CUSMODR {
            bits: u8,
        }
        impl CUSMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct REVANDR {
            bits: u8,
        }
        impl REVANDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - ARM CUSMOD"]
            #[inline(always)]
            pub fn cusmod(&self) -> CUSMODR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CUSMODR { bits }
            }
            #[doc = "Bits 4:7 - Revision Number"]
            #[inline(always)]
            pub fn revand(&self) -> REVANDR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REVANDR { bits }
            }
        }
    }
    #[doc = "Peripheral Identification 4"]
    pub struct PID4 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Identification 4"]
    pub mod pid4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID4 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct JEPCCR {
            bits: u8,
        }
        impl JEPCCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FKBCR {
            bits: u8,
        }
        impl FKBCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - JEP-106 Continuation Code"]
            #[inline(always)]
            pub fn jepcc(&self) -> JEPCCR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JEPCCR { bits }
            }
            #[doc = "Bits 4:7 - 4KB Count"]
            #[inline(always)]
            pub fn fkbc(&self) -> FKBCR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FKBCR { bits }
            }
        }
    }
    #[doc = "Status A"]
    pub struct STATUSA {
        register: VolatileCell<u8>,
    }
    #[doc = "Status A"]
    pub mod statusa {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::STATUSA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DONER {
            bits: bool,
        }
        impl DONER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRSTEXTR {
            bits: bool,
        }
        impl CRSTEXTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BERRR {
            bits: bool,
        }
        impl BERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAILR {
            bits: bool,
        }
        impl FAILR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PERRR {
            bits: bool,
        }
        impl PERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DONEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DONEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRSTEXTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRSTEXTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAILW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAILW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Done"]
            #[inline(always)]
            pub fn done(&self) -> DONER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DONER { bits }
            }
            #[doc = "Bit 1 - CPU Reset Phase Extension"]
            #[inline(always)]
            pub fn crstext(&self) -> CRSTEXTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CRSTEXTR { bits }
            }
            #[doc = "Bit 2 - Bus Error"]
            #[inline(always)]
            pub fn berr(&self) -> BERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                BERRR { bits }
            }
            #[doc = "Bit 3 - Failure"]
            #[inline(always)]
            pub fn fail(&self) -> FAILR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                FAILR { bits }
            }
            #[doc = "Bit 4 - Protection Error"]
            #[inline(always)]
            pub fn perr(&self) -> PERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                PERRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Done"]
            #[inline(always)]
            pub fn done(&mut self) -> _DONEW {
                _DONEW { w: self }
            }
            #[doc = "Bit 1 - CPU Reset Phase Extension"]
            #[inline(always)]
            pub fn crstext(&mut self) -> _CRSTEXTW {
                _CRSTEXTW { w: self }
            }
            #[doc = "Bit 2 - Bus Error"]
            #[inline(always)]
            pub fn berr(&mut self) -> _BERRW {
                _BERRW { w: self }
            }
            #[doc = "Bit 3 - Failure"]
            #[inline(always)]
            pub fn fail(&mut self) -> _FAILW {
                _FAILW { w: self }
            }
            #[doc = "Bit 4 - Protection Error"]
            #[inline(always)]
            pub fn perr(&mut self) -> _PERRW {
                _PERRW { w: self }
            }
        }
    }
    #[doc = "Status B"]
    pub struct STATUSB {
        register: VolatileCell<u8>,
    }
    #[doc = "Status B"]
    pub mod statusb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUSB {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PROTR {
            bits: bool,
        }
        impl PROTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBGPRESR {
            bits: bool,
        }
        impl DBGPRESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DCCD0R {
            bits: bool,
        }
        impl DCCD0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DCCD1R {
            bits: bool,
        }
        impl DCCD1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HPER {
            bits: bool,
        }
        impl HPER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Protected"]
            #[inline(always)]
            pub fn prot(&self) -> PROTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                PROTR { bits }
            }
            #[doc = "Bit 1 - Debugger Present"]
            #[inline(always)]
            pub fn dbgpres(&self) -> DBGPRESR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DBGPRESR { bits }
            }
            #[doc = "Bit 2 - Debug Communication Channel 0 Dirty"]
            #[inline(always)]
            pub fn dccd0(&self) -> DCCD0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DCCD0R { bits }
            }
            #[doc = "Bit 3 - Debug Communication Channel 1 Dirty"]
            #[inline(always)]
            pub fn dccd1(&self) -> DCCD1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DCCD1R { bits }
            }
            #[doc = "Bit 4 - Hot-Plugging Enable"]
            #[inline(always)]
            pub fn hpe(&self) -> HPER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                HPER { bits }
            }
        }
    }
}
#[doc = "Device Service Unit"]
pub struct DSU {
    register_block: dsu::RegisterBlock,
}
impl Deref for DSU {
    type Target = dsu::RegisterBlock;
    fn deref(&self) -> &dsu::RegisterBlock {
        &self.register_block
    }
}
#[doc = "External Interrupt Controller"]
pub const EIC: Peripheral<EIC> = unsafe { Peripheral::new(1073747968) };
#[doc = "External Interrupt Controller"]
pub mod eic {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctrl: CTRL,
        #[doc = "0x01 - Status"]
        pub status: STATUS,
        #[doc = "0x02 - Non-Maskable Interrupt Control"]
        pub nmictrl: NMICTRL,
        #[doc = "0x03 - Non-Maskable Interrupt Flag Status and Clear"]
        pub nmiflag: NMIFLAG,
        #[doc = "0x04 - Event Control"]
        pub evctrl: EVCTRL,
        #[doc = "0x08 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x0c - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x10 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        #[doc = "0x14 - Wake-Up Enable"]
        pub wakeup: WAKEUP,
        #[doc = "0x18 - Configuration n"]
        pub config0: CONFIG,
        #[doc = "0x1c - Configuration n"]
        pub config1: CONFIG,
    }
    #[doc = "Configuration n"]
    pub struct CONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "Configuration n"]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SENSE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE0R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising-edge detection"]
            RISE,
            #[doc = "Falling-edge detection"]
            FALL,
            #[doc = "Both-edges detection"]
            BOTH,
            #[doc = "High-level detection"]
            HIGH,
            #[doc = "Low-level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE0R::NONE => 0,
                    SENSE0R::RISE => 1,
                    SENSE0R::FALL => 2,
                    SENSE0R::BOTH => 3,
                    SENSE0R::HIGH => 4,
                    SENSE0R::LOW => 5,
                    SENSE0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SENSE0R {
                match value {
                    0 => SENSE0R::NONE,
                    1 => SENSE0R::RISE,
                    2 => SENSE0R::FALL,
                    3 => SENSE0R::BOTH,
                    4 => SENSE0R::HIGH,
                    5 => SENSE0R::LOW,
                    i => SENSE0R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == SENSE0R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == SENSE0R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == SENSE0R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == SENSE0R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == SENSE0R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == SENSE0R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN0R {
            bits: bool,
        }
        impl FILTEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE1R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE1R::NONE => 0,
                    SENSE1R::RISE => 1,
                    SENSE1R::FALL => 2,
                    SENSE1R::BOTH => 3,
                    SENSE1R::HIGH => 4,
                    SENSE1R::LOW => 5,
                    SENSE1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SENSE1R {
                match value {
                    0 => SENSE1R::NONE,
                    1 => SENSE1R::RISE,
                    2 => SENSE1R::FALL,
                    3 => SENSE1R::BOTH,
                    4 => SENSE1R::HIGH,
                    5 => SENSE1R::LOW,
                    i => SENSE1R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == SENSE1R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == SENSE1R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == SENSE1R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == SENSE1R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == SENSE1R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == SENSE1R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN1R {
            bits: bool,
        }
        impl FILTEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE2R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE2R::NONE => 0,
                    SENSE2R::RISE => 1,
                    SENSE2R::FALL => 2,
                    SENSE2R::BOTH => 3,
                    SENSE2R::HIGH => 4,
                    SENSE2R::LOW => 5,
                    SENSE2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SENSE2R {
                match value {
                    0 => SENSE2R::NONE,
                    1 => SENSE2R::RISE,
                    2 => SENSE2R::FALL,
                    3 => SENSE2R::BOTH,
                    4 => SENSE2R::HIGH,
                    5 => SENSE2R::LOW,
                    i => SENSE2R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == SENSE2R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == SENSE2R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == SENSE2R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == SENSE2R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == SENSE2R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == SENSE2R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN2R {
            bits: bool,
        }
        impl FILTEN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE3R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE3R::NONE => 0,
                    SENSE3R::RISE => 1,
                    SENSE3R::FALL => 2,
                    SENSE3R::BOTH => 3,
                    SENSE3R::HIGH => 4,
                    SENSE3R::LOW => 5,
                    SENSE3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SENSE3R {
                match value {
                    0 => SENSE3R::NONE,
                    1 => SENSE3R::RISE,
                    2 => SENSE3R::FALL,
                    3 => SENSE3R::BOTH,
                    4 => SENSE3R::HIGH,
                    5 => SENSE3R::LOW,
                    i => SENSE3R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == SENSE3R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == SENSE3R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == SENSE3R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == SENSE3R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == SENSE3R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == SENSE3R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN3R {
            bits: bool,
        }
        impl FILTEN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE4R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE4R::NONE => 0,
                    SENSE4R::RISE => 1,
                    SENSE4R::FALL => 2,
                    SENSE4R::BOTH => 3,
                    SENSE4R::HIGH => 4,
                    SENSE4R::LOW => 5,
                    SENSE4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SENSE4R {
                match value {
                    0 => SENSE4R::NONE,
                    1 => SENSE4R::RISE,
                    2 => SENSE4R::FALL,
                    3 => SENSE4R::BOTH,
                    4 => SENSE4R::HIGH,
                    5 => SENSE4R::LOW,
                    i => SENSE4R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == SENSE4R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == SENSE4R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == SENSE4R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == SENSE4R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == SENSE4R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == SENSE4R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN4R {
            bits: bool,
        }
        impl FILTEN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE5R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE5R::NONE => 0,
                    SENSE5R::RISE => 1,
                    SENSE5R::FALL => 2,
                    SENSE5R::BOTH => 3,
                    SENSE5R::HIGH => 4,
                    SENSE5R::LOW => 5,
                    SENSE5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SENSE5R {
                match value {
                    0 => SENSE5R::NONE,
                    1 => SENSE5R::RISE,
                    2 => SENSE5R::FALL,
                    3 => SENSE5R::BOTH,
                    4 => SENSE5R::HIGH,
                    5 => SENSE5R::LOW,
                    i => SENSE5R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == SENSE5R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == SENSE5R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == SENSE5R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == SENSE5R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == SENSE5R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == SENSE5R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN5R {
            bits: bool,
        }
        impl FILTEN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE6R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE6R::NONE => 0,
                    SENSE6R::RISE => 1,
                    SENSE6R::FALL => 2,
                    SENSE6R::BOTH => 3,
                    SENSE6R::HIGH => 4,
                    SENSE6R::LOW => 5,
                    SENSE6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SENSE6R {
                match value {
                    0 => SENSE6R::NONE,
                    1 => SENSE6R::RISE,
                    2 => SENSE6R::FALL,
                    3 => SENSE6R::BOTH,
                    4 => SENSE6R::HIGH,
                    5 => SENSE6R::LOW,
                    i => SENSE6R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == SENSE6R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == SENSE6R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == SENSE6R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == SENSE6R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == SENSE6R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == SENSE6R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN6R {
            bits: bool,
        }
        impl FILTEN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE7R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE7R::NONE => 0,
                    SENSE7R::RISE => 1,
                    SENSE7R::FALL => 2,
                    SENSE7R::BOTH => 3,
                    SENSE7R::HIGH => 4,
                    SENSE7R::LOW => 5,
                    SENSE7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SENSE7R {
                match value {
                    0 => SENSE7R::NONE,
                    1 => SENSE7R::RISE,
                    2 => SENSE7R::FALL,
                    3 => SENSE7R::BOTH,
                    4 => SENSE7R::HIGH,
                    5 => SENSE7R::LOW,
                    i => SENSE7R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == SENSE7R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == SENSE7R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == SENSE7R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == SENSE7R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == SENSE7R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == SENSE7R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN7R {
            bits: bool,
        }
        impl FILTEN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `SENSE0`"]
        pub enum SENSE0W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising-edge detection"]
            RISE,
            #[doc = "Falling-edge detection"]
            FALL,
            #[doc = "Both-edges detection"]
            BOTH,
            #[doc = "High-level detection"]
            HIGH,
            #[doc = "Low-level detection"]
            LOW,
        }
        impl SENSE0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE0W::NONE => 0,
                    SENSE0W::RISE => 1,
                    SENSE0W::FALL => 2,
                    SENSE0W::BOTH => 3,
                    SENSE0W::HIGH => 4,
                    SENSE0W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SENSE0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE0W::NONE)
            }
            #[doc = "Rising-edge detection"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE0W::RISE)
            }
            #[doc = "Falling-edge detection"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE0W::FALL)
            }
            #[doc = "Both-edges detection"]
            #[inline(always)]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE0W::BOTH)
            }
            #[doc = "High-level detection"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE0W::HIGH)
            }
            #[doc = "Low-level detection"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE0W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE1`"]
        pub enum SENSE1W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE1W::NONE => 0,
                    SENSE1W::RISE => 1,
                    SENSE1W::FALL => 2,
                    SENSE1W::BOTH => 3,
                    SENSE1W::HIGH => 4,
                    SENSE1W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SENSE1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE1W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE1W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE1W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline(always)]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE1W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE1W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE1W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE2`"]
        pub enum SENSE2W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE2W::NONE => 0,
                    SENSE2W::RISE => 1,
                    SENSE2W::FALL => 2,
                    SENSE2W::BOTH => 3,
                    SENSE2W::HIGH => 4,
                    SENSE2W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SENSE2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE2W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE2W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE2W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline(always)]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE2W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE2W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE2W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE3`"]
        pub enum SENSE3W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE3W::NONE => 0,
                    SENSE3W::RISE => 1,
                    SENSE3W::FALL => 2,
                    SENSE3W::BOTH => 3,
                    SENSE3W::HIGH => 4,
                    SENSE3W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SENSE3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE3W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE3W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE3W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline(always)]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE3W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE3W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE3W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE4`"]
        pub enum SENSE4W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE4W::NONE => 0,
                    SENSE4W::RISE => 1,
                    SENSE4W::FALL => 2,
                    SENSE4W::BOTH => 3,
                    SENSE4W::HIGH => 4,
                    SENSE4W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SENSE4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE4W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE4W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE4W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline(always)]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE4W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE4W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE4W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE5`"]
        pub enum SENSE5W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE5W::NONE => 0,
                    SENSE5W::RISE => 1,
                    SENSE5W::FALL => 2,
                    SENSE5W::BOTH => 3,
                    SENSE5W::HIGH => 4,
                    SENSE5W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SENSE5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE5W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE5W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE5W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline(always)]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE5W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE5W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE5W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE6`"]
        pub enum SENSE6W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE6W::NONE => 0,
                    SENSE6W::RISE => 1,
                    SENSE6W::FALL => 2,
                    SENSE6W::BOTH => 3,
                    SENSE6W::HIGH => 4,
                    SENSE6W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SENSE6W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE6W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE6W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE6W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline(always)]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE6W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE6W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE6W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE7`"]
        pub enum SENSE7W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE7W::NONE => 0,
                    SENSE7W::RISE => 1,
                    SENSE7W::FALL => 2,
                    SENSE7W::BOTH => 3,
                    SENSE7W::HIGH => 4,
                    SENSE7W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SENSE7W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE7W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE7W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE7W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline(always)]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE7W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE7W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE7W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Input Sense n Configuration"]
            #[inline(always)]
            pub fn sense0(&self) -> SENSE0R {
                SENSE0R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 3 - Filter n Enable"]
            #[inline(always)]
            pub fn filten0(&self) -> FILTEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN0R { bits }
            }
            #[doc = "Bits 4:6 - Input Sense 1 Configuration"]
            #[inline(always)]
            pub fn sense1(&self) -> SENSE1R {
                SENSE1R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 7 - Filter 1 Enable"]
            #[inline(always)]
            pub fn filten1(&self) -> FILTEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN1R { bits }
            }
            #[doc = "Bits 8:10 - Input Sense 2 Configuration"]
            #[inline(always)]
            pub fn sense2(&self) -> SENSE2R {
                SENSE2R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 11 - Filter 2 Enable"]
            #[inline(always)]
            pub fn filten2(&self) -> FILTEN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN2R { bits }
            }
            #[doc = "Bits 12:14 - Input Sense 3 Configuration"]
            #[inline(always)]
            pub fn sense3(&self) -> SENSE3R {
                SENSE3R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 15 - Filter 3 Enable"]
            #[inline(always)]
            pub fn filten3(&self) -> FILTEN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN3R { bits }
            }
            #[doc = "Bits 16:18 - Input Sense 4 Configuration"]
            #[inline(always)]
            pub fn sense4(&self) -> SENSE4R {
                SENSE4R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 19 - Filter 4 Enable"]
            #[inline(always)]
            pub fn filten4(&self) -> FILTEN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN4R { bits }
            }
            #[doc = "Bits 20:22 - Input Sense 5 Configuration"]
            #[inline(always)]
            pub fn sense5(&self) -> SENSE5R {
                SENSE5R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 23 - Filter 5 Enable"]
            #[inline(always)]
            pub fn filten5(&self) -> FILTEN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN5R { bits }
            }
            #[doc = "Bits 24:26 - Input Sense 6 Configuration"]
            #[inline(always)]
            pub fn sense6(&self) -> SENSE6R {
                SENSE6R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 27 - Filter 6 Enable"]
            #[inline(always)]
            pub fn filten6(&self) -> FILTEN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN6R { bits }
            }
            #[doc = "Bits 28:30 - Input Sense 7 Configuration"]
            #[inline(always)]
            pub fn sense7(&self) -> SENSE7R {
                SENSE7R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 31 - Filter 7 Enable"]
            #[inline(always)]
            pub fn filten7(&self) -> FILTEN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Input Sense n Configuration"]
            #[inline(always)]
            pub fn sense0(&mut self) -> _SENSE0W {
                _SENSE0W { w: self }
            }
            #[doc = "Bit 3 - Filter n Enable"]
            #[inline(always)]
            pub fn filten0(&mut self) -> _FILTEN0W {
                _FILTEN0W { w: self }
            }
            #[doc = "Bits 4:6 - Input Sense 1 Configuration"]
            #[inline(always)]
            pub fn sense1(&mut self) -> _SENSE1W {
                _SENSE1W { w: self }
            }
            #[doc = "Bit 7 - Filter 1 Enable"]
            #[inline(always)]
            pub fn filten1(&mut self) -> _FILTEN1W {
                _FILTEN1W { w: self }
            }
            #[doc = "Bits 8:10 - Input Sense 2 Configuration"]
            #[inline(always)]
            pub fn sense2(&mut self) -> _SENSE2W {
                _SENSE2W { w: self }
            }
            #[doc = "Bit 11 - Filter 2 Enable"]
            #[inline(always)]
            pub fn filten2(&mut self) -> _FILTEN2W {
                _FILTEN2W { w: self }
            }
            #[doc = "Bits 12:14 - Input Sense 3 Configuration"]
            #[inline(always)]
            pub fn sense3(&mut self) -> _SENSE3W {
                _SENSE3W { w: self }
            }
            #[doc = "Bit 15 - Filter 3 Enable"]
            #[inline(always)]
            pub fn filten3(&mut self) -> _FILTEN3W {
                _FILTEN3W { w: self }
            }
            #[doc = "Bits 16:18 - Input Sense 4 Configuration"]
            #[inline(always)]
            pub fn sense4(&mut self) -> _SENSE4W {
                _SENSE4W { w: self }
            }
            #[doc = "Bit 19 - Filter 4 Enable"]
            #[inline(always)]
            pub fn filten4(&mut self) -> _FILTEN4W {
                _FILTEN4W { w: self }
            }
            #[doc = "Bits 20:22 - Input Sense 5 Configuration"]
            #[inline(always)]
            pub fn sense5(&mut self) -> _SENSE5W {
                _SENSE5W { w: self }
            }
            #[doc = "Bit 23 - Filter 5 Enable"]
            #[inline(always)]
            pub fn filten5(&mut self) -> _FILTEN5W {
                _FILTEN5W { w: self }
            }
            #[doc = "Bits 24:26 - Input Sense 6 Configuration"]
            #[inline(always)]
            pub fn sense6(&mut self) -> _SENSE6W {
                _SENSE6W { w: self }
            }
            #[doc = "Bit 27 - Filter 6 Enable"]
            #[inline(always)]
            pub fn filten6(&mut self) -> _FILTEN6W {
                _FILTEN6W { w: self }
            }
            #[doc = "Bits 28:30 - Input Sense 7 Configuration"]
            #[inline(always)]
            pub fn sense7(&mut self) -> _SENSE7W {
                _SENSE7W { w: self }
            }
            #[doc = "Bit 31 - Filter 7 Enable"]
            #[inline(always)]
            pub fn filten7(&mut self) -> _FILTEN7W {
                _FILTEN7W { w: self }
            }
        }
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SWRSTR { bits }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "Event Control"]
    pub struct EVCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Event Control"]
    pub mod evctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO0R {
            bits: bool,
        }
        impl EXTINTEO0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO1R {
            bits: bool,
        }
        impl EXTINTEO1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO2R {
            bits: bool,
        }
        impl EXTINTEO2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO3R {
            bits: bool,
        }
        impl EXTINTEO3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO4R {
            bits: bool,
        }
        impl EXTINTEO4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO5R {
            bits: bool,
        }
        impl EXTINTEO5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO6R {
            bits: bool,
        }
        impl EXTINTEO6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO7R {
            bits: bool,
        }
        impl EXTINTEO7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO8R {
            bits: bool,
        }
        impl EXTINTEO8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO9R {
            bits: bool,
        }
        impl EXTINTEO9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO10R {
            bits: bool,
        }
        impl EXTINTEO10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO11R {
            bits: bool,
        }
        impl EXTINTEO11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO12R {
            bits: bool,
        }
        impl EXTINTEO12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO13R {
            bits: bool,
        }
        impl EXTINTEO13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO14R {
            bits: bool,
        }
        impl EXTINTEO14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO15R {
            bits: bool,
        }
        impl EXTINTEO15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Interrupt 0 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo0(&self) -> EXTINTEO0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO0R { bits }
            }
            #[doc = "Bit 1 - External Interrupt 1 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo1(&self) -> EXTINTEO1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO1R { bits }
            }
            #[doc = "Bit 2 - External Interrupt 2 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo2(&self) -> EXTINTEO2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO2R { bits }
            }
            #[doc = "Bit 3 - External Interrupt 3 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo3(&self) -> EXTINTEO3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO3R { bits }
            }
            #[doc = "Bit 4 - External Interrupt 4 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo4(&self) -> EXTINTEO4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO4R { bits }
            }
            #[doc = "Bit 5 - External Interrupt 5 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo5(&self) -> EXTINTEO5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO5R { bits }
            }
            #[doc = "Bit 6 - External Interrupt 6 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo6(&self) -> EXTINTEO6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO6R { bits }
            }
            #[doc = "Bit 7 - External Interrupt 7 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo7(&self) -> EXTINTEO7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO7R { bits }
            }
            #[doc = "Bit 8 - External Interrupt 8 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo8(&self) -> EXTINTEO8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO8R { bits }
            }
            #[doc = "Bit 9 - External Interrupt 9 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo9(&self) -> EXTINTEO9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO9R { bits }
            }
            #[doc = "Bit 10 - External Interrupt 10 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo10(&self) -> EXTINTEO10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO10R { bits }
            }
            #[doc = "Bit 11 - External Interrupt 11 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo11(&self) -> EXTINTEO11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO11R { bits }
            }
            #[doc = "Bit 12 - External Interrupt 12 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo12(&self) -> EXTINTEO12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO12R { bits }
            }
            #[doc = "Bit 13 - External Interrupt 13 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo13(&self) -> EXTINTEO13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO13R { bits }
            }
            #[doc = "Bit 14 - External Interrupt 14 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo14(&self) -> EXTINTEO14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO14R { bits }
            }
            #[doc = "Bit 15 - External Interrupt 15 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo15(&self) -> EXTINTEO15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO15R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Interrupt 0 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo0(&mut self) -> _EXTINTEO0W {
                _EXTINTEO0W { w: self }
            }
            #[doc = "Bit 1 - External Interrupt 1 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo1(&mut self) -> _EXTINTEO1W {
                _EXTINTEO1W { w: self }
            }
            #[doc = "Bit 2 - External Interrupt 2 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo2(&mut self) -> _EXTINTEO2W {
                _EXTINTEO2W { w: self }
            }
            #[doc = "Bit 3 - External Interrupt 3 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo3(&mut self) -> _EXTINTEO3W {
                _EXTINTEO3W { w: self }
            }
            #[doc = "Bit 4 - External Interrupt 4 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo4(&mut self) -> _EXTINTEO4W {
                _EXTINTEO4W { w: self }
            }
            #[doc = "Bit 5 - External Interrupt 5 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo5(&mut self) -> _EXTINTEO5W {
                _EXTINTEO5W { w: self }
            }
            #[doc = "Bit 6 - External Interrupt 6 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo6(&mut self) -> _EXTINTEO6W {
                _EXTINTEO6W { w: self }
            }
            #[doc = "Bit 7 - External Interrupt 7 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo7(&mut self) -> _EXTINTEO7W {
                _EXTINTEO7W { w: self }
            }
            #[doc = "Bit 8 - External Interrupt 8 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo8(&mut self) -> _EXTINTEO8W {
                _EXTINTEO8W { w: self }
            }
            #[doc = "Bit 9 - External Interrupt 9 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo9(&mut self) -> _EXTINTEO9W {
                _EXTINTEO9W { w: self }
            }
            #[doc = "Bit 10 - External Interrupt 10 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo10(&mut self) -> _EXTINTEO10W {
                _EXTINTEO10W { w: self }
            }
            #[doc = "Bit 11 - External Interrupt 11 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo11(&mut self) -> _EXTINTEO11W {
                _EXTINTEO11W { w: self }
            }
            #[doc = "Bit 12 - External Interrupt 12 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo12(&mut self) -> _EXTINTEO12W {
                _EXTINTEO12W { w: self }
            }
            #[doc = "Bit 13 - External Interrupt 13 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo13(&mut self) -> _EXTINTEO13W {
                _EXTINTEO13W { w: self }
            }
            #[doc = "Bit 14 - External Interrupt 14 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo14(&mut self) -> _EXTINTEO14W {
                _EXTINTEO14W { w: self }
            }
            #[doc = "Bit 15 - External Interrupt 15 Event Output Enable"]
            #[inline(always)]
            pub fn extinteo15(&mut self) -> _EXTINTEO15W {
                _EXTINTEO15W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT0R {
            bits: bool,
        }
        impl EXTINT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT1R {
            bits: bool,
        }
        impl EXTINT1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT2R {
            bits: bool,
        }
        impl EXTINT2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT3R {
            bits: bool,
        }
        impl EXTINT3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT4R {
            bits: bool,
        }
        impl EXTINT4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT5R {
            bits: bool,
        }
        impl EXTINT5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT6R {
            bits: bool,
        }
        impl EXTINT6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT7R {
            bits: bool,
        }
        impl EXTINT7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT8R {
            bits: bool,
        }
        impl EXTINT8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT9R {
            bits: bool,
        }
        impl EXTINT9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT10R {
            bits: bool,
        }
        impl EXTINT10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT11R {
            bits: bool,
        }
        impl EXTINT11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT12R {
            bits: bool,
        }
        impl EXTINT12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT13R {
            bits: bool,
        }
        impl EXTINT13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT14R {
            bits: bool,
        }
        impl EXTINT14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT15R {
            bits: bool,
        }
        impl EXTINT15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Interrupt 0 Enable"]
            #[inline(always)]
            pub fn extint0(&self) -> EXTINT0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT0R { bits }
            }
            #[doc = "Bit 1 - External Interrupt 1 Enable"]
            #[inline(always)]
            pub fn extint1(&self) -> EXTINT1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT1R { bits }
            }
            #[doc = "Bit 2 - External Interrupt 2 Enable"]
            #[inline(always)]
            pub fn extint2(&self) -> EXTINT2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT2R { bits }
            }
            #[doc = "Bit 3 - External Interrupt 3 Enable"]
            #[inline(always)]
            pub fn extint3(&self) -> EXTINT3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT3R { bits }
            }
            #[doc = "Bit 4 - External Interrupt 4 Enable"]
            #[inline(always)]
            pub fn extint4(&self) -> EXTINT4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT4R { bits }
            }
            #[doc = "Bit 5 - External Interrupt 5 Enable"]
            #[inline(always)]
            pub fn extint5(&self) -> EXTINT5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT5R { bits }
            }
            #[doc = "Bit 6 - External Interrupt 6 Enable"]
            #[inline(always)]
            pub fn extint6(&self) -> EXTINT6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT6R { bits }
            }
            #[doc = "Bit 7 - External Interrupt 7 Enable"]
            #[inline(always)]
            pub fn extint7(&self) -> EXTINT7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT7R { bits }
            }
            #[doc = "Bit 8 - External Interrupt 8 Enable"]
            #[inline(always)]
            pub fn extint8(&self) -> EXTINT8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT8R { bits }
            }
            #[doc = "Bit 9 - External Interrupt 9 Enable"]
            #[inline(always)]
            pub fn extint9(&self) -> EXTINT9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT9R { bits }
            }
            #[doc = "Bit 10 - External Interrupt 10 Enable"]
            #[inline(always)]
            pub fn extint10(&self) -> EXTINT10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT10R { bits }
            }
            #[doc = "Bit 11 - External Interrupt 11 Enable"]
            #[inline(always)]
            pub fn extint11(&self) -> EXTINT11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT11R { bits }
            }
            #[doc = "Bit 12 - External Interrupt 12 Enable"]
            #[inline(always)]
            pub fn extint12(&self) -> EXTINT12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT12R { bits }
            }
            #[doc = "Bit 13 - External Interrupt 13 Enable"]
            #[inline(always)]
            pub fn extint13(&self) -> EXTINT13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT13R { bits }
            }
            #[doc = "Bit 14 - External Interrupt 14 Enable"]
            #[inline(always)]
            pub fn extint14(&self) -> EXTINT14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT14R { bits }
            }
            #[doc = "Bit 15 - External Interrupt 15 Enable"]
            #[inline(always)]
            pub fn extint15(&self) -> EXTINT15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT15R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Interrupt 0 Enable"]
            #[inline(always)]
            pub fn extint0(&mut self) -> _EXTINT0W {
                _EXTINT0W { w: self }
            }
            #[doc = "Bit 1 - External Interrupt 1 Enable"]
            #[inline(always)]
            pub fn extint1(&mut self) -> _EXTINT1W {
                _EXTINT1W { w: self }
            }
            #[doc = "Bit 2 - External Interrupt 2 Enable"]
            #[inline(always)]
            pub fn extint2(&mut self) -> _EXTINT2W {
                _EXTINT2W { w: self }
            }
            #[doc = "Bit 3 - External Interrupt 3 Enable"]
            #[inline(always)]
            pub fn extint3(&mut self) -> _EXTINT3W {
                _EXTINT3W { w: self }
            }
            #[doc = "Bit 4 - External Interrupt 4 Enable"]
            #[inline(always)]
            pub fn extint4(&mut self) -> _EXTINT4W {
                _EXTINT4W { w: self }
            }
            #[doc = "Bit 5 - External Interrupt 5 Enable"]
            #[inline(always)]
            pub fn extint5(&mut self) -> _EXTINT5W {
                _EXTINT5W { w: self }
            }
            #[doc = "Bit 6 - External Interrupt 6 Enable"]
            #[inline(always)]
            pub fn extint6(&mut self) -> _EXTINT6W {
                _EXTINT6W { w: self }
            }
            #[doc = "Bit 7 - External Interrupt 7 Enable"]
            #[inline(always)]
            pub fn extint7(&mut self) -> _EXTINT7W {
                _EXTINT7W { w: self }
            }
            #[doc = "Bit 8 - External Interrupt 8 Enable"]
            #[inline(always)]
            pub fn extint8(&mut self) -> _EXTINT8W {
                _EXTINT8W { w: self }
            }
            #[doc = "Bit 9 - External Interrupt 9 Enable"]
            #[inline(always)]
            pub fn extint9(&mut self) -> _EXTINT9W {
                _EXTINT9W { w: self }
            }
            #[doc = "Bit 10 - External Interrupt 10 Enable"]
            #[inline(always)]
            pub fn extint10(&mut self) -> _EXTINT10W {
                _EXTINT10W { w: self }
            }
            #[doc = "Bit 11 - External Interrupt 11 Enable"]
            #[inline(always)]
            pub fn extint11(&mut self) -> _EXTINT11W {
                _EXTINT11W { w: self }
            }
            #[doc = "Bit 12 - External Interrupt 12 Enable"]
            #[inline(always)]
            pub fn extint12(&mut self) -> _EXTINT12W {
                _EXTINT12W { w: self }
            }
            #[doc = "Bit 13 - External Interrupt 13 Enable"]
            #[inline(always)]
            pub fn extint13(&mut self) -> _EXTINT13W {
                _EXTINT13W { w: self }
            }
            #[doc = "Bit 14 - External Interrupt 14 Enable"]
            #[inline(always)]
            pub fn extint14(&mut self) -> _EXTINT14W {
                _EXTINT14W { w: self }
            }
            #[doc = "Bit 15 - External Interrupt 15 Enable"]
            #[inline(always)]
            pub fn extint15(&mut self) -> _EXTINT15W {
                _EXTINT15W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT0R {
            bits: bool,
        }
        impl EXTINT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT1R {
            bits: bool,
        }
        impl EXTINT1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT2R {
            bits: bool,
        }
        impl EXTINT2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT3R {
            bits: bool,
        }
        impl EXTINT3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT4R {
            bits: bool,
        }
        impl EXTINT4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT5R {
            bits: bool,
        }
        impl EXTINT5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT6R {
            bits: bool,
        }
        impl EXTINT6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT7R {
            bits: bool,
        }
        impl EXTINT7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT8R {
            bits: bool,
        }
        impl EXTINT8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT9R {
            bits: bool,
        }
        impl EXTINT9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT10R {
            bits: bool,
        }
        impl EXTINT10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT11R {
            bits: bool,
        }
        impl EXTINT11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT12R {
            bits: bool,
        }
        impl EXTINT12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT13R {
            bits: bool,
        }
        impl EXTINT13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT14R {
            bits: bool,
        }
        impl EXTINT14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT15R {
            bits: bool,
        }
        impl EXTINT15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Interrupt 0 Enable"]
            #[inline(always)]
            pub fn extint0(&self) -> EXTINT0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT0R { bits }
            }
            #[doc = "Bit 1 - External Interrupt 1 Enable"]
            #[inline(always)]
            pub fn extint1(&self) -> EXTINT1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT1R { bits }
            }
            #[doc = "Bit 2 - External Interrupt 2 Enable"]
            #[inline(always)]
            pub fn extint2(&self) -> EXTINT2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT2R { bits }
            }
            #[doc = "Bit 3 - External Interrupt 3 Enable"]
            #[inline(always)]
            pub fn extint3(&self) -> EXTINT3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT3R { bits }
            }
            #[doc = "Bit 4 - External Interrupt 4 Enable"]
            #[inline(always)]
            pub fn extint4(&self) -> EXTINT4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT4R { bits }
            }
            #[doc = "Bit 5 - External Interrupt 5 Enable"]
            #[inline(always)]
            pub fn extint5(&self) -> EXTINT5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT5R { bits }
            }
            #[doc = "Bit 6 - External Interrupt 6 Enable"]
            #[inline(always)]
            pub fn extint6(&self) -> EXTINT6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT6R { bits }
            }
            #[doc = "Bit 7 - External Interrupt 7 Enable"]
            #[inline(always)]
            pub fn extint7(&self) -> EXTINT7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT7R { bits }
            }
            #[doc = "Bit 8 - External Interrupt 8 Enable"]
            #[inline(always)]
            pub fn extint8(&self) -> EXTINT8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT8R { bits }
            }
            #[doc = "Bit 9 - External Interrupt 9 Enable"]
            #[inline(always)]
            pub fn extint9(&self) -> EXTINT9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT9R { bits }
            }
            #[doc = "Bit 10 - External Interrupt 10 Enable"]
            #[inline(always)]
            pub fn extint10(&self) -> EXTINT10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT10R { bits }
            }
            #[doc = "Bit 11 - External Interrupt 11 Enable"]
            #[inline(always)]
            pub fn extint11(&self) -> EXTINT11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT11R { bits }
            }
            #[doc = "Bit 12 - External Interrupt 12 Enable"]
            #[inline(always)]
            pub fn extint12(&self) -> EXTINT12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT12R { bits }
            }
            #[doc = "Bit 13 - External Interrupt 13 Enable"]
            #[inline(always)]
            pub fn extint13(&self) -> EXTINT13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT13R { bits }
            }
            #[doc = "Bit 14 - External Interrupt 14 Enable"]
            #[inline(always)]
            pub fn extint14(&self) -> EXTINT14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT14R { bits }
            }
            #[doc = "Bit 15 - External Interrupt 15 Enable"]
            #[inline(always)]
            pub fn extint15(&self) -> EXTINT15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT15R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Interrupt 0 Enable"]
            #[inline(always)]
            pub fn extint0(&mut self) -> _EXTINT0W {
                _EXTINT0W { w: self }
            }
            #[doc = "Bit 1 - External Interrupt 1 Enable"]
            #[inline(always)]
            pub fn extint1(&mut self) -> _EXTINT1W {
                _EXTINT1W { w: self }
            }
            #[doc = "Bit 2 - External Interrupt 2 Enable"]
            #[inline(always)]
            pub fn extint2(&mut self) -> _EXTINT2W {
                _EXTINT2W { w: self }
            }
            #[doc = "Bit 3 - External Interrupt 3 Enable"]
            #[inline(always)]
            pub fn extint3(&mut self) -> _EXTINT3W {
                _EXTINT3W { w: self }
            }
            #[doc = "Bit 4 - External Interrupt 4 Enable"]
            #[inline(always)]
            pub fn extint4(&mut self) -> _EXTINT4W {
                _EXTINT4W { w: self }
            }
            #[doc = "Bit 5 - External Interrupt 5 Enable"]
            #[inline(always)]
            pub fn extint5(&mut self) -> _EXTINT5W {
                _EXTINT5W { w: self }
            }
            #[doc = "Bit 6 - External Interrupt 6 Enable"]
            #[inline(always)]
            pub fn extint6(&mut self) -> _EXTINT6W {
                _EXTINT6W { w: self }
            }
            #[doc = "Bit 7 - External Interrupt 7 Enable"]
            #[inline(always)]
            pub fn extint7(&mut self) -> _EXTINT7W {
                _EXTINT7W { w: self }
            }
            #[doc = "Bit 8 - External Interrupt 8 Enable"]
            #[inline(always)]
            pub fn extint8(&mut self) -> _EXTINT8W {
                _EXTINT8W { w: self }
            }
            #[doc = "Bit 9 - External Interrupt 9 Enable"]
            #[inline(always)]
            pub fn extint9(&mut self) -> _EXTINT9W {
                _EXTINT9W { w: self }
            }
            #[doc = "Bit 10 - External Interrupt 10 Enable"]
            #[inline(always)]
            pub fn extint10(&mut self) -> _EXTINT10W {
                _EXTINT10W { w: self }
            }
            #[doc = "Bit 11 - External Interrupt 11 Enable"]
            #[inline(always)]
            pub fn extint11(&mut self) -> _EXTINT11W {
                _EXTINT11W { w: self }
            }
            #[doc = "Bit 12 - External Interrupt 12 Enable"]
            #[inline(always)]
            pub fn extint12(&mut self) -> _EXTINT12W {
                _EXTINT12W { w: self }
            }
            #[doc = "Bit 13 - External Interrupt 13 Enable"]
            #[inline(always)]
            pub fn extint13(&mut self) -> _EXTINT13W {
                _EXTINT13W { w: self }
            }
            #[doc = "Bit 14 - External Interrupt 14 Enable"]
            #[inline(always)]
            pub fn extint14(&mut self) -> _EXTINT14W {
                _EXTINT14W { w: self }
            }
            #[doc = "Bit 15 - External Interrupt 15 Enable"]
            #[inline(always)]
            pub fn extint15(&mut self) -> _EXTINT15W {
                _EXTINT15W { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT0R {
            bits: bool,
        }
        impl EXTINT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT1R {
            bits: bool,
        }
        impl EXTINT1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT2R {
            bits: bool,
        }
        impl EXTINT2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT3R {
            bits: bool,
        }
        impl EXTINT3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT4R {
            bits: bool,
        }
        impl EXTINT4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT5R {
            bits: bool,
        }
        impl EXTINT5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT6R {
            bits: bool,
        }
        impl EXTINT6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT7R {
            bits: bool,
        }
        impl EXTINT7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT8R {
            bits: bool,
        }
        impl EXTINT8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT9R {
            bits: bool,
        }
        impl EXTINT9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT10R {
            bits: bool,
        }
        impl EXTINT10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT11R {
            bits: bool,
        }
        impl EXTINT11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT12R {
            bits: bool,
        }
        impl EXTINT12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT13R {
            bits: bool,
        }
        impl EXTINT13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT14R {
            bits: bool,
        }
        impl EXTINT14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT15R {
            bits: bool,
        }
        impl EXTINT15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Interrupt 0"]
            #[inline(always)]
            pub fn extint0(&self) -> EXTINT0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT0R { bits }
            }
            #[doc = "Bit 1 - External Interrupt 1"]
            #[inline(always)]
            pub fn extint1(&self) -> EXTINT1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT1R { bits }
            }
            #[doc = "Bit 2 - External Interrupt 2"]
            #[inline(always)]
            pub fn extint2(&self) -> EXTINT2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT2R { bits }
            }
            #[doc = "Bit 3 - External Interrupt 3"]
            #[inline(always)]
            pub fn extint3(&self) -> EXTINT3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT3R { bits }
            }
            #[doc = "Bit 4 - External Interrupt 4"]
            #[inline(always)]
            pub fn extint4(&self) -> EXTINT4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT4R { bits }
            }
            #[doc = "Bit 5 - External Interrupt 5"]
            #[inline(always)]
            pub fn extint5(&self) -> EXTINT5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT5R { bits }
            }
            #[doc = "Bit 6 - External Interrupt 6"]
            #[inline(always)]
            pub fn extint6(&self) -> EXTINT6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT6R { bits }
            }
            #[doc = "Bit 7 - External Interrupt 7"]
            #[inline(always)]
            pub fn extint7(&self) -> EXTINT7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT7R { bits }
            }
            #[doc = "Bit 8 - External Interrupt 8"]
            #[inline(always)]
            pub fn extint8(&self) -> EXTINT8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT8R { bits }
            }
            #[doc = "Bit 9 - External Interrupt 9"]
            #[inline(always)]
            pub fn extint9(&self) -> EXTINT9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT9R { bits }
            }
            #[doc = "Bit 10 - External Interrupt 10"]
            #[inline(always)]
            pub fn extint10(&self) -> EXTINT10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT10R { bits }
            }
            #[doc = "Bit 11 - External Interrupt 11"]
            #[inline(always)]
            pub fn extint11(&self) -> EXTINT11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT11R { bits }
            }
            #[doc = "Bit 12 - External Interrupt 12"]
            #[inline(always)]
            pub fn extint12(&self) -> EXTINT12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT12R { bits }
            }
            #[doc = "Bit 13 - External Interrupt 13"]
            #[inline(always)]
            pub fn extint13(&self) -> EXTINT13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT13R { bits }
            }
            #[doc = "Bit 14 - External Interrupt 14"]
            #[inline(always)]
            pub fn extint14(&self) -> EXTINT14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT14R { bits }
            }
            #[doc = "Bit 15 - External Interrupt 15"]
            #[inline(always)]
            pub fn extint15(&self) -> EXTINT15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT15R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Interrupt 0"]
            #[inline(always)]
            pub fn extint0(&mut self) -> _EXTINT0W {
                _EXTINT0W { w: self }
            }
            #[doc = "Bit 1 - External Interrupt 1"]
            #[inline(always)]
            pub fn extint1(&mut self) -> _EXTINT1W {
                _EXTINT1W { w: self }
            }
            #[doc = "Bit 2 - External Interrupt 2"]
            #[inline(always)]
            pub fn extint2(&mut self) -> _EXTINT2W {
                _EXTINT2W { w: self }
            }
            #[doc = "Bit 3 - External Interrupt 3"]
            #[inline(always)]
            pub fn extint3(&mut self) -> _EXTINT3W {
                _EXTINT3W { w: self }
            }
            #[doc = "Bit 4 - External Interrupt 4"]
            #[inline(always)]
            pub fn extint4(&mut self) -> _EXTINT4W {
                _EXTINT4W { w: self }
            }
            #[doc = "Bit 5 - External Interrupt 5"]
            #[inline(always)]
            pub fn extint5(&mut self) -> _EXTINT5W {
                _EXTINT5W { w: self }
            }
            #[doc = "Bit 6 - External Interrupt 6"]
            #[inline(always)]
            pub fn extint6(&mut self) -> _EXTINT6W {
                _EXTINT6W { w: self }
            }
            #[doc = "Bit 7 - External Interrupt 7"]
            #[inline(always)]
            pub fn extint7(&mut self) -> _EXTINT7W {
                _EXTINT7W { w: self }
            }
            #[doc = "Bit 8 - External Interrupt 8"]
            #[inline(always)]
            pub fn extint8(&mut self) -> _EXTINT8W {
                _EXTINT8W { w: self }
            }
            #[doc = "Bit 9 - External Interrupt 9"]
            #[inline(always)]
            pub fn extint9(&mut self) -> _EXTINT9W {
                _EXTINT9W { w: self }
            }
            #[doc = "Bit 10 - External Interrupt 10"]
            #[inline(always)]
            pub fn extint10(&mut self) -> _EXTINT10W {
                _EXTINT10W { w: self }
            }
            #[doc = "Bit 11 - External Interrupt 11"]
            #[inline(always)]
            pub fn extint11(&mut self) -> _EXTINT11W {
                _EXTINT11W { w: self }
            }
            #[doc = "Bit 12 - External Interrupt 12"]
            #[inline(always)]
            pub fn extint12(&mut self) -> _EXTINT12W {
                _EXTINT12W { w: self }
            }
            #[doc = "Bit 13 - External Interrupt 13"]
            #[inline(always)]
            pub fn extint13(&mut self) -> _EXTINT13W {
                _EXTINT13W { w: self }
            }
            #[doc = "Bit 14 - External Interrupt 14"]
            #[inline(always)]
            pub fn extint14(&mut self) -> _EXTINT14W {
                _EXTINT14W { w: self }
            }
            #[doc = "Bit 15 - External Interrupt 15"]
            #[inline(always)]
            pub fn extint15(&mut self) -> _EXTINT15W {
                _EXTINT15W { w: self }
            }
        }
    }
    #[doc = "Non-Maskable Interrupt Control"]
    pub struct NMICTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Non-Maskable Interrupt Control"]
    pub mod nmictrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::NMICTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `NMISENSE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NMISENSER {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising-edge detection"]
            RISE,
            #[doc = "Falling-edge detection"]
            FALL,
            #[doc = "Both-edges detection"]
            BOTH,
            #[doc = "High-level detection"]
            HIGH,
            #[doc = "Low-level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl NMISENSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    NMISENSER::NONE => 0,
                    NMISENSER::RISE => 1,
                    NMISENSER::FALL => 2,
                    NMISENSER::BOTH => 3,
                    NMISENSER::HIGH => 4,
                    NMISENSER::LOW => 5,
                    NMISENSER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> NMISENSER {
                match value {
                    0 => NMISENSER::NONE,
                    1 => NMISENSER::RISE,
                    2 => NMISENSER::FALL,
                    3 => NMISENSER::BOTH,
                    4 => NMISENSER::HIGH,
                    5 => NMISENSER::LOW,
                    i => NMISENSER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == NMISENSER::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == NMISENSER::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == NMISENSER::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == NMISENSER::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == NMISENSER::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == NMISENSER::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct NMIFILTENR {
            bits: bool,
        }
        impl NMIFILTENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `NMISENSE`"]
        pub enum NMISENSEW {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising-edge detection"]
            RISE,
            #[doc = "Falling-edge detection"]
            FALL,
            #[doc = "Both-edges detection"]
            BOTH,
            #[doc = "High-level detection"]
            HIGH,
            #[doc = "Low-level detection"]
            LOW,
        }
        impl NMISENSEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    NMISENSEW::NONE => 0,
                    NMISENSEW::RISE => 1,
                    NMISENSEW::FALL => 2,
                    NMISENSEW::BOTH => 3,
                    NMISENSEW::HIGH => 4,
                    NMISENSEW::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _NMISENSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NMISENSEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: NMISENSEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(NMISENSEW::NONE)
            }
            #[doc = "Rising-edge detection"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(NMISENSEW::RISE)
            }
            #[doc = "Falling-edge detection"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(NMISENSEW::FALL)
            }
            #[doc = "Both-edges detection"]
            #[inline(always)]
            pub fn both(self) -> &'a mut W {
                self.variant(NMISENSEW::BOTH)
            }
            #[doc = "High-level detection"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(NMISENSEW::HIGH)
            }
            #[doc = "Low-level detection"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(NMISENSEW::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NMIFILTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NMIFILTENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:2 - Non-Maskable Interrupt Sense"]
            #[inline(always)]
            pub fn nmisense(&self) -> NMISENSER {
                NMISENSER::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bit 3 - Non-Maskable Interrupt Filter Enable"]
            #[inline(always)]
            pub fn nmifilten(&self) -> NMIFILTENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                NMIFILTENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Non-Maskable Interrupt Sense"]
            #[inline(always)]
            pub fn nmisense(&mut self) -> _NMISENSEW {
                _NMISENSEW { w: self }
            }
            #[doc = "Bit 3 - Non-Maskable Interrupt Filter Enable"]
            #[inline(always)]
            pub fn nmifilten(&mut self) -> _NMIFILTENW {
                _NMIFILTENW { w: self }
            }
        }
    }
    #[doc = "Non-Maskable Interrupt Flag Status and Clear"]
    pub struct NMIFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Non-Maskable Interrupt Flag Status and Clear"]
    pub mod nmiflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::NMIFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct NMIR {
            bits: bool,
        }
        impl NMIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _NMIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NMIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Non-Maskable Interrupt"]
            #[inline(always)]
            pub fn nmi(&self) -> NMIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                NMIR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Non-Maskable Interrupt"]
            #[inline(always)]
            pub fn nmi(&mut self) -> _NMIW {
                _NMIW { w: self }
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 7 - Synchronization Busy"]
            #[inline(always)]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCBUSYR { bits }
            }
        }
    }
    #[doc = "Wake-Up Enable"]
    pub struct WAKEUP {
        register: VolatileCell<u32>,
    }
    #[doc = "Wake-Up Enable"]
    pub mod wakeup {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WAKEUP {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN0R {
            bits: bool,
        }
        impl WAKEUPEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN1R {
            bits: bool,
        }
        impl WAKEUPEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN2R {
            bits: bool,
        }
        impl WAKEUPEN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN3R {
            bits: bool,
        }
        impl WAKEUPEN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN4R {
            bits: bool,
        }
        impl WAKEUPEN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN5R {
            bits: bool,
        }
        impl WAKEUPEN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN6R {
            bits: bool,
        }
        impl WAKEUPEN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN7R {
            bits: bool,
        }
        impl WAKEUPEN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN8R {
            bits: bool,
        }
        impl WAKEUPEN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN9R {
            bits: bool,
        }
        impl WAKEUPEN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN10R {
            bits: bool,
        }
        impl WAKEUPEN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN11R {
            bits: bool,
        }
        impl WAKEUPEN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN12R {
            bits: bool,
        }
        impl WAKEUPEN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN13R {
            bits: bool,
        }
        impl WAKEUPEN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN14R {
            bits: bool,
        }
        impl WAKEUPEN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN15R {
            bits: bool,
        }
        impl WAKEUPEN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Interrupt 0 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen0(&self) -> WAKEUPEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN0R { bits }
            }
            #[doc = "Bit 1 - External Interrupt 1 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen1(&self) -> WAKEUPEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN1R { bits }
            }
            #[doc = "Bit 2 - External Interrupt 2 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen2(&self) -> WAKEUPEN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN2R { bits }
            }
            #[doc = "Bit 3 - External Interrupt 3 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen3(&self) -> WAKEUPEN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN3R { bits }
            }
            #[doc = "Bit 4 - External Interrupt 4 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen4(&self) -> WAKEUPEN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN4R { bits }
            }
            #[doc = "Bit 5 - External Interrupt 5 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen5(&self) -> WAKEUPEN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN5R { bits }
            }
            #[doc = "Bit 6 - External Interrupt 6 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen6(&self) -> WAKEUPEN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN6R { bits }
            }
            #[doc = "Bit 7 - External Interrupt 7 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen7(&self) -> WAKEUPEN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN7R { bits }
            }
            #[doc = "Bit 8 - External Interrupt 8 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen8(&self) -> WAKEUPEN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN8R { bits }
            }
            #[doc = "Bit 9 - External Interrupt 9 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen9(&self) -> WAKEUPEN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN9R { bits }
            }
            #[doc = "Bit 10 - External Interrupt 10 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen10(&self) -> WAKEUPEN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN10R { bits }
            }
            #[doc = "Bit 11 - External Interrupt 11 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen11(&self) -> WAKEUPEN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN11R { bits }
            }
            #[doc = "Bit 12 - External Interrupt 12 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen12(&self) -> WAKEUPEN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN12R { bits }
            }
            #[doc = "Bit 13 - External Interrupt 13 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen13(&self) -> WAKEUPEN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN13R { bits }
            }
            #[doc = "Bit 14 - External Interrupt 14 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen14(&self) -> WAKEUPEN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN14R { bits }
            }
            #[doc = "Bit 15 - External Interrupt 15 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen15(&self) -> WAKEUPEN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN15R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Interrupt 0 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen0(&mut self) -> _WAKEUPEN0W {
                _WAKEUPEN0W { w: self }
            }
            #[doc = "Bit 1 - External Interrupt 1 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen1(&mut self) -> _WAKEUPEN1W {
                _WAKEUPEN1W { w: self }
            }
            #[doc = "Bit 2 - External Interrupt 2 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen2(&mut self) -> _WAKEUPEN2W {
                _WAKEUPEN2W { w: self }
            }
            #[doc = "Bit 3 - External Interrupt 3 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen3(&mut self) -> _WAKEUPEN3W {
                _WAKEUPEN3W { w: self }
            }
            #[doc = "Bit 4 - External Interrupt 4 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen4(&mut self) -> _WAKEUPEN4W {
                _WAKEUPEN4W { w: self }
            }
            #[doc = "Bit 5 - External Interrupt 5 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen5(&mut self) -> _WAKEUPEN5W {
                _WAKEUPEN5W { w: self }
            }
            #[doc = "Bit 6 - External Interrupt 6 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen6(&mut self) -> _WAKEUPEN6W {
                _WAKEUPEN6W { w: self }
            }
            #[doc = "Bit 7 - External Interrupt 7 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen7(&mut self) -> _WAKEUPEN7W {
                _WAKEUPEN7W { w: self }
            }
            #[doc = "Bit 8 - External Interrupt 8 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen8(&mut self) -> _WAKEUPEN8W {
                _WAKEUPEN8W { w: self }
            }
            #[doc = "Bit 9 - External Interrupt 9 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen9(&mut self) -> _WAKEUPEN9W {
                _WAKEUPEN9W { w: self }
            }
            #[doc = "Bit 10 - External Interrupt 10 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen10(&mut self) -> _WAKEUPEN10W {
                _WAKEUPEN10W { w: self }
            }
            #[doc = "Bit 11 - External Interrupt 11 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen11(&mut self) -> _WAKEUPEN11W {
                _WAKEUPEN11W { w: self }
            }
            #[doc = "Bit 12 - External Interrupt 12 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen12(&mut self) -> _WAKEUPEN12W {
                _WAKEUPEN12W { w: self }
            }
            #[doc = "Bit 13 - External Interrupt 13 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen13(&mut self) -> _WAKEUPEN13W {
                _WAKEUPEN13W { w: self }
            }
            #[doc = "Bit 14 - External Interrupt 14 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen14(&mut self) -> _WAKEUPEN14W {
                _WAKEUPEN14W { w: self }
            }
            #[doc = "Bit 15 - External Interrupt 15 Wake-up Enable"]
            #[inline(always)]
            pub fn wakeupen15(&mut self) -> _WAKEUPEN15W {
                _WAKEUPEN15W { w: self }
            }
        }
    }
}
#[doc = "External Interrupt Controller"]
pub struct EIC {
    register_block: eic::RegisterBlock,
}
impl Deref for EIC {
    type Target = eic::RegisterBlock;
    fn deref(&self) -> &eic::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Event System Interface"]
pub const EVSYS: Peripheral<EVSYS> = unsafe { Peripheral::new(1107297280) };
#[doc = "Event System Interface"]
pub mod evsys {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctrl: CTRL,
        _reserved0: [u8; 3usize],
        #[doc = "0x04 - Channel"]
        pub channel: CHANNEL,
        #[doc = "0x08 - User Multiplexer"]
        pub user: USER,
        _reserved1: [u8; 2usize],
        #[doc = "0x0c - Channel Status"]
        pub chstatus: CHSTATUS,
        #[doc = "0x10 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x14 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x18 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
    }
    #[doc = "Channel"]
    pub struct CHANNEL {
        register: VolatileCell<u32>,
    }
    #[doc = "Channel"]
    pub mod channel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CHANNEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHANNELR {
            bits: u8,
        }
        impl CHANNELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWEVTR {
            bits: bool,
        }
        impl SWEVTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVGENR {
            bits: u8,
        }
        impl EVGENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `PATH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PATHR {
            #[doc = "Synchronous path"]
            SYNCHRONOUS,
            #[doc = "Resynchronized path"]
            RESYNCHRONIZED,
            #[doc = "Asynchronous path"]
            ASYNCHRONOUS,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PATHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    PATHR::SYNCHRONOUS => 0,
                    PATHR::RESYNCHRONIZED => 1,
                    PATHR::ASYNCHRONOUS => 2,
                    PATHR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> PATHR {
                match value {
                    0 => PATHR::SYNCHRONOUS,
                    1 => PATHR::RESYNCHRONIZED,
                    2 => PATHR::ASYNCHRONOUS,
                    i => PATHR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `SYNCHRONOUS`"]
            #[inline(always)]
            pub fn is_synchronous(&self) -> bool {
                *self == PATHR::SYNCHRONOUS
            }
            #[doc = "Checks if the value of the field is `RESYNCHRONIZED`"]
            #[inline(always)]
            pub fn is_resynchronized(&self) -> bool {
                *self == PATHR::RESYNCHRONIZED
            }
            #[doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
            #[inline(always)]
            pub fn is_asynchronous(&self) -> bool {
                *self == PATHR::ASYNCHRONOUS
            }
        }
        #[doc = "Possible values of the field `EDGSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EDGSELR {
            #[doc = "No event output when using the resynchronized or synchronous path"]
            NO_EVT_OUTPUT,
            #[doc = "Event detection only on the rising edge of the signal from the event generator when using the resynchronized or synchronous path"]
            RISING_EDGE,
            #[doc = "Event detection only on the falling edge of the signal from the event generator when using the resynchronized or synchronous path"]
            FALLING_EDGE,
            #[doc = "Event detection on rising and falling edges of the signal from the event generator when using the resynchronized or synchronous path"]
            BOTH_EDGES,
        }
        impl EDGSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    EDGSELR::NO_EVT_OUTPUT => 0,
                    EDGSELR::RISING_EDGE => 1,
                    EDGSELR::FALLING_EDGE => 2,
                    EDGSELR::BOTH_EDGES => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> EDGSELR {
                match value {
                    0 => EDGSELR::NO_EVT_OUTPUT,
                    1 => EDGSELR::RISING_EDGE,
                    2 => EDGSELR::FALLING_EDGE,
                    3 => EDGSELR::BOTH_EDGES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_EVT_OUTPUT`"]
            #[inline(always)]
            pub fn is_no_evt_output(&self) -> bool {
                *self == EDGSELR::NO_EVT_OUTPUT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE`"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == EDGSELR::RISING_EDGE
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE`"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == EDGSELR::FALLING_EDGE
            }
            #[doc = "Checks if the value of the field is `BOTH_EDGES`"]
            #[inline(always)]
            pub fn is_both_edges(&self) -> bool {
                *self == EDGSELR::BOTH_EDGES
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHANNELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHANNELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWEVTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWEVTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVGENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVGENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PATH`"]
        pub enum PATHW {
            #[doc = "Synchronous path"]
            SYNCHRONOUS,
            #[doc = "Resynchronized path"]
            RESYNCHRONIZED,
            #[doc = "Asynchronous path"]
            ASYNCHRONOUS,
        }
        impl PATHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PATHW::SYNCHRONOUS => 0,
                    PATHW::RESYNCHRONIZED => 1,
                    PATHW::ASYNCHRONOUS => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PATHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PATHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PATHW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Synchronous path"]
            #[inline(always)]
            pub fn synchronous(self) -> &'a mut W {
                self.variant(PATHW::SYNCHRONOUS)
            }
            #[doc = "Resynchronized path"]
            #[inline(always)]
            pub fn resynchronized(self) -> &'a mut W {
                self.variant(PATHW::RESYNCHRONIZED)
            }
            #[doc = "Asynchronous path"]
            #[inline(always)]
            pub fn asynchronous(self) -> &'a mut W {
                self.variant(PATHW::ASYNCHRONOUS)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EDGSEL`"]
        pub enum EDGSELW {
            #[doc = "No event output when using the resynchronized or synchronous path"]
            NO_EVT_OUTPUT,
            #[doc = "Event detection only on the rising edge of the signal from the event generator when using the resynchronized or synchronous path"]
            RISING_EDGE,
            #[doc = "Event detection only on the falling edge of the signal from the event generator when using the resynchronized or synchronous path"]
            FALLING_EDGE,
            #[doc = "Event detection on rising and falling edges of the signal from the event generator when using the resynchronized or synchronous path"]
            BOTH_EDGES,
        }
        impl EDGSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EDGSELW::NO_EVT_OUTPUT => 0,
                    EDGSELW::RISING_EDGE => 1,
                    EDGSELW::FALLING_EDGE => 2,
                    EDGSELW::BOTH_EDGES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EDGSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EDGSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EDGSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No event output when using the resynchronized or synchronous path"]
            #[inline(always)]
            pub fn no_evt_output(self) -> &'a mut W {
                self.variant(EDGSELW::NO_EVT_OUTPUT)
            }
            #[doc = "Event detection only on the rising edge of the signal from the event generator when using the resynchronized or synchronous path"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(EDGSELW::RISING_EDGE)
            }
            #[doc = "Event detection only on the falling edge of the signal from the event generator when using the resynchronized or synchronous path"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(EDGSELW::FALLING_EDGE)
            }
            #[doc = "Event detection on rising and falling edges of the signal from the event generator when using the resynchronized or synchronous path"]
            #[inline(always)]
            pub fn both_edges(self) -> &'a mut W {
                self.variant(EDGSELW::BOTH_EDGES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Channel Selection"]
            #[inline(always)]
            pub fn channel(&self) -> CHANNELR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CHANNELR { bits }
            }
            #[doc = "Bit 8 - Software Event"]
            #[inline(always)]
            pub fn swevt(&self) -> SWEVTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWEVTR { bits }
            }
            #[doc = "Bits 16:22 - Event Generator Selection"]
            #[inline(always)]
            pub fn evgen(&self) -> EVGENR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EVGENR { bits }
            }
            #[doc = "Bits 24:25 - Path Selection"]
            #[inline(always)]
            pub fn path(&self) -> PATHR {
                PATHR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 26:27 - Edge Detection Selection"]
            #[inline(always)]
            pub fn edgsel(&self) -> EDGSELR {
                EDGSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Channel Selection"]
            #[inline(always)]
            pub fn channel(&mut self) -> _CHANNELW {
                _CHANNELW { w: self }
            }
            #[doc = "Bit 8 - Software Event"]
            #[inline(always)]
            pub fn swevt(&mut self) -> _SWEVTW {
                _SWEVTW { w: self }
            }
            #[doc = "Bits 16:22 - Event Generator Selection"]
            #[inline(always)]
            pub fn evgen(&mut self) -> _EVGENW {
                _EVGENW { w: self }
            }
            #[doc = "Bits 24:25 - Path Selection"]
            #[inline(always)]
            pub fn path(&mut self) -> _PATHW {
                _PATHW { w: self }
            }
            #[doc = "Bits 26:27 - Edge Detection Selection"]
            #[inline(always)]
            pub fn edgsel(&mut self) -> _EDGSELW {
                _EDGSELW { w: self }
            }
        }
    }
    #[doc = "Channel Status"]
    pub struct CHSTATUS {
        register: VolatileCell<u32>,
    }
    #[doc = "Channel Status"]
    pub mod chstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CHSTATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY0R {
            bits: bool,
        }
        impl USRRDY0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY1R {
            bits: bool,
        }
        impl USRRDY1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY2R {
            bits: bool,
        }
        impl USRRDY2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY3R {
            bits: bool,
        }
        impl USRRDY3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY4R {
            bits: bool,
        }
        impl USRRDY4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY5R {
            bits: bool,
        }
        impl USRRDY5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY6R {
            bits: bool,
        }
        impl USRRDY6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY7R {
            bits: bool,
        }
        impl USRRDY7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY0R {
            bits: bool,
        }
        impl CHBUSY0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY1R {
            bits: bool,
        }
        impl CHBUSY1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY2R {
            bits: bool,
        }
        impl CHBUSY2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY3R {
            bits: bool,
        }
        impl CHBUSY3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY4R {
            bits: bool,
        }
        impl CHBUSY4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY5R {
            bits: bool,
        }
        impl CHBUSY5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY6R {
            bits: bool,
        }
        impl CHBUSY6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY7R {
            bits: bool,
        }
        impl CHBUSY7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY8R {
            bits: bool,
        }
        impl USRRDY8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY9R {
            bits: bool,
        }
        impl USRRDY9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY10R {
            bits: bool,
        }
        impl USRRDY10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY11R {
            bits: bool,
        }
        impl USRRDY11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY8R {
            bits: bool,
        }
        impl CHBUSY8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY9R {
            bits: bool,
        }
        impl CHBUSY9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY10R {
            bits: bool,
        }
        impl CHBUSY10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY11R {
            bits: bool,
        }
        impl CHBUSY11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel 0 User Ready"]
            #[inline(always)]
            pub fn usrrdy0(&self) -> USRRDY0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY0R { bits }
            }
            #[doc = "Bit 1 - Channel 1 User Ready"]
            #[inline(always)]
            pub fn usrrdy1(&self) -> USRRDY1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY1R { bits }
            }
            #[doc = "Bit 2 - Channel 2 User Ready"]
            #[inline(always)]
            pub fn usrrdy2(&self) -> USRRDY2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY2R { bits }
            }
            #[doc = "Bit 3 - Channel 3 User Ready"]
            #[inline(always)]
            pub fn usrrdy3(&self) -> USRRDY3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY3R { bits }
            }
            #[doc = "Bit 4 - Channel 4 User Ready"]
            #[inline(always)]
            pub fn usrrdy4(&self) -> USRRDY4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY4R { bits }
            }
            #[doc = "Bit 5 - Channel 5 User Ready"]
            #[inline(always)]
            pub fn usrrdy5(&self) -> USRRDY5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY5R { bits }
            }
            #[doc = "Bit 6 - Channel 6 User Ready"]
            #[inline(always)]
            pub fn usrrdy6(&self) -> USRRDY6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY6R { bits }
            }
            #[doc = "Bit 7 - Channel 7 User Ready"]
            #[inline(always)]
            pub fn usrrdy7(&self) -> USRRDY7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY7R { bits }
            }
            #[doc = "Bit 8 - Channel 0 Busy"]
            #[inline(always)]
            pub fn chbusy0(&self) -> CHBUSY0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY0R { bits }
            }
            #[doc = "Bit 9 - Channel 1 Busy"]
            #[inline(always)]
            pub fn chbusy1(&self) -> CHBUSY1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY1R { bits }
            }
            #[doc = "Bit 10 - Channel 2 Busy"]
            #[inline(always)]
            pub fn chbusy2(&self) -> CHBUSY2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY2R { bits }
            }
            #[doc = "Bit 11 - Channel 3 Busy"]
            #[inline(always)]
            pub fn chbusy3(&self) -> CHBUSY3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY3R { bits }
            }
            #[doc = "Bit 12 - Channel 4 Busy"]
            #[inline(always)]
            pub fn chbusy4(&self) -> CHBUSY4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY4R { bits }
            }
            #[doc = "Bit 13 - Channel 5 Busy"]
            #[inline(always)]
            pub fn chbusy5(&self) -> CHBUSY5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY5R { bits }
            }
            #[doc = "Bit 14 - Channel 6 Busy"]
            #[inline(always)]
            pub fn chbusy6(&self) -> CHBUSY6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY6R { bits }
            }
            #[doc = "Bit 15 - Channel 7 Busy"]
            #[inline(always)]
            pub fn chbusy7(&self) -> CHBUSY7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY7R { bits }
            }
            #[doc = "Bit 16 - Channel 8 User Ready"]
            #[inline(always)]
            pub fn usrrdy8(&self) -> USRRDY8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY8R { bits }
            }
            #[doc = "Bit 17 - Channel 9 User Ready"]
            #[inline(always)]
            pub fn usrrdy9(&self) -> USRRDY9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY9R { bits }
            }
            #[doc = "Bit 18 - Channel 10 User Ready"]
            #[inline(always)]
            pub fn usrrdy10(&self) -> USRRDY10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY10R { bits }
            }
            #[doc = "Bit 19 - Channel 11 User Ready"]
            #[inline(always)]
            pub fn usrrdy11(&self) -> USRRDY11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY11R { bits }
            }
            #[doc = "Bit 24 - Channel 8 Busy"]
            #[inline(always)]
            pub fn chbusy8(&self) -> CHBUSY8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY8R { bits }
            }
            #[doc = "Bit 25 - Channel 9 Busy"]
            #[inline(always)]
            pub fn chbusy9(&self) -> CHBUSY9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY9R { bits }
            }
            #[doc = "Bit 26 - Channel 10 Busy"]
            #[inline(always)]
            pub fn chbusy10(&self) -> CHBUSY10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY10R { bits }
            }
            #[doc = "Bit 27 - Channel 11 Busy"]
            #[inline(always)]
            pub fn chbusy11(&self) -> CHBUSY11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY11R { bits }
            }
        }
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRL {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GCLKREQW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GCLKREQW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 4 - Generic Clock Requests"]
            #[inline(always)]
            pub fn gclkreq(&mut self) -> _GCLKREQW {
                _GCLKREQW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR0R {
            bits: bool,
        }
        impl OVR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR1R {
            bits: bool,
        }
        impl OVR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR2R {
            bits: bool,
        }
        impl OVR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR3R {
            bits: bool,
        }
        impl OVR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR4R {
            bits: bool,
        }
        impl OVR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR5R {
            bits: bool,
        }
        impl OVR5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR6R {
            bits: bool,
        }
        impl OVR6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR7R {
            bits: bool,
        }
        impl OVR7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD0R {
            bits: bool,
        }
        impl EVD0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD1R {
            bits: bool,
        }
        impl EVD1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD2R {
            bits: bool,
        }
        impl EVD2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD3R {
            bits: bool,
        }
        impl EVD3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD4R {
            bits: bool,
        }
        impl EVD4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD5R {
            bits: bool,
        }
        impl EVD5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD6R {
            bits: bool,
        }
        impl EVD6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD7R {
            bits: bool,
        }
        impl EVD7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR8R {
            bits: bool,
        }
        impl OVR8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR9R {
            bits: bool,
        }
        impl OVR9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR10R {
            bits: bool,
        }
        impl OVR10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR11R {
            bits: bool,
        }
        impl OVR11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD8R {
            bits: bool,
        }
        impl EVD8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD9R {
            bits: bool,
        }
        impl EVD9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD10R {
            bits: bool,
        }
        impl EVD10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD11R {
            bits: bool,
        }
        impl EVD11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel 0 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr0(&self) -> OVR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR0R { bits }
            }
            #[doc = "Bit 1 - Channel 1 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr1(&self) -> OVR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR1R { bits }
            }
            #[doc = "Bit 2 - Channel 2 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr2(&self) -> OVR2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR2R { bits }
            }
            #[doc = "Bit 3 - Channel 3 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr3(&self) -> OVR3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR3R { bits }
            }
            #[doc = "Bit 4 - Channel 4 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr4(&self) -> OVR4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR4R { bits }
            }
            #[doc = "Bit 5 - Channel 5 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr5(&self) -> OVR5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR5R { bits }
            }
            #[doc = "Bit 6 - Channel 6 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr6(&self) -> OVR6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR6R { bits }
            }
            #[doc = "Bit 7 - Channel 7 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr7(&self) -> OVR7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR7R { bits }
            }
            #[doc = "Bit 8 - Channel 0 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd0(&self) -> EVD0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD0R { bits }
            }
            #[doc = "Bit 9 - Channel 1 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd1(&self) -> EVD1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD1R { bits }
            }
            #[doc = "Bit 10 - Channel 2 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd2(&self) -> EVD2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD2R { bits }
            }
            #[doc = "Bit 11 - Channel 3 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd3(&self) -> EVD3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD3R { bits }
            }
            #[doc = "Bit 12 - Channel 4 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd4(&self) -> EVD4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD4R { bits }
            }
            #[doc = "Bit 13 - Channel 5 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd5(&self) -> EVD5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD5R { bits }
            }
            #[doc = "Bit 14 - Channel 6 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd6(&self) -> EVD6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD6R { bits }
            }
            #[doc = "Bit 15 - Channel 7 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd7(&self) -> EVD7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD7R { bits }
            }
            #[doc = "Bit 16 - Channel 8 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr8(&self) -> OVR8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR8R { bits }
            }
            #[doc = "Bit 17 - Channel 9 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr9(&self) -> OVR9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR9R { bits }
            }
            #[doc = "Bit 18 - Channel 10 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr10(&self) -> OVR10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR10R { bits }
            }
            #[doc = "Bit 19 - Channel 11 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr11(&self) -> OVR11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR11R { bits }
            }
            #[doc = "Bit 24 - Channel 8 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd8(&self) -> EVD8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD8R { bits }
            }
            #[doc = "Bit 25 - Channel 9 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd9(&self) -> EVD9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD9R { bits }
            }
            #[doc = "Bit 26 - Channel 10 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd10(&self) -> EVD10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD10R { bits }
            }
            #[doc = "Bit 27 - Channel 11 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd11(&self) -> EVD11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD11R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel 0 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr0(&mut self) -> _OVR0W {
                _OVR0W { w: self }
            }
            #[doc = "Bit 1 - Channel 1 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr1(&mut self) -> _OVR1W {
                _OVR1W { w: self }
            }
            #[doc = "Bit 2 - Channel 2 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr2(&mut self) -> _OVR2W {
                _OVR2W { w: self }
            }
            #[doc = "Bit 3 - Channel 3 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr3(&mut self) -> _OVR3W {
                _OVR3W { w: self }
            }
            #[doc = "Bit 4 - Channel 4 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr4(&mut self) -> _OVR4W {
                _OVR4W { w: self }
            }
            #[doc = "Bit 5 - Channel 5 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr5(&mut self) -> _OVR5W {
                _OVR5W { w: self }
            }
            #[doc = "Bit 6 - Channel 6 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr6(&mut self) -> _OVR6W {
                _OVR6W { w: self }
            }
            #[doc = "Bit 7 - Channel 7 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr7(&mut self) -> _OVR7W {
                _OVR7W { w: self }
            }
            #[doc = "Bit 8 - Channel 0 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd0(&mut self) -> _EVD0W {
                _EVD0W { w: self }
            }
            #[doc = "Bit 9 - Channel 1 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd1(&mut self) -> _EVD1W {
                _EVD1W { w: self }
            }
            #[doc = "Bit 10 - Channel 2 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd2(&mut self) -> _EVD2W {
                _EVD2W { w: self }
            }
            #[doc = "Bit 11 - Channel 3 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd3(&mut self) -> _EVD3W {
                _EVD3W { w: self }
            }
            #[doc = "Bit 12 - Channel 4 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd4(&mut self) -> _EVD4W {
                _EVD4W { w: self }
            }
            #[doc = "Bit 13 - Channel 5 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd5(&mut self) -> _EVD5W {
                _EVD5W { w: self }
            }
            #[doc = "Bit 14 - Channel 6 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd6(&mut self) -> _EVD6W {
                _EVD6W { w: self }
            }
            #[doc = "Bit 15 - Channel 7 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd7(&mut self) -> _EVD7W {
                _EVD7W { w: self }
            }
            #[doc = "Bit 16 - Channel 8 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr8(&mut self) -> _OVR8W {
                _OVR8W { w: self }
            }
            #[doc = "Bit 17 - Channel 9 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr9(&mut self) -> _OVR9W {
                _OVR9W { w: self }
            }
            #[doc = "Bit 18 - Channel 10 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr10(&mut self) -> _OVR10W {
                _OVR10W { w: self }
            }
            #[doc = "Bit 19 - Channel 11 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr11(&mut self) -> _OVR11W {
                _OVR11W { w: self }
            }
            #[doc = "Bit 24 - Channel 8 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd8(&mut self) -> _EVD8W {
                _EVD8W { w: self }
            }
            #[doc = "Bit 25 - Channel 9 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd9(&mut self) -> _EVD9W {
                _EVD9W { w: self }
            }
            #[doc = "Bit 26 - Channel 10 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd10(&mut self) -> _EVD10W {
                _EVD10W { w: self }
            }
            #[doc = "Bit 27 - Channel 11 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd11(&mut self) -> _EVD11W {
                _EVD11W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR0R {
            bits: bool,
        }
        impl OVR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR1R {
            bits: bool,
        }
        impl OVR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR2R {
            bits: bool,
        }
        impl OVR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR3R {
            bits: bool,
        }
        impl OVR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR4R {
            bits: bool,
        }
        impl OVR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR5R {
            bits: bool,
        }
        impl OVR5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR6R {
            bits: bool,
        }
        impl OVR6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR7R {
            bits: bool,
        }
        impl OVR7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD0R {
            bits: bool,
        }
        impl EVD0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD1R {
            bits: bool,
        }
        impl EVD1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD2R {
            bits: bool,
        }
        impl EVD2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD3R {
            bits: bool,
        }
        impl EVD3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD4R {
            bits: bool,
        }
        impl EVD4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD5R {
            bits: bool,
        }
        impl EVD5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD6R {
            bits: bool,
        }
        impl EVD6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD7R {
            bits: bool,
        }
        impl EVD7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR8R {
            bits: bool,
        }
        impl OVR8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR9R {
            bits: bool,
        }
        impl OVR9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR10R {
            bits: bool,
        }
        impl OVR10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR11R {
            bits: bool,
        }
        impl OVR11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD8R {
            bits: bool,
        }
        impl EVD8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD9R {
            bits: bool,
        }
        impl EVD9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD10R {
            bits: bool,
        }
        impl EVD10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD11R {
            bits: bool,
        }
        impl EVD11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel 0 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr0(&self) -> OVR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR0R { bits }
            }
            #[doc = "Bit 1 - Channel 1 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr1(&self) -> OVR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR1R { bits }
            }
            #[doc = "Bit 2 - Channel 2 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr2(&self) -> OVR2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR2R { bits }
            }
            #[doc = "Bit 3 - Channel 3 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr3(&self) -> OVR3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR3R { bits }
            }
            #[doc = "Bit 4 - Channel 4 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr4(&self) -> OVR4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR4R { bits }
            }
            #[doc = "Bit 5 - Channel 5 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr5(&self) -> OVR5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR5R { bits }
            }
            #[doc = "Bit 6 - Channel 6 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr6(&self) -> OVR6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR6R { bits }
            }
            #[doc = "Bit 7 - Channel 7 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr7(&self) -> OVR7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR7R { bits }
            }
            #[doc = "Bit 8 - Channel 0 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd0(&self) -> EVD0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD0R { bits }
            }
            #[doc = "Bit 9 - Channel 1 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd1(&self) -> EVD1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD1R { bits }
            }
            #[doc = "Bit 10 - Channel 2 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd2(&self) -> EVD2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD2R { bits }
            }
            #[doc = "Bit 11 - Channel 3 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd3(&self) -> EVD3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD3R { bits }
            }
            #[doc = "Bit 12 - Channel 4 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd4(&self) -> EVD4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD4R { bits }
            }
            #[doc = "Bit 13 - Channel 5 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd5(&self) -> EVD5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD5R { bits }
            }
            #[doc = "Bit 14 - Channel 6 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd6(&self) -> EVD6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD6R { bits }
            }
            #[doc = "Bit 15 - Channel 7 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd7(&self) -> EVD7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD7R { bits }
            }
            #[doc = "Bit 16 - Channel 8 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr8(&self) -> OVR8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR8R { bits }
            }
            #[doc = "Bit 17 - Channel 9 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr9(&self) -> OVR9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR9R { bits }
            }
            #[doc = "Bit 18 - Channel 10 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr10(&self) -> OVR10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR10R { bits }
            }
            #[doc = "Bit 19 - Channel 11 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr11(&self) -> OVR11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR11R { bits }
            }
            #[doc = "Bit 24 - Channel 8 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd8(&self) -> EVD8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD8R { bits }
            }
            #[doc = "Bit 25 - Channel 9 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd9(&self) -> EVD9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD9R { bits }
            }
            #[doc = "Bit 26 - Channel 10 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd10(&self) -> EVD10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD10R { bits }
            }
            #[doc = "Bit 27 - Channel 11 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd11(&self) -> EVD11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD11R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel 0 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr0(&mut self) -> _OVR0W {
                _OVR0W { w: self }
            }
            #[doc = "Bit 1 - Channel 1 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr1(&mut self) -> _OVR1W {
                _OVR1W { w: self }
            }
            #[doc = "Bit 2 - Channel 2 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr2(&mut self) -> _OVR2W {
                _OVR2W { w: self }
            }
            #[doc = "Bit 3 - Channel 3 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr3(&mut self) -> _OVR3W {
                _OVR3W { w: self }
            }
            #[doc = "Bit 4 - Channel 4 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr4(&mut self) -> _OVR4W {
                _OVR4W { w: self }
            }
            #[doc = "Bit 5 - Channel 5 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr5(&mut self) -> _OVR5W {
                _OVR5W { w: self }
            }
            #[doc = "Bit 6 - Channel 6 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr6(&mut self) -> _OVR6W {
                _OVR6W { w: self }
            }
            #[doc = "Bit 7 - Channel 7 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr7(&mut self) -> _OVR7W {
                _OVR7W { w: self }
            }
            #[doc = "Bit 8 - Channel 0 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd0(&mut self) -> _EVD0W {
                _EVD0W { w: self }
            }
            #[doc = "Bit 9 - Channel 1 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd1(&mut self) -> _EVD1W {
                _EVD1W { w: self }
            }
            #[doc = "Bit 10 - Channel 2 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd2(&mut self) -> _EVD2W {
                _EVD2W { w: self }
            }
            #[doc = "Bit 11 - Channel 3 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd3(&mut self) -> _EVD3W {
                _EVD3W { w: self }
            }
            #[doc = "Bit 12 - Channel 4 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd4(&mut self) -> _EVD4W {
                _EVD4W { w: self }
            }
            #[doc = "Bit 13 - Channel 5 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd5(&mut self) -> _EVD5W {
                _EVD5W { w: self }
            }
            #[doc = "Bit 14 - Channel 6 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd6(&mut self) -> _EVD6W {
                _EVD6W { w: self }
            }
            #[doc = "Bit 15 - Channel 7 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd7(&mut self) -> _EVD7W {
                _EVD7W { w: self }
            }
            #[doc = "Bit 16 - Channel 8 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr8(&mut self) -> _OVR8W {
                _OVR8W { w: self }
            }
            #[doc = "Bit 17 - Channel 9 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr9(&mut self) -> _OVR9W {
                _OVR9W { w: self }
            }
            #[doc = "Bit 18 - Channel 10 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr10(&mut self) -> _OVR10W {
                _OVR10W { w: self }
            }
            #[doc = "Bit 19 - Channel 11 Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn ovr11(&mut self) -> _OVR11W {
                _OVR11W { w: self }
            }
            #[doc = "Bit 24 - Channel 8 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd8(&mut self) -> _EVD8W {
                _EVD8W { w: self }
            }
            #[doc = "Bit 25 - Channel 9 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd9(&mut self) -> _EVD9W {
                _EVD9W { w: self }
            }
            #[doc = "Bit 26 - Channel 10 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd10(&mut self) -> _EVD10W {
                _EVD10W { w: self }
            }
            #[doc = "Bit 27 - Channel 11 Event Detection Interrupt Enable"]
            #[inline(always)]
            pub fn evd11(&mut self) -> _EVD11W {
                _EVD11W { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR0R {
            bits: bool,
        }
        impl OVR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR1R {
            bits: bool,
        }
        impl OVR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR2R {
            bits: bool,
        }
        impl OVR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR3R {
            bits: bool,
        }
        impl OVR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR4R {
            bits: bool,
        }
        impl OVR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR5R {
            bits: bool,
        }
        impl OVR5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR6R {
            bits: bool,
        }
        impl OVR6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR7R {
            bits: bool,
        }
        impl OVR7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD0R {
            bits: bool,
        }
        impl EVD0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD1R {
            bits: bool,
        }
        impl EVD1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD2R {
            bits: bool,
        }
        impl EVD2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD3R {
            bits: bool,
        }
        impl EVD3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD4R {
            bits: bool,
        }
        impl EVD4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD5R {
            bits: bool,
        }
        impl EVD5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD6R {
            bits: bool,
        }
        impl EVD6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD7R {
            bits: bool,
        }
        impl EVD7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR8R {
            bits: bool,
        }
        impl OVR8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR9R {
            bits: bool,
        }
        impl OVR9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR10R {
            bits: bool,
        }
        impl OVR10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR11R {
            bits: bool,
        }
        impl OVR11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD8R {
            bits: bool,
        }
        impl EVD8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD9R {
            bits: bool,
        }
        impl EVD9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD10R {
            bits: bool,
        }
        impl EVD10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD11R {
            bits: bool,
        }
        impl EVD11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel 0 Overrun"]
            #[inline(always)]
            pub fn ovr0(&self) -> OVR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR0R { bits }
            }
            #[doc = "Bit 1 - Channel 1 Overrun"]
            #[inline(always)]
            pub fn ovr1(&self) -> OVR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR1R { bits }
            }
            #[doc = "Bit 2 - Channel 2 Overrun"]
            #[inline(always)]
            pub fn ovr2(&self) -> OVR2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR2R { bits }
            }
            #[doc = "Bit 3 - Channel 3 Overrun"]
            #[inline(always)]
            pub fn ovr3(&self) -> OVR3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR3R { bits }
            }
            #[doc = "Bit 4 - Channel 4 Overrun"]
            #[inline(always)]
            pub fn ovr4(&self) -> OVR4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR4R { bits }
            }
            #[doc = "Bit 5 - Channel 5 Overrun"]
            #[inline(always)]
            pub fn ovr5(&self) -> OVR5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR5R { bits }
            }
            #[doc = "Bit 6 - Channel 6 Overrun"]
            #[inline(always)]
            pub fn ovr6(&self) -> OVR6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR6R { bits }
            }
            #[doc = "Bit 7 - Channel 7 Overrun"]
            #[inline(always)]
            pub fn ovr7(&self) -> OVR7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR7R { bits }
            }
            #[doc = "Bit 8 - Channel 0 Event Detection"]
            #[inline(always)]
            pub fn evd0(&self) -> EVD0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD0R { bits }
            }
            #[doc = "Bit 9 - Channel 1 Event Detection"]
            #[inline(always)]
            pub fn evd1(&self) -> EVD1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD1R { bits }
            }
            #[doc = "Bit 10 - Channel 2 Event Detection"]
            #[inline(always)]
            pub fn evd2(&self) -> EVD2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD2R { bits }
            }
            #[doc = "Bit 11 - Channel 3 Event Detection"]
            #[inline(always)]
            pub fn evd3(&self) -> EVD3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD3R { bits }
            }
            #[doc = "Bit 12 - Channel 4 Event Detection"]
            #[inline(always)]
            pub fn evd4(&self) -> EVD4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD4R { bits }
            }
            #[doc = "Bit 13 - Channel 5 Event Detection"]
            #[inline(always)]
            pub fn evd5(&self) -> EVD5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD5R { bits }
            }
            #[doc = "Bit 14 - Channel 6 Event Detection"]
            #[inline(always)]
            pub fn evd6(&self) -> EVD6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD6R { bits }
            }
            #[doc = "Bit 15 - Channel 7 Event Detection"]
            #[inline(always)]
            pub fn evd7(&self) -> EVD7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD7R { bits }
            }
            #[doc = "Bit 16 - Channel 8 Overrun"]
            #[inline(always)]
            pub fn ovr8(&self) -> OVR8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR8R { bits }
            }
            #[doc = "Bit 17 - Channel 9 Overrun"]
            #[inline(always)]
            pub fn ovr9(&self) -> OVR9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR9R { bits }
            }
            #[doc = "Bit 18 - Channel 10 Overrun"]
            #[inline(always)]
            pub fn ovr10(&self) -> OVR10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR10R { bits }
            }
            #[doc = "Bit 19 - Channel 11 Overrun"]
            #[inline(always)]
            pub fn ovr11(&self) -> OVR11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR11R { bits }
            }
            #[doc = "Bit 24 - Channel 8 Event Detection"]
            #[inline(always)]
            pub fn evd8(&self) -> EVD8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD8R { bits }
            }
            #[doc = "Bit 25 - Channel 9 Event Detection"]
            #[inline(always)]
            pub fn evd9(&self) -> EVD9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD9R { bits }
            }
            #[doc = "Bit 26 - Channel 10 Event Detection"]
            #[inline(always)]
            pub fn evd10(&self) -> EVD10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD10R { bits }
            }
            #[doc = "Bit 27 - Channel 11 Event Detection"]
            #[inline(always)]
            pub fn evd11(&self) -> EVD11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD11R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel 0 Overrun"]
            #[inline(always)]
            pub fn ovr0(&mut self) -> _OVR0W {
                _OVR0W { w: self }
            }
            #[doc = "Bit 1 - Channel 1 Overrun"]
            #[inline(always)]
            pub fn ovr1(&mut self) -> _OVR1W {
                _OVR1W { w: self }
            }
            #[doc = "Bit 2 - Channel 2 Overrun"]
            #[inline(always)]
            pub fn ovr2(&mut self) -> _OVR2W {
                _OVR2W { w: self }
            }
            #[doc = "Bit 3 - Channel 3 Overrun"]
            #[inline(always)]
            pub fn ovr3(&mut self) -> _OVR3W {
                _OVR3W { w: self }
            }
            #[doc = "Bit 4 - Channel 4 Overrun"]
            #[inline(always)]
            pub fn ovr4(&mut self) -> _OVR4W {
                _OVR4W { w: self }
            }
            #[doc = "Bit 5 - Channel 5 Overrun"]
            #[inline(always)]
            pub fn ovr5(&mut self) -> _OVR5W {
                _OVR5W { w: self }
            }
            #[doc = "Bit 6 - Channel 6 Overrun"]
            #[inline(always)]
            pub fn ovr6(&mut self) -> _OVR6W {
                _OVR6W { w: self }
            }
            #[doc = "Bit 7 - Channel 7 Overrun"]
            #[inline(always)]
            pub fn ovr7(&mut self) -> _OVR7W {
                _OVR7W { w: self }
            }
            #[doc = "Bit 8 - Channel 0 Event Detection"]
            #[inline(always)]
            pub fn evd0(&mut self) -> _EVD0W {
                _EVD0W { w: self }
            }
            #[doc = "Bit 9 - Channel 1 Event Detection"]
            #[inline(always)]
            pub fn evd1(&mut self) -> _EVD1W {
                _EVD1W { w: self }
            }
            #[doc = "Bit 10 - Channel 2 Event Detection"]
            #[inline(always)]
            pub fn evd2(&mut self) -> _EVD2W {
                _EVD2W { w: self }
            }
            #[doc = "Bit 11 - Channel 3 Event Detection"]
            #[inline(always)]
            pub fn evd3(&mut self) -> _EVD3W {
                _EVD3W { w: self }
            }
            #[doc = "Bit 12 - Channel 4 Event Detection"]
            #[inline(always)]
            pub fn evd4(&mut self) -> _EVD4W {
                _EVD4W { w: self }
            }
            #[doc = "Bit 13 - Channel 5 Event Detection"]
            #[inline(always)]
            pub fn evd5(&mut self) -> _EVD5W {
                _EVD5W { w: self }
            }
            #[doc = "Bit 14 - Channel 6 Event Detection"]
            #[inline(always)]
            pub fn evd6(&mut self) -> _EVD6W {
                _EVD6W { w: self }
            }
            #[doc = "Bit 15 - Channel 7 Event Detection"]
            #[inline(always)]
            pub fn evd7(&mut self) -> _EVD7W {
                _EVD7W { w: self }
            }
            #[doc = "Bit 16 - Channel 8 Overrun"]
            #[inline(always)]
            pub fn ovr8(&mut self) -> _OVR8W {
                _OVR8W { w: self }
            }
            #[doc = "Bit 17 - Channel 9 Overrun"]
            #[inline(always)]
            pub fn ovr9(&mut self) -> _OVR9W {
                _OVR9W { w: self }
            }
            #[doc = "Bit 18 - Channel 10 Overrun"]
            #[inline(always)]
            pub fn ovr10(&mut self) -> _OVR10W {
                _OVR10W { w: self }
            }
            #[doc = "Bit 19 - Channel 11 Overrun"]
            #[inline(always)]
            pub fn ovr11(&mut self) -> _OVR11W {
                _OVR11W { w: self }
            }
            #[doc = "Bit 24 - Channel 8 Event Detection"]
            #[inline(always)]
            pub fn evd8(&mut self) -> _EVD8W {
                _EVD8W { w: self }
            }
            #[doc = "Bit 25 - Channel 9 Event Detection"]
            #[inline(always)]
            pub fn evd9(&mut self) -> _EVD9W {
                _EVD9W { w: self }
            }
            #[doc = "Bit 26 - Channel 10 Event Detection"]
            #[inline(always)]
            pub fn evd10(&mut self) -> _EVD10W {
                _EVD10W { w: self }
            }
            #[doc = "Bit 27 - Channel 11 Event Detection"]
            #[inline(always)]
            pub fn evd11(&mut self) -> _EVD11W {
                _EVD11W { w: self }
            }
        }
    }
    #[doc = "User Multiplexer"]
    pub struct USER {
        register: VolatileCell<u16>,
    }
    #[doc = "User Multiplexer"]
    pub mod user {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::USER {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct USERR {
            bits: u8,
        }
        impl USERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CHANNEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CHANNELR {
            #[doc = "No Channel Output Selected"]
            _0,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CHANNELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CHANNELR::_0 => 0,
                    CHANNELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CHANNELR {
                match value {
                    0 => CHANNELR::_0,
                    i => CHANNELR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_0`"]
            #[inline(always)]
            pub fn is_0(&self) -> bool {
                *self == CHANNELR::_0
            }
        }
        #[doc = r" Proxy"]
        pub struct _USERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USERW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CHANNEL`"]
        pub enum CHANNELW {
            #[doc = "No Channel Output Selected"]
            _0,
        }
        impl CHANNELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CHANNELW::_0 => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHANNELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHANNELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHANNELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No Channel Output Selected"]
            #[inline(always)]
            pub fn _0(self) -> &'a mut W {
                self.variant(CHANNELW::_0)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:4 - User Multiplexer Selection"]
            #[inline(always)]
            pub fn user(&self) -> USERR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                USERR { bits }
            }
            #[doc = "Bits 8:12 - Channel Event Selection"]
            #[inline(always)]
            pub fn channel(&self) -> CHANNELR {
                CHANNELR::_from({
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - User Multiplexer Selection"]
            #[inline(always)]
            pub fn user(&mut self) -> _USERW {
                _USERW { w: self }
            }
            #[doc = "Bits 8:12 - Channel Event Selection"]
            #[inline(always)]
            pub fn channel(&mut self) -> _CHANNELW {
                _CHANNELW { w: self }
            }
        }
    }
}
#[doc = "Event System Interface"]
pub struct EVSYS {
    register_block: evsys::RegisterBlock,
}
impl Deref for EVSYS {
    type Target = evsys::RegisterBlock;
    fn deref(&self) -> &evsys::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Generic Clock Generator"]
pub const GCLK: Peripheral<GCLK> = unsafe { Peripheral::new(1073744896) };
#[doc = "Generic Clock Generator"]
pub mod gclk {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctrl: CTRL,
        #[doc = "0x01 - Status"]
        pub status: STATUS,
        #[doc = "0x02 - Generic Clock Control"]
        pub clkctrl: CLKCTRL,
        #[doc = "0x04 - Generic Clock Generator Control"]
        pub genctrl: GENCTRL,
        #[doc = "0x08 - Generic Clock Generator Division"]
        pub gendiv: GENDIV,
    }
    #[doc = "Generic Clock Control"]
    pub struct CLKCTRL {
        register: VolatileCell<u16>,
    }
    #[doc = "Generic Clock Control"]
    pub mod clkctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::CLKCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDR {
            bits: u8,
        }
        impl IDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `GEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GENR {
            #[doc = "Generic clock generator 0"]
            GCLK0,
            #[doc = "Generic clock generator 1"]
            GCLK1,
            #[doc = "Generic clock generator 2"]
            GCLK2,
            #[doc = "Generic clock generator 3"]
            GCLK3,
            #[doc = "Generic clock generator 4"]
            GCLK4,
            #[doc = "Generic clock generator 5"]
            GCLK5,
            #[doc = "Generic clock generator 6"]
            GCLK6,
            #[doc = "Generic clock generator 7"]
            GCLK7,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl GENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    GENR::GCLK0 => 0,
                    GENR::GCLK1 => 1,
                    GENR::GCLK2 => 2,
                    GENR::GCLK3 => 3,
                    GENR::GCLK4 => 4,
                    GENR::GCLK5 => 5,
                    GENR::GCLK6 => 6,
                    GENR::GCLK7 => 7,
                    GENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> GENR {
                match value {
                    0 => GENR::GCLK0,
                    1 => GENR::GCLK1,
                    2 => GENR::GCLK2,
                    3 => GENR::GCLK3,
                    4 => GENR::GCLK4,
                    5 => GENR::GCLK5,
                    6 => GENR::GCLK6,
                    7 => GENR::GCLK7,
                    i => GENR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `GCLK0`"]
            #[inline(always)]
            pub fn is_gclk0(&self) -> bool {
                *self == GENR::GCLK0
            }
            #[doc = "Checks if the value of the field is `GCLK1`"]
            #[inline(always)]
            pub fn is_gclk1(&self) -> bool {
                *self == GENR::GCLK1
            }
            #[doc = "Checks if the value of the field is `GCLK2`"]
            #[inline(always)]
            pub fn is_gclk2(&self) -> bool {
                *self == GENR::GCLK2
            }
            #[doc = "Checks if the value of the field is `GCLK3`"]
            #[inline(always)]
            pub fn is_gclk3(&self) -> bool {
                *self == GENR::GCLK3
            }
            #[doc = "Checks if the value of the field is `GCLK4`"]
            #[inline(always)]
            pub fn is_gclk4(&self) -> bool {
                *self == GENR::GCLK4
            }
            #[doc = "Checks if the value of the field is `GCLK5`"]
            #[inline(always)]
            pub fn is_gclk5(&self) -> bool {
                *self == GENR::GCLK5
            }
            #[doc = "Checks if the value of the field is `GCLK6`"]
            #[inline(always)]
            pub fn is_gclk6(&self) -> bool {
                *self == GENR::GCLK6
            }
            #[doc = "Checks if the value of the field is `GCLK7`"]
            #[inline(always)]
            pub fn is_gclk7(&self) -> bool {
                *self == GENR::GCLK7
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKENR {
            bits: bool,
        }
        impl CLKENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRTLOCKR {
            bits: bool,
        }
        impl WRTLOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GEN`"]
        pub enum GENW {
            #[doc = "Generic clock generator 0"]
            GCLK0,
            #[doc = "Generic clock generator 1"]
            GCLK1,
            #[doc = "Generic clock generator 2"]
            GCLK2,
            #[doc = "Generic clock generator 3"]
            GCLK3,
            #[doc = "Generic clock generator 4"]
            GCLK4,
            #[doc = "Generic clock generator 5"]
            GCLK5,
            #[doc = "Generic clock generator 6"]
            GCLK6,
            #[doc = "Generic clock generator 7"]
            GCLK7,
        }
        impl GENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    GENW::GCLK0 => 0,
                    GENW::GCLK1 => 1,
                    GENW::GCLK2 => 2,
                    GENW::GCLK3 => 3,
                    GENW::GCLK4 => 4,
                    GENW::GCLK5 => 5,
                    GENW::GCLK6 => 6,
                    GENW::GCLK7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: GENW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Generic clock generator 0"]
            #[inline(always)]
            pub fn gclk0(self) -> &'a mut W {
                self.variant(GENW::GCLK0)
            }
            #[doc = "Generic clock generator 1"]
            #[inline(always)]
            pub fn gclk1(self) -> &'a mut W {
                self.variant(GENW::GCLK1)
            }
            #[doc = "Generic clock generator 2"]
            #[inline(always)]
            pub fn gclk2(self) -> &'a mut W {
                self.variant(GENW::GCLK2)
            }
            #[doc = "Generic clock generator 3"]
            #[inline(always)]
            pub fn gclk3(self) -> &'a mut W {
                self.variant(GENW::GCLK3)
            }
            #[doc = "Generic clock generator 4"]
            #[inline(always)]
            pub fn gclk4(self) -> &'a mut W {
                self.variant(GENW::GCLK4)
            }
            #[doc = "Generic clock generator 5"]
            #[inline(always)]
            pub fn gclk5(self) -> &'a mut W {
                self.variant(GENW::GCLK5)
            }
            #[doc = "Generic clock generator 6"]
            #[inline(always)]
            pub fn gclk6(self) -> &'a mut W {
                self.variant(GENW::GCLK6)
            }
            #[doc = "Generic clock generator 7"]
            #[inline(always)]
            pub fn gclk7(self) -> &'a mut W {
                self.variant(GENW::GCLK7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRTLOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRTLOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:5 - Generic Clock Selection ID"]
            #[inline(always)]
            pub fn id(&self) -> IDR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                IDR { bits }
            }
            #[doc = "Bits 8:11 - Generic Clock Generator"]
            #[inline(always)]
            pub fn gen(&self) -> GENR {
                GENR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bit 14 - Clock Enable"]
            #[inline(always)]
            pub fn clken(&self) -> CLKENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                CLKENR { bits }
            }
            #[doc = "Bit 15 - Write Lock"]
            #[inline(always)]
            pub fn wrtlock(&self) -> WRTLOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                WRTLOCKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - Generic Clock Selection ID"]
            #[inline(always)]
            pub fn id(&mut self) -> _IDW {
                _IDW { w: self }
            }
            #[doc = "Bits 8:11 - Generic Clock Generator"]
            #[inline(always)]
            pub fn gen(&mut self) -> _GENW {
                _GENW { w: self }
            }
            #[doc = "Bit 14 - Clock Enable"]
            #[inline(always)]
            pub fn clken(&mut self) -> _CLKENW {
                _CLKENW { w: self }
            }
            #[doc = "Bit 15 - Write Lock"]
            #[inline(always)]
            pub fn wrtlock(&mut self) -> _WRTLOCKW {
                _WRTLOCKW { w: self }
            }
        }
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SWRSTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
        }
    }
    #[doc = "Generic Clock Generator Control"]
    pub struct GENCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Generic Clock Generator Control"]
    pub mod genctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GENCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDR {
            bits: u8,
        }
        impl IDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `SRC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRCR {
            #[doc = "XOSC oscillator output"]
            XOSC,
            #[doc = "Generator input pad"]
            GCLKIN,
            #[doc = "Generic clock generator 1 output"]
            GCLKGEN1,
            #[doc = "OSCULP32K oscillator output"]
            OSCULP32K,
            #[doc = "OSC32K oscillator output"]
            OSC32K,
            #[doc = "XOSC32K oscillator output"]
            XOSC32K,
            #[doc = "OSC8M oscillator output"]
            OSC8M,
            #[doc = "DFLL48M output"]
            DFLL48M,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SRCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRCR::XOSC => 0,
                    SRCR::GCLKIN => 1,
                    SRCR::GCLKGEN1 => 2,
                    SRCR::OSCULP32K => 3,
                    SRCR::OSC32K => 4,
                    SRCR::XOSC32K => 5,
                    SRCR::OSC8M => 6,
                    SRCR::DFLL48M => 7,
                    SRCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SRCR {
                match value {
                    0 => SRCR::XOSC,
                    1 => SRCR::GCLKIN,
                    2 => SRCR::GCLKGEN1,
                    3 => SRCR::OSCULP32K,
                    4 => SRCR::OSC32K,
                    5 => SRCR::XOSC32K,
                    6 => SRCR::OSC8M,
                    7 => SRCR::DFLL48M,
                    i => SRCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `XOSC`"]
            #[inline(always)]
            pub fn is_xosc(&self) -> bool {
                *self == SRCR::XOSC
            }
            #[doc = "Checks if the value of the field is `GCLKIN`"]
            #[inline(always)]
            pub fn is_gclkin(&self) -> bool {
                *self == SRCR::GCLKIN
            }
            #[doc = "Checks if the value of the field is `GCLKGEN1`"]
            #[inline(always)]
            pub fn is_gclkgen1(&self) -> bool {
                *self == SRCR::GCLKGEN1
            }
            #[doc = "Checks if the value of the field is `OSCULP32K`"]
            #[inline(always)]
            pub fn is_osculp32k(&self) -> bool {
                *self == SRCR::OSCULP32K
            }
            #[doc = "Checks if the value of the field is `OSC32K`"]
            #[inline(always)]
            pub fn is_osc32k(&self) -> bool {
                *self == SRCR::OSC32K
            }
            #[doc = "Checks if the value of the field is `XOSC32K`"]
            #[inline(always)]
            pub fn is_xosc32k(&self) -> bool {
                *self == SRCR::XOSC32K
            }
            #[doc = "Checks if the value of the field is `OSC8M`"]
            #[inline(always)]
            pub fn is_osc8m(&self) -> bool {
                *self == SRCR::OSC8M
            }
            #[doc = "Checks if the value of the field is `DFLL48M`"]
            #[inline(always)]
            pub fn is_dfll48m(&self) -> bool {
                *self == SRCR::DFLL48M
            }
        }
        #[doc = r" Value of the field"]
        pub struct GENENR {
            bits: bool,
        }
        impl GENENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDCR {
            bits: bool,
        }
        impl IDCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OOVR {
            bits: bool,
        }
        impl OOVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OER {
            bits: bool,
        }
        impl OER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVSELR {
            bits: bool,
        }
        impl DIVSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC`"]
        pub enum SRCW {
            #[doc = "XOSC oscillator output"]
            XOSC,
            #[doc = "Generator input pad"]
            GCLKIN,
            #[doc = "Generic clock generator 1 output"]
            GCLKGEN1,
            #[doc = "OSCULP32K oscillator output"]
            OSCULP32K,
            #[doc = "OSC32K oscillator output"]
            OSC32K,
            #[doc = "XOSC32K oscillator output"]
            XOSC32K,
            #[doc = "OSC8M oscillator output"]
            OSC8M,
            #[doc = "DFLL48M output"]
            DFLL48M,
        }
        impl SRCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRCW::XOSC => 0,
                    SRCW::GCLKIN => 1,
                    SRCW::GCLKGEN1 => 2,
                    SRCW::OSCULP32K => 3,
                    SRCW::OSC32K => 4,
                    SRCW::XOSC32K => 5,
                    SRCW::OSC8M => 6,
                    SRCW::DFLL48M => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SRCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "XOSC oscillator output"]
            #[inline(always)]
            pub fn xosc(self) -> &'a mut W {
                self.variant(SRCW::XOSC)
            }
            #[doc = "Generator input pad"]
            #[inline(always)]
            pub fn gclkin(self) -> &'a mut W {
                self.variant(SRCW::GCLKIN)
            }
            #[doc = "Generic clock generator 1 output"]
            #[inline(always)]
            pub fn gclkgen1(self) -> &'a mut W {
                self.variant(SRCW::GCLKGEN1)
            }
            #[doc = "OSCULP32K oscillator output"]
            #[inline(always)]
            pub fn osculp32k(self) -> &'a mut W {
                self.variant(SRCW::OSCULP32K)
            }
            #[doc = "OSC32K oscillator output"]
            #[inline(always)]
            pub fn osc32k(self) -> &'a mut W {
                self.variant(SRCW::OSC32K)
            }
            #[doc = "XOSC32K oscillator output"]
            #[inline(always)]
            pub fn xosc32k(self) -> &'a mut W {
                self.variant(SRCW::XOSC32K)
            }
            #[doc = "OSC8M oscillator output"]
            #[inline(always)]
            pub fn osc8m(self) -> &'a mut W {
                self.variant(SRCW::OSC8M)
            }
            #[doc = "DFLL48M output"]
            #[inline(always)]
            pub fn dfll48m(self) -> &'a mut W {
                self.variant(SRCW::DFLL48M)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GENENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GENENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OOVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OOVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVSELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Generic Clock Generator Selection"]
            #[inline(always)]
            pub fn id(&self) -> IDR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IDR { bits }
            }
            #[doc = "Bits 8:12 - Source Select"]
            #[inline(always)]
            pub fn src(&self) -> SRCR {
                SRCR::_from({
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 16 - Generic Clock Generator Enable"]
            #[inline(always)]
            pub fn genen(&self) -> GENENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GENENR { bits }
            }
            #[doc = "Bit 17 - Improve Duty Cycle"]
            #[inline(always)]
            pub fn idc(&self) -> IDCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IDCR { bits }
            }
            #[doc = "Bit 18 - Output Off Value"]
            #[inline(always)]
            pub fn oov(&self) -> OOVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OOVR { bits }
            }
            #[doc = "Bit 19 - Output Enable"]
            #[inline(always)]
            pub fn oe(&self) -> OER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OER { bits }
            }
            #[doc = "Bit 20 - Divide Selection"]
            #[inline(always)]
            pub fn divsel(&self) -> DIVSELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DIVSELR { bits }
            }
            #[doc = "Bit 21 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RUNSTDBYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Generic Clock Generator Selection"]
            #[inline(always)]
            pub fn id(&mut self) -> _IDW {
                _IDW { w: self }
            }
            #[doc = "Bits 8:12 - Source Select"]
            #[inline(always)]
            pub fn src(&mut self) -> _SRCW {
                _SRCW { w: self }
            }
            #[doc = "Bit 16 - Generic Clock Generator Enable"]
            #[inline(always)]
            pub fn genen(&mut self) -> _GENENW {
                _GENENW { w: self }
            }
            #[doc = "Bit 17 - Improve Duty Cycle"]
            #[inline(always)]
            pub fn idc(&mut self) -> _IDCW {
                _IDCW { w: self }
            }
            #[doc = "Bit 18 - Output Off Value"]
            #[inline(always)]
            pub fn oov(&mut self) -> _OOVW {
                _OOVW { w: self }
            }
            #[doc = "Bit 19 - Output Enable"]
            #[inline(always)]
            pub fn oe(&mut self) -> _OEW {
                _OEW { w: self }
            }
            #[doc = "Bit 20 - Divide Selection"]
            #[inline(always)]
            pub fn divsel(&mut self) -> _DIVSELW {
                _DIVSELW { w: self }
            }
            #[doc = "Bit 21 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
        }
    }
    #[doc = "Generic Clock Generator Division"]
    pub struct GENDIV {
        register: VolatileCell<u32>,
    }
    #[doc = "Generic Clock Generator Division"]
    pub mod gendiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GENDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDR {
            bits: u8,
        }
        impl IDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u16,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Generic Clock Generator Selection"]
            #[inline(always)]
            pub fn id(&self) -> IDR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IDR { bits }
            }
            #[doc = "Bits 8:23 - Division Factor"]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Generic Clock Generator Selection"]
            #[inline(always)]
            pub fn id(&mut self) -> _IDW {
                _IDW { w: self }
            }
            #[doc = "Bits 8:23 - Division Factor"]
            #[inline(always)]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 7 - Synchronization Busy Status"]
            #[inline(always)]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCBUSYR { bits }
            }
        }
    }
}
#[doc = "Generic Clock Generator"]
pub struct GCLK {
    register_block: gclk::RegisterBlock,
}
impl Deref for GCLK {
    type Target = gclk::RegisterBlock;
    fn deref(&self) -> &gclk::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Inter-IC Sound Interface"]
pub const I2S: Peripheral<I2S> = unsafe { Peripheral::new(1107316736) };
#[doc = "Inter-IC Sound Interface"]
pub mod i2s {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control A"]
        pub ctrla: CTRLA,
        _reserved0: [u8; 3usize],
        #[doc = "0x04 - Clock Unit n Control"]
        pub clkctrl0: CLKCTRL,
        #[doc = "0x08 - Clock Unit n Control"]
        pub clkctrl1: CLKCTRL,
        #[doc = "0x0c - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        _reserved1: [u8; 2usize],
        #[doc = "0x10 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        _reserved2: [u8; 2usize],
        #[doc = "0x14 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        _reserved3: [u8; 2usize],
        #[doc = "0x18 - Synchronization Status"]
        pub syncbusy: SYNCBUSY,
        _reserved4: [u8; 6usize],
        #[doc = "0x20 - Serializer n Control"]
        pub serctrl0: SERCTRL,
        #[doc = "0x24 - Serializer n Control"]
        pub serctrl1: SERCTRL,
        _reserved5: [u8; 8usize],
        #[doc = "0x30 - Data n"]
        pub data0: DATA,
        #[doc = "0x34 - Data n"]
        pub data1: DATA,
    }
    #[doc = "Clock Unit n Control"]
    pub struct CLKCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Clock Unit n Control"]
    pub mod clkctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLKCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SLOTSIZE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLOTSIZER {
            #[doc = "8-bit Slot for Clock Unit n"]
            _8,
            #[doc = "16-bit Slot for Clock Unit n"]
            _16,
            #[doc = "24-bit Slot for Clock Unit n"]
            _24,
            #[doc = "32-bit Slot for Clock Unit n"]
            _32,
        }
        impl SLOTSIZER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SLOTSIZER::_8 => 0,
                    SLOTSIZER::_16 => 1,
                    SLOTSIZER::_24 => 2,
                    SLOTSIZER::_32 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SLOTSIZER {
                match value {
                    0 => SLOTSIZER::_8,
                    1 => SLOTSIZER::_16,
                    2 => SLOTSIZER::_24,
                    3 => SLOTSIZER::_32,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_8`"]
            #[inline(always)]
            pub fn is_8(&self) -> bool {
                *self == SLOTSIZER::_8
            }
            #[doc = "Checks if the value of the field is `_16`"]
            #[inline(always)]
            pub fn is_16(&self) -> bool {
                *self == SLOTSIZER::_16
            }
            #[doc = "Checks if the value of the field is `_24`"]
            #[inline(always)]
            pub fn is_24(&self) -> bool {
                *self == SLOTSIZER::_24
            }
            #[doc = "Checks if the value of the field is `_32`"]
            #[inline(always)]
            pub fn is_32(&self) -> bool {
                *self == SLOTSIZER::_32
            }
        }
        #[doc = r" Value of the field"]
        pub struct NBSLOTSR {
            bits: u8,
        }
        impl NBSLOTSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `FSWIDTH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FSWIDTHR {
            #[doc = "Frame Sync Pulse is 1 Slot wide (default for I2S protocol)"]
            SLOT,
            #[doc = "Frame Sync Pulse is half a Frame wide"]
            HALF,
            #[doc = "Frame Sync Pulse is 1 Bit wide"]
            BIT,
            #[doc = "Clock Unit n operates in Burst mode, with a 1-bit wide Frame Sync pulse per Data sample, only when Data transfer is requested"]
            BURST,
        }
        impl FSWIDTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    FSWIDTHR::SLOT => 0,
                    FSWIDTHR::HALF => 1,
                    FSWIDTHR::BIT => 2,
                    FSWIDTHR::BURST => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> FSWIDTHR {
                match value {
                    0 => FSWIDTHR::SLOT,
                    1 => FSWIDTHR::HALF,
                    2 => FSWIDTHR::BIT,
                    3 => FSWIDTHR::BURST,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SLOT`"]
            #[inline(always)]
            pub fn is_slot(&self) -> bool {
                *self == FSWIDTHR::SLOT
            }
            #[doc = "Checks if the value of the field is `HALF`"]
            #[inline(always)]
            pub fn is_half(&self) -> bool {
                *self == FSWIDTHR::HALF
            }
            #[doc = "Checks if the value of the field is `BIT`"]
            #[inline(always)]
            pub fn is_bit_(&self) -> bool {
                *self == FSWIDTHR::BIT
            }
            #[doc = "Checks if the value of the field is `BURST`"]
            #[inline(always)]
            pub fn is_burst(&self) -> bool {
                *self == FSWIDTHR::BURST
            }
        }
        #[doc = "Possible values of the field `BITDELAY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BITDELAYR {
            #[doc = "Left Justified (0 Bit Delay)"]
            LJ,
            #[doc = "I2S (1 Bit Delay)"]
            I2S,
        }
        impl BITDELAYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    BITDELAYR::LJ => false,
                    BITDELAYR::I2S => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> BITDELAYR {
                match value {
                    false => BITDELAYR::LJ,
                    true => BITDELAYR::I2S,
                }
            }
            #[doc = "Checks if the value of the field is `LJ`"]
            #[inline(always)]
            pub fn is_lj(&self) -> bool {
                *self == BITDELAYR::LJ
            }
            #[doc = "Checks if the value of the field is `I2S`"]
            #[inline(always)]
            pub fn is_i2s(&self) -> bool {
                *self == BITDELAYR::I2S
            }
        }
        #[doc = "Possible values of the field `FSSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FSSELR {
            #[doc = "Divided Serial Clock n is used as Frame Sync n source"]
            SCKDIV,
            #[doc = "FSn input pin is used as Frame Sync n source"]
            FSPIN,
        }
        impl FSSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FSSELR::SCKDIV => false,
                    FSSELR::FSPIN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FSSELR {
                match value {
                    false => FSSELR::SCKDIV,
                    true => FSSELR::FSPIN,
                }
            }
            #[doc = "Checks if the value of the field is `SCKDIV`"]
            #[inline(always)]
            pub fn is_sckdiv(&self) -> bool {
                *self == FSSELR::SCKDIV
            }
            #[doc = "Checks if the value of the field is `FSPIN`"]
            #[inline(always)]
            pub fn is_fspin(&self) -> bool {
                *self == FSSELR::FSPIN
            }
        }
        #[doc = r" Value of the field"]
        pub struct FSINVR {
            bits: bool,
        }
        impl FSINVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SCKSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCKSELR {
            #[doc = "Divided Master Clock n is used as Serial Clock n source"]
            MCKDIV,
            #[doc = "SCKn input pin is used as Serial Clock n source"]
            SCKPIN,
        }
        impl SCKSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCKSELR::MCKDIV => false,
                    SCKSELR::SCKPIN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCKSELR {
                match value {
                    false => SCKSELR::MCKDIV,
                    true => SCKSELR::SCKPIN,
                }
            }
            #[doc = "Checks if the value of the field is `MCKDIV`"]
            #[inline(always)]
            pub fn is_mckdiv(&self) -> bool {
                *self == SCKSELR::MCKDIV
            }
            #[doc = "Checks if the value of the field is `SCKPIN`"]
            #[inline(always)]
            pub fn is_sckpin(&self) -> bool {
                *self == SCKSELR::SCKPIN
            }
        }
        #[doc = "Possible values of the field `MCKSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MCKSELR {
            #[doc = "clk_gen_n is used as Master Clock n source"]
            GCLK,
            #[doc = "MCKn input pin is used as Master Clock n source"]
            MCKPIN,
        }
        impl MCKSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MCKSELR::GCLK => false,
                    MCKSELR::MCKPIN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MCKSELR {
                match value {
                    false => MCKSELR::GCLK,
                    true => MCKSELR::MCKPIN,
                }
            }
            #[doc = "Checks if the value of the field is `GCLK`"]
            #[inline(always)]
            pub fn is_gclk(&self) -> bool {
                *self == MCKSELR::GCLK
            }
            #[doc = "Checks if the value of the field is `MCKPIN`"]
            #[inline(always)]
            pub fn is_mckpin(&self) -> bool {
                *self == MCKSELR::MCKPIN
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCKENR {
            bits: bool,
        }
        impl MCKENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCKDIVR {
            bits: u8,
        }
        impl MCKDIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCKOUTDIVR {
            bits: u8,
        }
        impl MCKOUTDIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FSOUTINVR {
            bits: bool,
        }
        impl FSOUTINVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCKOUTINVR {
            bits: bool,
        }
        impl SCKOUTINVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCKOUTINVR {
            bits: bool,
        }
        impl MCKOUTINVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `SLOTSIZE`"]
        pub enum SLOTSIZEW {
            #[doc = "8-bit Slot for Clock Unit n"]
            _8,
            #[doc = "16-bit Slot for Clock Unit n"]
            _16,
            #[doc = "24-bit Slot for Clock Unit n"]
            _24,
            #[doc = "32-bit Slot for Clock Unit n"]
            _32,
        }
        impl SLOTSIZEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SLOTSIZEW::_8 => 0,
                    SLOTSIZEW::_16 => 1,
                    SLOTSIZEW::_24 => 2,
                    SLOTSIZEW::_32 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLOTSIZEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLOTSIZEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLOTSIZEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "8-bit Slot for Clock Unit n"]
            #[inline(always)]
            pub fn _8(self) -> &'a mut W {
                self.variant(SLOTSIZEW::_8)
            }
            #[doc = "16-bit Slot for Clock Unit n"]
            #[inline(always)]
            pub fn _16(self) -> &'a mut W {
                self.variant(SLOTSIZEW::_16)
            }
            #[doc = "24-bit Slot for Clock Unit n"]
            #[inline(always)]
            pub fn _24(self) -> &'a mut W {
                self.variant(SLOTSIZEW::_24)
            }
            #[doc = "32-bit Slot for Clock Unit n"]
            #[inline(always)]
            pub fn _32(self) -> &'a mut W {
                self.variant(SLOTSIZEW::_32)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NBSLOTSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NBSLOTSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FSWIDTH`"]
        pub enum FSWIDTHW {
            #[doc = "Frame Sync Pulse is 1 Slot wide (default for I2S protocol)"]
            SLOT,
            #[doc = "Frame Sync Pulse is half a Frame wide"]
            HALF,
            #[doc = "Frame Sync Pulse is 1 Bit wide"]
            BIT,
            #[doc = "Clock Unit n operates in Burst mode, with a 1-bit wide Frame Sync pulse per Data sample, only when Data transfer is requested"]
            BURST,
        }
        impl FSWIDTHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FSWIDTHW::SLOT => 0,
                    FSWIDTHW::HALF => 1,
                    FSWIDTHW::BIT => 2,
                    FSWIDTHW::BURST => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FSWIDTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FSWIDTHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FSWIDTHW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Frame Sync Pulse is 1 Slot wide (default for I2S protocol)"]
            #[inline(always)]
            pub fn slot(self) -> &'a mut W {
                self.variant(FSWIDTHW::SLOT)
            }
            #[doc = "Frame Sync Pulse is half a Frame wide"]
            #[inline(always)]
            pub fn half(self) -> &'a mut W {
                self.variant(FSWIDTHW::HALF)
            }
            #[doc = "Frame Sync Pulse is 1 Bit wide"]
            #[inline(always)]
            pub fn bit_(self) -> &'a mut W {
                self.variant(FSWIDTHW::BIT)
            }
            #[doc = "Clock Unit n operates in Burst mode, with a 1-bit wide Frame Sync pulse per Data sample, only when Data transfer is requested"]
            #[inline(always)]
            pub fn burst(self) -> &'a mut W {
                self.variant(FSWIDTHW::BURST)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BITDELAY`"]
        pub enum BITDELAYW {
            #[doc = "Left Justified (0 Bit Delay)"]
            LJ,
            #[doc = "I2S (1 Bit Delay)"]
            I2S,
        }
        impl BITDELAYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    BITDELAYW::LJ => false,
                    BITDELAYW::I2S => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BITDELAYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BITDELAYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BITDELAYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Left Justified (0 Bit Delay)"]
            #[inline(always)]
            pub fn lj(self) -> &'a mut W {
                self.variant(BITDELAYW::LJ)
            }
            #[doc = "I2S (1 Bit Delay)"]
            #[inline(always)]
            pub fn i2s(self) -> &'a mut W {
                self.variant(BITDELAYW::I2S)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FSSEL`"]
        pub enum FSSELW {
            #[doc = "Divided Serial Clock n is used as Frame Sync n source"]
            SCKDIV,
            #[doc = "FSn input pin is used as Frame Sync n source"]
            FSPIN,
        }
        impl FSSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    FSSELW::SCKDIV => false,
                    FSSELW::FSPIN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FSSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FSSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FSSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Divided Serial Clock n is used as Frame Sync n source"]
            #[inline(always)]
            pub fn sckdiv(self) -> &'a mut W {
                self.variant(FSSELW::SCKDIV)
            }
            #[doc = "FSn input pin is used as Frame Sync n source"]
            #[inline(always)]
            pub fn fspin(self) -> &'a mut W {
                self.variant(FSSELW::FSPIN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FSINVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FSINVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCKSEL`"]
        pub enum SCKSELW {
            #[doc = "Divided Master Clock n is used as Serial Clock n source"]
            MCKDIV,
            #[doc = "SCKn input pin is used as Serial Clock n source"]
            SCKPIN,
        }
        impl SCKSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SCKSELW::MCKDIV => false,
                    SCKSELW::SCKPIN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCKSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCKSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCKSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Divided Master Clock n is used as Serial Clock n source"]
            #[inline(always)]
            pub fn mckdiv(self) -> &'a mut W {
                self.variant(SCKSELW::MCKDIV)
            }
            #[doc = "SCKn input pin is used as Serial Clock n source"]
            #[inline(always)]
            pub fn sckpin(self) -> &'a mut W {
                self.variant(SCKSELW::SCKPIN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MCKSEL`"]
        pub enum MCKSELW {
            #[doc = "clk_gen_n is used as Master Clock n source"]
            GCLK,
            #[doc = "MCKn input pin is used as Master Clock n source"]
            MCKPIN,
        }
        impl MCKSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MCKSELW::GCLK => false,
                    MCKSELW::MCKPIN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCKSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCKSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MCKSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "clk_gen_n is used as Master Clock n source"]
            #[inline(always)]
            pub fn gclk(self) -> &'a mut W {
                self.variant(MCKSELW::GCLK)
            }
            #[doc = "MCKn input pin is used as Master Clock n source"]
            #[inline(always)]
            pub fn mckpin(self) -> &'a mut W {
                self.variant(MCKSELW::MCKPIN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCKENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCKENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCKDIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCKDIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCKOUTDIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCKOUTDIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FSOUTINVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FSOUTINVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCKOUTINVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCKOUTINVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCKOUTINVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCKOUTINVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Slot Size"]
            #[inline(always)]
            pub fn slotsize(&self) -> SLOTSIZER {
                SLOTSIZER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:4 - Number of Slots in Frame"]
            #[inline(always)]
            pub fn nbslots(&self) -> NBSLOTSR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NBSLOTSR { bits }
            }
            #[doc = "Bits 5:6 - Frame Sync Width"]
            #[inline(always)]
            pub fn fswidth(&self) -> FSWIDTHR {
                FSWIDTHR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 7 - Data Delay from Frame Sync"]
            #[inline(always)]
            pub fn bitdelay(&self) -> BITDELAYR {
                BITDELAYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Frame Sync Select"]
            #[inline(always)]
            pub fn fssel(&self) -> FSSELR {
                FSSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Frame Sync Invert"]
            #[inline(always)]
            pub fn fsinv(&self) -> FSINVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FSINVR { bits }
            }
            #[doc = "Bit 12 - Serial Clock Select"]
            #[inline(always)]
            pub fn scksel(&self) -> SCKSELR {
                SCKSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Master Clock Select"]
            #[inline(always)]
            pub fn mcksel(&self) -> MCKSELR {
                MCKSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Master Clock Enable"]
            #[inline(always)]
            pub fn mcken(&self) -> MCKENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MCKENR { bits }
            }
            #[doc = "Bits 19:23 - Master Clock Division Factor"]
            #[inline(always)]
            pub fn mckdiv(&self) -> MCKDIVR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MCKDIVR { bits }
            }
            #[doc = "Bits 24:28 - Master Clock Output Division Factor"]
            #[inline(always)]
            pub fn mckoutdiv(&self) -> MCKOUTDIVR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MCKOUTDIVR { bits }
            }
            #[doc = "Bit 29 - Frame Sync Output Invert"]
            #[inline(always)]
            pub fn fsoutinv(&self) -> FSOUTINVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FSOUTINVR { bits }
            }
            #[doc = "Bit 30 - Serial Clock Output Invert"]
            #[inline(always)]
            pub fn sckoutinv(&self) -> SCKOUTINVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SCKOUTINVR { bits }
            }
            #[doc = "Bit 31 - Master Clock Output Invert"]
            #[inline(always)]
            pub fn mckoutinv(&self) -> MCKOUTINVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MCKOUTINVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Slot Size"]
            #[inline(always)]
            pub fn slotsize(&mut self) -> _SLOTSIZEW {
                _SLOTSIZEW { w: self }
            }
            #[doc = "Bits 2:4 - Number of Slots in Frame"]
            #[inline(always)]
            pub fn nbslots(&mut self) -> _NBSLOTSW {
                _NBSLOTSW { w: self }
            }
            #[doc = "Bits 5:6 - Frame Sync Width"]
            #[inline(always)]
            pub fn fswidth(&mut self) -> _FSWIDTHW {
                _FSWIDTHW { w: self }
            }
            #[doc = "Bit 7 - Data Delay from Frame Sync"]
            #[inline(always)]
            pub fn bitdelay(&mut self) -> _BITDELAYW {
                _BITDELAYW { w: self }
            }
            #[doc = "Bit 8 - Frame Sync Select"]
            #[inline(always)]
            pub fn fssel(&mut self) -> _FSSELW {
                _FSSELW { w: self }
            }
            #[doc = "Bit 11 - Frame Sync Invert"]
            #[inline(always)]
            pub fn fsinv(&mut self) -> _FSINVW {
                _FSINVW { w: self }
            }
            #[doc = "Bit 12 - Serial Clock Select"]
            #[inline(always)]
            pub fn scksel(&mut self) -> _SCKSELW {
                _SCKSELW { w: self }
            }
            #[doc = "Bit 16 - Master Clock Select"]
            #[inline(always)]
            pub fn mcksel(&mut self) -> _MCKSELW {
                _MCKSELW { w: self }
            }
            #[doc = "Bit 18 - Master Clock Enable"]
            #[inline(always)]
            pub fn mcken(&mut self) -> _MCKENW {
                _MCKENW { w: self }
            }
            #[doc = "Bits 19:23 - Master Clock Division Factor"]
            #[inline(always)]
            pub fn mckdiv(&mut self) -> _MCKDIVW {
                _MCKDIVW { w: self }
            }
            #[doc = "Bits 24:28 - Master Clock Output Division Factor"]
            #[inline(always)]
            pub fn mckoutdiv(&mut self) -> _MCKOUTDIVW {
                _MCKOUTDIVW { w: self }
            }
            #[doc = "Bit 29 - Frame Sync Output Invert"]
            #[inline(always)]
            pub fn fsoutinv(&mut self) -> _FSOUTINVW {
                _FSOUTINVW { w: self }
            }
            #[doc = "Bit 30 - Serial Clock Output Invert"]
            #[inline(always)]
            pub fn sckoutinv(&mut self) -> _SCKOUTINVW {
                _SCKOUTINVW { w: self }
            }
            #[doc = "Bit 31 - Master Clock Output Invert"]
            #[inline(always)]
            pub fn mckoutinv(&mut self) -> _MCKOUTINVW {
                _MCKOUTINVW { w: self }
            }
        }
    }
    #[doc = "Control A"]
    pub struct CTRLA {
        register: VolatileCell<u8>,
    }
    #[doc = "Control A"]
    pub mod ctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKEN0R {
            bits: bool,
        }
        impl CKEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKEN1R {
            bits: bool,
        }
        impl CKEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SEREN0R {
            bits: bool,
        }
        impl SEREN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SEREN1R {
            bits: bool,
        }
        impl SEREN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEREN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEREN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEREN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEREN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SWRSTR { bits }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Clock Unit 0 Enable"]
            #[inline(always)]
            pub fn cken0(&self) -> CKEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CKEN0R { bits }
            }
            #[doc = "Bit 3 - Clock Unit 1 Enable"]
            #[inline(always)]
            pub fn cken1(&self) -> CKEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CKEN1R { bits }
            }
            #[doc = "Bit 4 - Serializer 0 Enable"]
            #[inline(always)]
            pub fn seren0(&self) -> SEREN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SEREN0R { bits }
            }
            #[doc = "Bit 5 - Serializer 1 Enable"]
            #[inline(always)]
            pub fn seren1(&self) -> SEREN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SEREN1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Clock Unit 0 Enable"]
            #[inline(always)]
            pub fn cken0(&mut self) -> _CKEN0W {
                _CKEN0W { w: self }
            }
            #[doc = "Bit 3 - Clock Unit 1 Enable"]
            #[inline(always)]
            pub fn cken1(&mut self) -> _CKEN1W {
                _CKEN1W { w: self }
            }
            #[doc = "Bit 4 - Serializer 0 Enable"]
            #[inline(always)]
            pub fn seren0(&mut self) -> _SEREN0W {
                _SEREN0W { w: self }
            }
            #[doc = "Bit 5 - Serializer 1 Enable"]
            #[inline(always)]
            pub fn seren1(&mut self) -> _SEREN1W {
                _SEREN1W { w: self }
            }
        }
    }
    #[doc = "Data n"]
    pub struct DATA {
        register: VolatileCell<u32>,
    }
    #[doc = "Data n"]
    pub mod data {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u32,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Sample Data"]
            #[inline(always)]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Sample Data"]
            #[inline(always)]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u16>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDY0R {
            bits: bool,
        }
        impl RXRDY0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDY1R {
            bits: bool,
        }
        impl RXRDY1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXOR0R {
            bits: bool,
        }
        impl RXOR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXOR1R {
            bits: bool,
        }
        impl RXOR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDY0R {
            bits: bool,
        }
        impl TXRDY0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDY1R {
            bits: bool,
        }
        impl TXRDY1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXUR0R {
            bits: bool,
        }
        impl TXUR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXUR1R {
            bits: bool,
        }
        impl TXUR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDY0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDY0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDY1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDY1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXOR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXOR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXOR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXOR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDY0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDY0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDY1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDY1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXUR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXUR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXUR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXUR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Receive Ready 0 Interrupt Enable"]
            #[inline(always)]
            pub fn rxrdy0(&self) -> RXRDY0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RXRDY0R { bits }
            }
            #[doc = "Bit 1 - Receive Ready 1 Interrupt Enable"]
            #[inline(always)]
            pub fn rxrdy1(&self) -> RXRDY1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RXRDY1R { bits }
            }
            #[doc = "Bit 4 - Receive Overrun 0 Interrupt Enable"]
            #[inline(always)]
            pub fn rxor0(&self) -> RXOR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RXOR0R { bits }
            }
            #[doc = "Bit 5 - Receive Overrun 1 Interrupt Enable"]
            #[inline(always)]
            pub fn rxor1(&self) -> RXOR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RXOR1R { bits }
            }
            #[doc = "Bit 8 - Transmit Ready 0 Interrupt Enable"]
            #[inline(always)]
            pub fn txrdy0(&self) -> TXRDY0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TXRDY0R { bits }
            }
            #[doc = "Bit 9 - Transmit Ready 1 Interrupt Enable"]
            #[inline(always)]
            pub fn txrdy1(&self) -> TXRDY1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TXRDY1R { bits }
            }
            #[doc = "Bit 12 - Transmit Underrun 0 Interrupt Enable"]
            #[inline(always)]
            pub fn txur0(&self) -> TXUR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TXUR0R { bits }
            }
            #[doc = "Bit 13 - Transmit Underrun 1 Interrupt Enable"]
            #[inline(always)]
            pub fn txur1(&self) -> TXUR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TXUR1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Receive Ready 0 Interrupt Enable"]
            #[inline(always)]
            pub fn rxrdy0(&mut self) -> _RXRDY0W {
                _RXRDY0W { w: self }
            }
            #[doc = "Bit 1 - Receive Ready 1 Interrupt Enable"]
            #[inline(always)]
            pub fn rxrdy1(&mut self) -> _RXRDY1W {
                _RXRDY1W { w: self }
            }
            #[doc = "Bit 4 - Receive Overrun 0 Interrupt Enable"]
            #[inline(always)]
            pub fn rxor0(&mut self) -> _RXOR0W {
                _RXOR0W { w: self }
            }
            #[doc = "Bit 5 - Receive Overrun 1 Interrupt Enable"]
            #[inline(always)]
            pub fn rxor1(&mut self) -> _RXOR1W {
                _RXOR1W { w: self }
            }
            #[doc = "Bit 8 - Transmit Ready 0 Interrupt Enable"]
            #[inline(always)]
            pub fn txrdy0(&mut self) -> _TXRDY0W {
                _TXRDY0W { w: self }
            }
            #[doc = "Bit 9 - Transmit Ready 1 Interrupt Enable"]
            #[inline(always)]
            pub fn txrdy1(&mut self) -> _TXRDY1W {
                _TXRDY1W { w: self }
            }
            #[doc = "Bit 12 - Transmit Underrun 0 Interrupt Enable"]
            #[inline(always)]
            pub fn txur0(&mut self) -> _TXUR0W {
                _TXUR0W { w: self }
            }
            #[doc = "Bit 13 - Transmit Underrun 1 Interrupt Enable"]
            #[inline(always)]
            pub fn txur1(&mut self) -> _TXUR1W {
                _TXUR1W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u16>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDY0R {
            bits: bool,
        }
        impl RXRDY0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDY1R {
            bits: bool,
        }
        impl RXRDY1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXOR0R {
            bits: bool,
        }
        impl RXOR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXOR1R {
            bits: bool,
        }
        impl RXOR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDY0R {
            bits: bool,
        }
        impl TXRDY0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDY1R {
            bits: bool,
        }
        impl TXRDY1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXUR0R {
            bits: bool,
        }
        impl TXUR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXUR1R {
            bits: bool,
        }
        impl TXUR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDY0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDY0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDY1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDY1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXOR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXOR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXOR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXOR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDY0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDY0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDY1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDY1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXUR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXUR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXUR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXUR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Receive Ready 0 Interrupt Enable"]
            #[inline(always)]
            pub fn rxrdy0(&self) -> RXRDY0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RXRDY0R { bits }
            }
            #[doc = "Bit 1 - Receive Ready 1 Interrupt Enable"]
            #[inline(always)]
            pub fn rxrdy1(&self) -> RXRDY1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RXRDY1R { bits }
            }
            #[doc = "Bit 4 - Receive Overrun 0 Interrupt Enable"]
            #[inline(always)]
            pub fn rxor0(&self) -> RXOR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RXOR0R { bits }
            }
            #[doc = "Bit 5 - Receive Overrun 1 Interrupt Enable"]
            #[inline(always)]
            pub fn rxor1(&self) -> RXOR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RXOR1R { bits }
            }
            #[doc = "Bit 8 - Transmit Ready 0 Interrupt Enable"]
            #[inline(always)]
            pub fn txrdy0(&self) -> TXRDY0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TXRDY0R { bits }
            }
            #[doc = "Bit 9 - Transmit Ready 1 Interrupt Enable"]
            #[inline(always)]
            pub fn txrdy1(&self) -> TXRDY1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TXRDY1R { bits }
            }
            #[doc = "Bit 12 - Transmit Underrun 0 Interrupt Enable"]
            #[inline(always)]
            pub fn txur0(&self) -> TXUR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TXUR0R { bits }
            }
            #[doc = "Bit 13 - Transmit Underrun 1 Interrupt Enable"]
            #[inline(always)]
            pub fn txur1(&self) -> TXUR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TXUR1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Receive Ready 0 Interrupt Enable"]
            #[inline(always)]
            pub fn rxrdy0(&mut self) -> _RXRDY0W {
                _RXRDY0W { w: self }
            }
            #[doc = "Bit 1 - Receive Ready 1 Interrupt Enable"]
            #[inline(always)]
            pub fn rxrdy1(&mut self) -> _RXRDY1W {
                _RXRDY1W { w: self }
            }
            #[doc = "Bit 4 - Receive Overrun 0 Interrupt Enable"]
            #[inline(always)]
            pub fn rxor0(&mut self) -> _RXOR0W {
                _RXOR0W { w: self }
            }
            #[doc = "Bit 5 - Receive Overrun 1 Interrupt Enable"]
            #[inline(always)]
            pub fn rxor1(&mut self) -> _RXOR1W {
                _RXOR1W { w: self }
            }
            #[doc = "Bit 8 - Transmit Ready 0 Interrupt Enable"]
            #[inline(always)]
            pub fn txrdy0(&mut self) -> _TXRDY0W {
                _TXRDY0W { w: self }
            }
            #[doc = "Bit 9 - Transmit Ready 1 Interrupt Enable"]
            #[inline(always)]
            pub fn txrdy1(&mut self) -> _TXRDY1W {
                _TXRDY1W { w: self }
            }
            #[doc = "Bit 12 - Transmit Underrun 0 Interrupt Enable"]
            #[inline(always)]
            pub fn txur0(&mut self) -> _TXUR0W {
                _TXUR0W { w: self }
            }
            #[doc = "Bit 13 - Transmit Underrun 1 Interrupt Enable"]
            #[inline(always)]
            pub fn txur1(&mut self) -> _TXUR1W {
                _TXUR1W { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u16>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDY0R {
            bits: bool,
        }
        impl RXRDY0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDY1R {
            bits: bool,
        }
        impl RXRDY1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXOR0R {
            bits: bool,
        }
        impl RXOR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXOR1R {
            bits: bool,
        }
        impl RXOR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDY0R {
            bits: bool,
        }
        impl TXRDY0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDY1R {
            bits: bool,
        }
        impl TXRDY1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXUR0R {
            bits: bool,
        }
        impl TXUR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXUR1R {
            bits: bool,
        }
        impl TXUR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDY0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDY0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDY1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDY1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXOR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXOR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXOR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXOR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDY0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDY0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDY1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDY1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXUR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXUR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXUR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXUR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Receive Ready 0"]
            #[inline(always)]
            pub fn rxrdy0(&self) -> RXRDY0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RXRDY0R { bits }
            }
            #[doc = "Bit 1 - Receive Ready 1"]
            #[inline(always)]
            pub fn rxrdy1(&self) -> RXRDY1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RXRDY1R { bits }
            }
            #[doc = "Bit 4 - Receive Overrun 0"]
            #[inline(always)]
            pub fn rxor0(&self) -> RXOR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RXOR0R { bits }
            }
            #[doc = "Bit 5 - Receive Overrun 1"]
            #[inline(always)]
            pub fn rxor1(&self) -> RXOR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RXOR1R { bits }
            }
            #[doc = "Bit 8 - Transmit Ready 0"]
            #[inline(always)]
            pub fn txrdy0(&self) -> TXRDY0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TXRDY0R { bits }
            }
            #[doc = "Bit 9 - Transmit Ready 1"]
            #[inline(always)]
            pub fn txrdy1(&self) -> TXRDY1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TXRDY1R { bits }
            }
            #[doc = "Bit 12 - Transmit Underrun 0"]
            #[inline(always)]
            pub fn txur0(&self) -> TXUR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TXUR0R { bits }
            }
            #[doc = "Bit 13 - Transmit Underrun 1"]
            #[inline(always)]
            pub fn txur1(&self) -> TXUR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TXUR1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Receive Ready 0"]
            #[inline(always)]
            pub fn rxrdy0(&mut self) -> _RXRDY0W {
                _RXRDY0W { w: self }
            }
            #[doc = "Bit 1 - Receive Ready 1"]
            #[inline(always)]
            pub fn rxrdy1(&mut self) -> _RXRDY1W {
                _RXRDY1W { w: self }
            }
            #[doc = "Bit 4 - Receive Overrun 0"]
            #[inline(always)]
            pub fn rxor0(&mut self) -> _RXOR0W {
                _RXOR0W { w: self }
            }
            #[doc = "Bit 5 - Receive Overrun 1"]
            #[inline(always)]
            pub fn rxor1(&mut self) -> _RXOR1W {
                _RXOR1W { w: self }
            }
            #[doc = "Bit 8 - Transmit Ready 0"]
            #[inline(always)]
            pub fn txrdy0(&mut self) -> _TXRDY0W {
                _TXRDY0W { w: self }
            }
            #[doc = "Bit 9 - Transmit Ready 1"]
            #[inline(always)]
            pub fn txrdy1(&mut self) -> _TXRDY1W {
                _TXRDY1W { w: self }
            }
            #[doc = "Bit 12 - Transmit Underrun 0"]
            #[inline(always)]
            pub fn txur0(&mut self) -> _TXUR0W {
                _TXUR0W { w: self }
            }
            #[doc = "Bit 13 - Transmit Underrun 1"]
            #[inline(always)]
            pub fn txur1(&mut self) -> _TXUR1W {
                _TXUR1W { w: self }
            }
        }
    }
    #[doc = "Serializer n Control"]
    pub struct SERCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Serializer n Control"]
    pub mod serctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SERCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SERMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SERMODER {
            #[doc = "Receive"]
            RX,
            #[doc = "Transmit"]
            TX,
            #[doc = "Receive 1 PDM data on each clock edge"]
            PDM2,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SERMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SERMODER::RX => 0,
                    SERMODER::TX => 1,
                    SERMODER::PDM2 => 2,
                    SERMODER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SERMODER {
                match value {
                    0 => SERMODER::RX,
                    1 => SERMODER::TX,
                    2 => SERMODER::PDM2,
                    i => SERMODER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RX`"]
            #[inline(always)]
            pub fn is_rx(&self) -> bool {
                *self == SERMODER::RX
            }
            #[doc = "Checks if the value of the field is `TX`"]
            #[inline(always)]
            pub fn is_tx(&self) -> bool {
                *self == SERMODER::TX
            }
            #[doc = "Checks if the value of the field is `PDM2`"]
            #[inline(always)]
            pub fn is_pdm2(&self) -> bool {
                *self == SERMODER::PDM2
            }
        }
        #[doc = "Possible values of the field `TXDEFAULT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXDEFAULTR {
            #[doc = "Output Default Value is 0"]
            ZERO,
            #[doc = "Output Default Value is 1"]
            ONE,
            #[doc = "Output Default Value is high impedance"]
            HIZ,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl TXDEFAULTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    TXDEFAULTR::ZERO => 0,
                    TXDEFAULTR::ONE => 1,
                    TXDEFAULTR::HIZ => 3,
                    TXDEFAULTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> TXDEFAULTR {
                match value {
                    0 => TXDEFAULTR::ZERO,
                    1 => TXDEFAULTR::ONE,
                    3 => TXDEFAULTR::HIZ,
                    i => TXDEFAULTR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `ZERO`"]
            #[inline(always)]
            pub fn is_zero(&self) -> bool {
                *self == TXDEFAULTR::ZERO
            }
            #[doc = "Checks if the value of the field is `ONE`"]
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == TXDEFAULTR::ONE
            }
            #[doc = "Checks if the value of the field is `HIZ`"]
            #[inline(always)]
            pub fn is_hiz(&self) -> bool {
                *self == TXDEFAULTR::HIZ
            }
        }
        #[doc = "Possible values of the field `TXSAME`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXSAMER {
            #[doc = "Zero data transmitted in case of underrun"]
            ZERO,
            #[doc = "Last data transmitted in case of underrun"]
            SAME,
        }
        impl TXSAMER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    TXSAMER::ZERO => false,
                    TXSAMER::SAME => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> TXSAMER {
                match value {
                    false => TXSAMER::ZERO,
                    true => TXSAMER::SAME,
                }
            }
            #[doc = "Checks if the value of the field is `ZERO`"]
            #[inline(always)]
            pub fn is_zero(&self) -> bool {
                *self == TXSAMER::ZERO
            }
            #[doc = "Checks if the value of the field is `SAME`"]
            #[inline(always)]
            pub fn is_same(&self) -> bool {
                *self == TXSAMER::SAME
            }
        }
        #[doc = "Possible values of the field `CLKSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKSELR {
            #[doc = "Use Clock Unit 0"]
            CLK0,
            #[doc = "Use Clock Unit 1"]
            CLK1,
        }
        impl CLKSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CLKSELR::CLK0 => false,
                    CLKSELR::CLK1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CLKSELR {
                match value {
                    false => CLKSELR::CLK0,
                    true => CLKSELR::CLK1,
                }
            }
            #[doc = "Checks if the value of the field is `CLK0`"]
            #[inline(always)]
            pub fn is_clk0(&self) -> bool {
                *self == CLKSELR::CLK0
            }
            #[doc = "Checks if the value of the field is `CLK1`"]
            #[inline(always)]
            pub fn is_clk1(&self) -> bool {
                *self == CLKSELR::CLK1
            }
        }
        #[doc = "Possible values of the field `SLOTADJ`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLOTADJR {
            #[doc = "Data is right adjusted in slot"]
            RIGHT,
            #[doc = "Data is left adjusted in slot"]
            LEFT,
        }
        impl SLOTADJR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SLOTADJR::RIGHT => false,
                    SLOTADJR::LEFT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SLOTADJR {
                match value {
                    false => SLOTADJR::RIGHT,
                    true => SLOTADJR::LEFT,
                }
            }
            #[doc = "Checks if the value of the field is `RIGHT`"]
            #[inline(always)]
            pub fn is_right(&self) -> bool {
                *self == SLOTADJR::RIGHT
            }
            #[doc = "Checks if the value of the field is `LEFT`"]
            #[inline(always)]
            pub fn is_left(&self) -> bool {
                *self == SLOTADJR::LEFT
            }
        }
        #[doc = "Possible values of the field `DATASIZE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATASIZER {
            #[doc = "32 bits"]
            _32,
            #[doc = "24 bits"]
            _24,
            #[doc = "20 bits"]
            _20,
            #[doc = "18 bits"]
            _18,
            #[doc = "16 bits"]
            _16,
            #[doc = "16 bits compact stereo"]
            _16C,
            #[doc = "8 bits"]
            _8,
            #[doc = "8 bits compact stereo"]
            _8C,
        }
        impl DATASIZER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    DATASIZER::_32 => 0,
                    DATASIZER::_24 => 1,
                    DATASIZER::_20 => 2,
                    DATASIZER::_18 => 3,
                    DATASIZER::_16 => 4,
                    DATASIZER::_16C => 5,
                    DATASIZER::_8 => 6,
                    DATASIZER::_8C => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> DATASIZER {
                match value {
                    0 => DATASIZER::_32,
                    1 => DATASIZER::_24,
                    2 => DATASIZER::_20,
                    3 => DATASIZER::_18,
                    4 => DATASIZER::_16,
                    5 => DATASIZER::_16C,
                    6 => DATASIZER::_8,
                    7 => DATASIZER::_8C,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_32`"]
            #[inline(always)]
            pub fn is_32(&self) -> bool {
                *self == DATASIZER::_32
            }
            #[doc = "Checks if the value of the field is `_24`"]
            #[inline(always)]
            pub fn is_24(&self) -> bool {
                *self == DATASIZER::_24
            }
            #[doc = "Checks if the value of the field is `_20`"]
            #[inline(always)]
            pub fn is_20(&self) -> bool {
                *self == DATASIZER::_20
            }
            #[doc = "Checks if the value of the field is `_18`"]
            #[inline(always)]
            pub fn is_18(&self) -> bool {
                *self == DATASIZER::_18
            }
            #[doc = "Checks if the value of the field is `_16`"]
            #[inline(always)]
            pub fn is_16(&self) -> bool {
                *self == DATASIZER::_16
            }
            #[doc = "Checks if the value of the field is `_16C`"]
            #[inline(always)]
            pub fn is_16c(&self) -> bool {
                *self == DATASIZER::_16C
            }
            #[doc = "Checks if the value of the field is `_8`"]
            #[inline(always)]
            pub fn is_8(&self) -> bool {
                *self == DATASIZER::_8
            }
            #[doc = "Checks if the value of the field is `_8C`"]
            #[inline(always)]
            pub fn is_8c(&self) -> bool {
                *self == DATASIZER::_8C
            }
        }
        #[doc = "Possible values of the field `WORDADJ`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WORDADJR {
            #[doc = "Data is right adjusted in word"]
            RIGHT,
            #[doc = "Data is left adjusted in word"]
            LEFT,
        }
        impl WORDADJR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WORDADJR::RIGHT => false,
                    WORDADJR::LEFT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WORDADJR {
                match value {
                    false => WORDADJR::RIGHT,
                    true => WORDADJR::LEFT,
                }
            }
            #[doc = "Checks if the value of the field is `RIGHT`"]
            #[inline(always)]
            pub fn is_right(&self) -> bool {
                *self == WORDADJR::RIGHT
            }
            #[doc = "Checks if the value of the field is `LEFT`"]
            #[inline(always)]
            pub fn is_left(&self) -> bool {
                *self == WORDADJR::LEFT
            }
        }
        #[doc = "Possible values of the field `EXTEND`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTENDR {
            #[doc = "Extend with zeroes"]
            ZERO,
            #[doc = "Extend with ones"]
            ONE,
            #[doc = "Extend with Most Significant Bit"]
            MSBIT,
            #[doc = "Extend with Least Significant Bit"]
            LSBIT,
        }
        impl EXTENDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    EXTENDR::ZERO => 0,
                    EXTENDR::ONE => 1,
                    EXTENDR::MSBIT => 2,
                    EXTENDR::LSBIT => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> EXTENDR {
                match value {
                    0 => EXTENDR::ZERO,
                    1 => EXTENDR::ONE,
                    2 => EXTENDR::MSBIT,
                    3 => EXTENDR::LSBIT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ZERO`"]
            #[inline(always)]
            pub fn is_zero(&self) -> bool {
                *self == EXTENDR::ZERO
            }
            #[doc = "Checks if the value of the field is `ONE`"]
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == EXTENDR::ONE
            }
            #[doc = "Checks if the value of the field is `MSBIT`"]
            #[inline(always)]
            pub fn is_msbit(&self) -> bool {
                *self == EXTENDR::MSBIT
            }
            #[doc = "Checks if the value of the field is `LSBIT`"]
            #[inline(always)]
            pub fn is_lsbit(&self) -> bool {
                *self == EXTENDR::LSBIT
            }
        }
        #[doc = "Possible values of the field `BITREV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BITREVR {
            #[doc = "Transfer Data Most Significant Bit (MSB) first (default for I2S protocol)"]
            MSBIT,
            #[doc = "Transfer Data Least Significant Bit (LSB) first"]
            LSBIT,
        }
        impl BITREVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    BITREVR::MSBIT => false,
                    BITREVR::LSBIT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> BITREVR {
                match value {
                    false => BITREVR::MSBIT,
                    true => BITREVR::LSBIT,
                }
            }
            #[doc = "Checks if the value of the field is `MSBIT`"]
            #[inline(always)]
            pub fn is_msbit(&self) -> bool {
                *self == BITREVR::MSBIT
            }
            #[doc = "Checks if the value of the field is `LSBIT`"]
            #[inline(always)]
            pub fn is_lsbit(&self) -> bool {
                *self == BITREVR::LSBIT
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLOTDIS0R {
            bits: bool,
        }
        impl SLOTDIS0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLOTDIS1R {
            bits: bool,
        }
        impl SLOTDIS1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLOTDIS2R {
            bits: bool,
        }
        impl SLOTDIS2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLOTDIS3R {
            bits: bool,
        }
        impl SLOTDIS3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLOTDIS4R {
            bits: bool,
        }
        impl SLOTDIS4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLOTDIS5R {
            bits: bool,
        }
        impl SLOTDIS5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLOTDIS6R {
            bits: bool,
        }
        impl SLOTDIS6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLOTDIS7R {
            bits: bool,
        }
        impl SLOTDIS7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `MONO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONOR {
            #[doc = "Normal mode"]
            STEREO,
            #[doc = "Left channel data is duplicated to right channel"]
            MONO,
        }
        impl MONOR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MONOR::STEREO => false,
                    MONOR::MONO => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MONOR {
                match value {
                    false => MONOR::STEREO,
                    true => MONOR::MONO,
                }
            }
            #[doc = "Checks if the value of the field is `STEREO`"]
            #[inline(always)]
            pub fn is_stereo(&self) -> bool {
                *self == MONOR::STEREO
            }
            #[doc = "Checks if the value of the field is `MONO`"]
            #[inline(always)]
            pub fn is_mono(&self) -> bool {
                *self == MONOR::MONO
            }
        }
        #[doc = "Possible values of the field `DMA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAR {
            #[doc = "Single DMA channel"]
            SINGLE,
            #[doc = "One DMA channel per data channel"]
            MULTIPLE,
        }
        impl DMAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    DMAR::SINGLE => false,
                    DMAR::MULTIPLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> DMAR {
                match value {
                    false => DMAR::SINGLE,
                    true => DMAR::MULTIPLE,
                }
            }
            #[doc = "Checks if the value of the field is `SINGLE`"]
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                *self == DMAR::SINGLE
            }
            #[doc = "Checks if the value of the field is `MULTIPLE`"]
            #[inline(always)]
            pub fn is_multiple(&self) -> bool {
                *self == DMAR::MULTIPLE
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXLOOPR {
            bits: bool,
        }
        impl RXLOOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `SERMODE`"]
        pub enum SERMODEW {
            #[doc = "Receive"]
            RX,
            #[doc = "Transmit"]
            TX,
            #[doc = "Receive 1 PDM data on each clock edge"]
            PDM2,
        }
        impl SERMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SERMODEW::RX => 0,
                    SERMODEW::TX => 1,
                    SERMODEW::PDM2 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SERMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SERMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SERMODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Receive"]
            #[inline(always)]
            pub fn rx(self) -> &'a mut W {
                self.variant(SERMODEW::RX)
            }
            #[doc = "Transmit"]
            #[inline(always)]
            pub fn tx(self) -> &'a mut W {
                self.variant(SERMODEW::TX)
            }
            #[doc = "Receive 1 PDM data on each clock edge"]
            #[inline(always)]
            pub fn pdm2(self) -> &'a mut W {
                self.variant(SERMODEW::PDM2)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXDEFAULT`"]
        pub enum TXDEFAULTW {
            #[doc = "Output Default Value is 0"]
            ZERO,
            #[doc = "Output Default Value is 1"]
            ONE,
            #[doc = "Output Default Value is high impedance"]
            HIZ,
        }
        impl TXDEFAULTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TXDEFAULTW::ZERO => 0,
                    TXDEFAULTW::ONE => 1,
                    TXDEFAULTW::HIZ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDEFAULTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDEFAULTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXDEFAULTW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Output Default Value is 0"]
            #[inline(always)]
            pub fn zero(self) -> &'a mut W {
                self.variant(TXDEFAULTW::ZERO)
            }
            #[doc = "Output Default Value is 1"]
            #[inline(always)]
            pub fn one(self) -> &'a mut W {
                self.variant(TXDEFAULTW::ONE)
            }
            #[doc = "Output Default Value is high impedance"]
            #[inline(always)]
            pub fn hiz(self) -> &'a mut W {
                self.variant(TXDEFAULTW::HIZ)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXSAME`"]
        pub enum TXSAMEW {
            #[doc = "Zero data transmitted in case of underrun"]
            ZERO,
            #[doc = "Last data transmitted in case of underrun"]
            SAME,
        }
        impl TXSAMEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXSAMEW::ZERO => false,
                    TXSAMEW::SAME => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXSAMEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXSAMEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXSAMEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Zero data transmitted in case of underrun"]
            #[inline(always)]
            pub fn zero(self) -> &'a mut W {
                self.variant(TXSAMEW::ZERO)
            }
            #[doc = "Last data transmitted in case of underrun"]
            #[inline(always)]
            pub fn same(self) -> &'a mut W {
                self.variant(TXSAMEW::SAME)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLKSEL`"]
        pub enum CLKSELW {
            #[doc = "Use Clock Unit 0"]
            CLK0,
            #[doc = "Use Clock Unit 1"]
            CLK1,
        }
        impl CLKSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    CLKSELW::CLK0 => false,
                    CLKSELW::CLK1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLKSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Use Clock Unit 0"]
            #[inline(always)]
            pub fn clk0(self) -> &'a mut W {
                self.variant(CLKSELW::CLK0)
            }
            #[doc = "Use Clock Unit 1"]
            #[inline(always)]
            pub fn clk1(self) -> &'a mut W {
                self.variant(CLKSELW::CLK1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLOTADJ`"]
        pub enum SLOTADJW {
            #[doc = "Data is right adjusted in slot"]
            RIGHT,
            #[doc = "Data is left adjusted in slot"]
            LEFT,
        }
        impl SLOTADJW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLOTADJW::RIGHT => false,
                    SLOTADJW::LEFT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLOTADJW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLOTADJW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLOTADJW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Data is right adjusted in slot"]
            #[inline(always)]
            pub fn right(self) -> &'a mut W {
                self.variant(SLOTADJW::RIGHT)
            }
            #[doc = "Data is left adjusted in slot"]
            #[inline(always)]
            pub fn left(self) -> &'a mut W {
                self.variant(SLOTADJW::LEFT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DATASIZE`"]
        pub enum DATASIZEW {
            #[doc = "32 bits"]
            _32,
            #[doc = "24 bits"]
            _24,
            #[doc = "20 bits"]
            _20,
            #[doc = "18 bits"]
            _18,
            #[doc = "16 bits"]
            _16,
            #[doc = "16 bits compact stereo"]
            _16C,
            #[doc = "8 bits"]
            _8,
            #[doc = "8 bits compact stereo"]
            _8C,
        }
        impl DATASIZEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DATASIZEW::_32 => 0,
                    DATASIZEW::_24 => 1,
                    DATASIZEW::_20 => 2,
                    DATASIZEW::_18 => 3,
                    DATASIZEW::_16 => 4,
                    DATASIZEW::_16C => 5,
                    DATASIZEW::_8 => 6,
                    DATASIZEW::_8C => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATASIZEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATASIZEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DATASIZEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "32 bits"]
            #[inline(always)]
            pub fn _32(self) -> &'a mut W {
                self.variant(DATASIZEW::_32)
            }
            #[doc = "24 bits"]
            #[inline(always)]
            pub fn _24(self) -> &'a mut W {
                self.variant(DATASIZEW::_24)
            }
            #[doc = "20 bits"]
            #[inline(always)]
            pub fn _20(self) -> &'a mut W {
                self.variant(DATASIZEW::_20)
            }
            #[doc = "18 bits"]
            #[inline(always)]
            pub fn _18(self) -> &'a mut W {
                self.variant(DATASIZEW::_18)
            }
            #[doc = "16 bits"]
            #[inline(always)]
            pub fn _16(self) -> &'a mut W {
                self.variant(DATASIZEW::_16)
            }
            #[doc = "16 bits compact stereo"]
            #[inline(always)]
            pub fn _16c(self) -> &'a mut W {
                self.variant(DATASIZEW::_16C)
            }
            #[doc = "8 bits"]
            #[inline(always)]
            pub fn _8(self) -> &'a mut W {
                self.variant(DATASIZEW::_8)
            }
            #[doc = "8 bits compact stereo"]
            #[inline(always)]
            pub fn _8c(self) -> &'a mut W {
                self.variant(DATASIZEW::_8C)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WORDADJ`"]
        pub enum WORDADJW {
            #[doc = "Data is right adjusted in word"]
            RIGHT,
            #[doc = "Data is left adjusted in word"]
            LEFT,
        }
        impl WORDADJW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WORDADJW::RIGHT => false,
                    WORDADJW::LEFT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WORDADJW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WORDADJW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WORDADJW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Data is right adjusted in word"]
            #[inline(always)]
            pub fn right(self) -> &'a mut W {
                self.variant(WORDADJW::RIGHT)
            }
            #[doc = "Data is left adjusted in word"]
            #[inline(always)]
            pub fn left(self) -> &'a mut W {
                self.variant(WORDADJW::LEFT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EXTEND`"]
        pub enum EXTENDW {
            #[doc = "Extend with zeroes"]
            ZERO,
            #[doc = "Extend with ones"]
            ONE,
            #[doc = "Extend with Most Significant Bit"]
            MSBIT,
            #[doc = "Extend with Least Significant Bit"]
            LSBIT,
        }
        impl EXTENDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EXTENDW::ZERO => 0,
                    EXTENDW::ONE => 1,
                    EXTENDW::MSBIT => 2,
                    EXTENDW::LSBIT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTENDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTENDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTENDW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Extend with zeroes"]
            #[inline(always)]
            pub fn zero(self) -> &'a mut W {
                self.variant(EXTENDW::ZERO)
            }
            #[doc = "Extend with ones"]
            #[inline(always)]
            pub fn one(self) -> &'a mut W {
                self.variant(EXTENDW::ONE)
            }
            #[doc = "Extend with Most Significant Bit"]
            #[inline(always)]
            pub fn msbit(self) -> &'a mut W {
                self.variant(EXTENDW::MSBIT)
            }
            #[doc = "Extend with Least Significant Bit"]
            #[inline(always)]
            pub fn lsbit(self) -> &'a mut W {
                self.variant(EXTENDW::LSBIT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BITREV`"]
        pub enum BITREVW {
            #[doc = "Transfer Data Most Significant Bit (MSB) first (default for I2S protocol)"]
            MSBIT,
            #[doc = "Transfer Data Least Significant Bit (LSB) first"]
            LSBIT,
        }
        impl BITREVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    BITREVW::MSBIT => false,
                    BITREVW::LSBIT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BITREVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BITREVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BITREVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Transfer Data Most Significant Bit (MSB) first (default for I2S protocol)"]
            #[inline(always)]
            pub fn msbit(self) -> &'a mut W {
                self.variant(BITREVW::MSBIT)
            }
            #[doc = "Transfer Data Least Significant Bit (LSB) first"]
            #[inline(always)]
            pub fn lsbit(self) -> &'a mut W {
                self.variant(BITREVW::LSBIT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLOTDIS0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLOTDIS0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLOTDIS1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLOTDIS1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLOTDIS2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLOTDIS2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLOTDIS3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLOTDIS3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLOTDIS4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLOTDIS4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLOTDIS5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLOTDIS5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLOTDIS6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLOTDIS6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLOTDIS7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLOTDIS7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONO`"]
        pub enum MONOW {
            #[doc = "Normal mode"]
            STEREO,
            #[doc = "Left channel data is duplicated to right channel"]
            MONO,
        }
        impl MONOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONOW::STEREO => false,
                    MONOW::MONO => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MONOW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Normal mode"]
            #[inline(always)]
            pub fn stereo(self) -> &'a mut W {
                self.variant(MONOW::STEREO)
            }
            #[doc = "Left channel data is duplicated to right channel"]
            #[inline(always)]
            pub fn mono(self) -> &'a mut W {
                self.variant(MONOW::MONO)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DMA`"]
        pub enum DMAW {
            #[doc = "Single DMA channel"]
            SINGLE,
            #[doc = "One DMA channel per data channel"]
            MULTIPLE,
        }
        impl DMAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    DMAW::SINGLE => false,
                    DMAW::MULTIPLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Single DMA channel"]
            #[inline(always)]
            pub fn single(self) -> &'a mut W {
                self.variant(DMAW::SINGLE)
            }
            #[doc = "One DMA channel per data channel"]
            #[inline(always)]
            pub fn multiple(self) -> &'a mut W {
                self.variant(DMAW::MULTIPLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXLOOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXLOOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Serializer Mode"]
            #[inline(always)]
            pub fn sermode(&self) -> SERMODER {
                SERMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:3 - Line Default Line when Slot Disabled"]
            #[inline(always)]
            pub fn txdefault(&self) -> TXDEFAULTR {
                TXDEFAULTR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 4 - Transmit Data when Underrun"]
            #[inline(always)]
            pub fn txsame(&self) -> TXSAMER {
                TXSAMER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Clock Unit Selection"]
            #[inline(always)]
            pub fn clksel(&self) -> CLKSELR {
                CLKSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Data Slot Formatting Adjust"]
            #[inline(always)]
            pub fn slotadj(&self) -> SLOTADJR {
                SLOTADJR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 8:10 - Data Word Size"]
            #[inline(always)]
            pub fn datasize(&self) -> DATASIZER {
                DATASIZER::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 12 - Data Word Formatting Adjust"]
            #[inline(always)]
            pub fn wordadj(&self) -> WORDADJR {
                WORDADJR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 13:14 - Data Formatting Bit Extension"]
            #[inline(always)]
            pub fn extend(&self) -> EXTENDR {
                EXTENDR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 15 - Data Formatting Bit Reverse"]
            #[inline(always)]
            pub fn bitrev(&self) -> BITREVR {
                BITREVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Slot 0 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis0(&self) -> SLOTDIS0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLOTDIS0R { bits }
            }
            #[doc = "Bit 17 - Slot 1 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis1(&self) -> SLOTDIS1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLOTDIS1R { bits }
            }
            #[doc = "Bit 18 - Slot 2 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis2(&self) -> SLOTDIS2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLOTDIS2R { bits }
            }
            #[doc = "Bit 19 - Slot 3 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis3(&self) -> SLOTDIS3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLOTDIS3R { bits }
            }
            #[doc = "Bit 20 - Slot 4 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis4(&self) -> SLOTDIS4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLOTDIS4R { bits }
            }
            #[doc = "Bit 21 - Slot 5 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis5(&self) -> SLOTDIS5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLOTDIS5R { bits }
            }
            #[doc = "Bit 22 - Slot 6 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis6(&self) -> SLOTDIS6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLOTDIS6R { bits }
            }
            #[doc = "Bit 23 - Slot 7 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis7(&self) -> SLOTDIS7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLOTDIS7R { bits }
            }
            #[doc = "Bit 24 - Mono Mode"]
            #[inline(always)]
            pub fn mono(&self) -> MONOR {
                MONOR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Single or Multiple DMA Channels"]
            #[inline(always)]
            pub fn dma(&self) -> DMAR {
                DMAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Loop-back Test Mode"]
            #[inline(always)]
            pub fn rxloop(&self) -> RXLOOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXLOOPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Serializer Mode"]
            #[inline(always)]
            pub fn sermode(&mut self) -> _SERMODEW {
                _SERMODEW { w: self }
            }
            #[doc = "Bits 2:3 - Line Default Line when Slot Disabled"]
            #[inline(always)]
            pub fn txdefault(&mut self) -> _TXDEFAULTW {
                _TXDEFAULTW { w: self }
            }
            #[doc = "Bit 4 - Transmit Data when Underrun"]
            #[inline(always)]
            pub fn txsame(&mut self) -> _TXSAMEW {
                _TXSAMEW { w: self }
            }
            #[doc = "Bit 5 - Clock Unit Selection"]
            #[inline(always)]
            pub fn clksel(&mut self) -> _CLKSELW {
                _CLKSELW { w: self }
            }
            #[doc = "Bit 7 - Data Slot Formatting Adjust"]
            #[inline(always)]
            pub fn slotadj(&mut self) -> _SLOTADJW {
                _SLOTADJW { w: self }
            }
            #[doc = "Bits 8:10 - Data Word Size"]
            #[inline(always)]
            pub fn datasize(&mut self) -> _DATASIZEW {
                _DATASIZEW { w: self }
            }
            #[doc = "Bit 12 - Data Word Formatting Adjust"]
            #[inline(always)]
            pub fn wordadj(&mut self) -> _WORDADJW {
                _WORDADJW { w: self }
            }
            #[doc = "Bits 13:14 - Data Formatting Bit Extension"]
            #[inline(always)]
            pub fn extend(&mut self) -> _EXTENDW {
                _EXTENDW { w: self }
            }
            #[doc = "Bit 15 - Data Formatting Bit Reverse"]
            #[inline(always)]
            pub fn bitrev(&mut self) -> _BITREVW {
                _BITREVW { w: self }
            }
            #[doc = "Bit 16 - Slot 0 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis0(&mut self) -> _SLOTDIS0W {
                _SLOTDIS0W { w: self }
            }
            #[doc = "Bit 17 - Slot 1 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis1(&mut self) -> _SLOTDIS1W {
                _SLOTDIS1W { w: self }
            }
            #[doc = "Bit 18 - Slot 2 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis2(&mut self) -> _SLOTDIS2W {
                _SLOTDIS2W { w: self }
            }
            #[doc = "Bit 19 - Slot 3 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis3(&mut self) -> _SLOTDIS3W {
                _SLOTDIS3W { w: self }
            }
            #[doc = "Bit 20 - Slot 4 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis4(&mut self) -> _SLOTDIS4W {
                _SLOTDIS4W { w: self }
            }
            #[doc = "Bit 21 - Slot 5 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis5(&mut self) -> _SLOTDIS5W {
                _SLOTDIS5W { w: self }
            }
            #[doc = "Bit 22 - Slot 6 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis6(&mut self) -> _SLOTDIS6W {
                _SLOTDIS6W { w: self }
            }
            #[doc = "Bit 23 - Slot 7 Disabled for this Serializer"]
            #[inline(always)]
            pub fn slotdis7(&mut self) -> _SLOTDIS7W {
                _SLOTDIS7W { w: self }
            }
            #[doc = "Bit 24 - Mono Mode"]
            #[inline(always)]
            pub fn mono(&mut self) -> _MONOW {
                _MONOW { w: self }
            }
            #[doc = "Bit 25 - Single or Multiple DMA Channels"]
            #[inline(always)]
            pub fn dma(&mut self) -> _DMAW {
                _DMAW { w: self }
            }
            #[doc = "Bit 26 - Loop-back Test Mode"]
            #[inline(always)]
            pub fn rxloop(&mut self) -> _RXLOOPW {
                _RXLOOPW { w: self }
            }
        }
    }
    #[doc = "Synchronization Status"]
    pub struct SYNCBUSY {
        register: VolatileCell<u16>,
    }
    #[doc = "Synchronization Status"]
    pub mod syncbusy {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        impl super::SYNCBUSY {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKEN0R {
            bits: bool,
        }
        impl CKEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKEN1R {
            bits: bool,
        }
        impl CKEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SEREN0R {
            bits: bool,
        }
        impl SEREN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SEREN1R {
            bits: bool,
        }
        impl SEREN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA0R {
            bits: bool,
        }
        impl DATA0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA1R {
            bits: bool,
        }
        impl DATA1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Software Reset Synchronization Status"]
            #[inline(always)]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                SWRSTR { bits }
            }
            #[doc = "Bit 1 - Enable Synchronization Status"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Clock Unit 0 Enable Synchronization Status"]
            #[inline(always)]
            pub fn cken0(&self) -> CKEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                CKEN0R { bits }
            }
            #[doc = "Bit 3 - Clock Unit 1 Enable Synchronization Status"]
            #[inline(always)]
            pub fn cken1(&self) -> CKEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                CKEN1R { bits }
            }
            #[doc = "Bit 4 - Serializer 0 Enable Synchronization Status"]
            #[inline(always)]
            pub fn seren0(&self) -> SEREN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                SEREN0R { bits }
            }
            #[doc = "Bit 5 - Serializer 1 Enable Synchronization Status"]
            #[inline(always)]
            pub fn seren1(&self) -> SEREN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                SEREN1R { bits }
            }
            #[doc = "Bit 8 - Data 0 Synchronization Status"]
            #[inline(always)]
            pub fn data0(&self) -> DATA0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                DATA0R { bits }
            }
            #[doc = "Bit 9 - Data 1 Synchronization Status"]
            #[inline(always)]
            pub fn data1(&self) -> DATA1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                DATA1R { bits }
            }
        }
    }
}
#[doc = "Inter-IC Sound Interface"]
pub struct I2S {
    register_block: i2s::RegisterBlock,
}
impl Deref for I2S {
    type Target = i2s::RegisterBlock;
    fn deref(&self) -> &i2s::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Cortex-M0+ Micro-Trace Buffer"]
pub const MTB: Peripheral<MTB> = unsafe { Peripheral::new(1090543616) };
#[doc = "Cortex-M0+ Micro-Trace Buffer"]
pub mod mtb {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - MTB Position"]
        pub position: POSITION,
        #[doc = "0x04 - MTB Master"]
        pub master: MASTER,
        #[doc = "0x08 - MTB Flow"]
        pub flow: FLOW,
        #[doc = "0x0c - MTB Base"]
        pub base: BASE,
        _reserved0: [u8; 3824usize],
        #[doc = "0xf00 - MTB Integration Mode Control"]
        pub itctrl: ITCTRL,
        _reserved1: [u8; 156usize],
        #[doc = "0xfa0 - MTB Claim Set"]
        pub claimset: CLAIMSET,
        #[doc = "0xfa4 - MTB Claim Clear"]
        pub claimclr: CLAIMCLR,
        _reserved2: [u8; 8usize],
        #[doc = "0xfb0 - MTB Lock Access"]
        pub lockaccess: LOCKACCESS,
        #[doc = "0xfb4 - MTB Lock Status"]
        pub lockstatus: LOCKSTATUS,
        #[doc = "0xfb8 - MTB Authentication Status"]
        pub authstatus: AUTHSTATUS,
        #[doc = "0xfbc - MTB Device Architecture"]
        pub devarch: DEVARCH,
        _reserved3: [u8; 8usize],
        #[doc = "0xfc8 - MTB Device Configuration"]
        pub devid: DEVID,
        #[doc = "0xfcc - MTB Device Type"]
        pub devtype: DEVTYPE,
        #[doc = "0xfd0 - CoreSight"]
        pub pid4: PID4,
        #[doc = "0xfd4 - CoreSight"]
        pub pid5: PID5,
        #[doc = "0xfd8 - CoreSight"]
        pub pid6: PID6,
        #[doc = "0xfdc - CoreSight"]
        pub pid7: PID7,
        #[doc = "0xfe0 - CoreSight"]
        pub pid0: PID0,
        #[doc = "0xfe4 - CoreSight"]
        pub pid1: PID1,
        #[doc = "0xfe8 - CoreSight"]
        pub pid2: PID2,
        #[doc = "0xfec - CoreSight"]
        pub pid3: PID3,
        #[doc = "0xff0 - CoreSight"]
        pub cid0: CID0,
        #[doc = "0xff4 - CoreSight"]
        pub cid1: CID1,
        #[doc = "0xff8 - CoreSight"]
        pub cid2: CID2,
        #[doc = "0xffc - CoreSight"]
        pub cid3: CID3,
    }
    #[doc = "MTB Authentication Status"]
    pub struct AUTHSTATUS {
        register: VolatileCell<u32>,
    }
    #[doc = "MTB Authentication Status"]
    pub mod authstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::AUTHSTATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "MTB Base"]
    pub struct BASE {
        register: VolatileCell<u32>,
    }
    #[doc = "MTB Base"]
    pub mod base {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::BASE {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "CoreSight"]
    pub struct CID0 {
        register: VolatileCell<u32>,
    }
    #[doc = "CoreSight"]
    pub mod cid0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CID0 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "CoreSight"]
    pub struct CID1 {
        register: VolatileCell<u32>,
    }
    #[doc = "CoreSight"]
    pub mod cid1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CID1 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "CoreSight"]
    pub struct CID2 {
        register: VolatileCell<u32>,
    }
    #[doc = "CoreSight"]
    pub mod cid2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CID2 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "CoreSight"]
    pub struct CID3 {
        register: VolatileCell<u32>,
    }
    #[doc = "CoreSight"]
    pub mod cid3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CID3 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "MTB Claim Clear"]
    pub struct CLAIMCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "MTB Claim Clear"]
    pub mod claimclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLAIMCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "MTB Claim Set"]
    pub struct CLAIMSET {
        register: VolatileCell<u32>,
    }
    #[doc = "MTB Claim Set"]
    pub mod claimset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLAIMSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "MTB Device Architecture"]
    pub struct DEVARCH {
        register: VolatileCell<u32>,
    }
    #[doc = "MTB Device Architecture"]
    pub mod devarch {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DEVARCH {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "MTB Device Configuration"]
    pub struct DEVID {
        register: VolatileCell<u32>,
    }
    #[doc = "MTB Device Configuration"]
    pub mod devid {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DEVID {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "MTB Device Type"]
    pub struct DEVTYPE {
        register: VolatileCell<u32>,
    }
    #[doc = "MTB Device Type"]
    pub mod devtype {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DEVTYPE {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "MTB Flow"]
    pub struct FLOW {
        register: VolatileCell<u32>,
    }
    #[doc = "MTB Flow"]
    pub mod flow {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FLOW {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct AUTOSTOPR {
            bits: bool,
        }
        impl AUTOSTOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AUTOHALTR {
            bits: bool,
        }
        impl AUTOHALTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WATERMARKR {
            bits: u32,
        }
        impl WATERMARKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _AUTOSTOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AUTOSTOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AUTOHALTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AUTOHALTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WATERMARKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WATERMARKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 536870911;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Auto Stop Tracing"]
            #[inline(always)]
            pub fn autostop(&self) -> AUTOSTOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AUTOSTOPR { bits }
            }
            #[doc = "Bit 1 - Auto Halt Request"]
            #[inline(always)]
            pub fn autohalt(&self) -> AUTOHALTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AUTOHALTR { bits }
            }
            #[doc = "Bits 3:31 - Watermark value"]
            #[inline(always)]
            pub fn watermark(&self) -> WATERMARKR {
                let bits = {
                    const MASK: u32 = 536870911;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                WATERMARKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Auto Stop Tracing"]
            #[inline(always)]
            pub fn autostop(&mut self) -> _AUTOSTOPW {
                _AUTOSTOPW { w: self }
            }
            #[doc = "Bit 1 - Auto Halt Request"]
            #[inline(always)]
            pub fn autohalt(&mut self) -> _AUTOHALTW {
                _AUTOHALTW { w: self }
            }
            #[doc = "Bits 3:31 - Watermark value"]
            #[inline(always)]
            pub fn watermark(&mut self) -> _WATERMARKW {
                _WATERMARKW { w: self }
            }
        }
    }
    #[doc = "MTB Integration Mode Control"]
    pub struct ITCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "MTB Integration Mode Control"]
    pub mod itctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ITCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "MTB Lock Access"]
    pub struct LOCKACCESS {
        register: VolatileCell<u32>,
    }
    #[doc = "MTB Lock Access"]
    pub mod lockaccess {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LOCKACCESS {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "MTB Lock Status"]
    pub struct LOCKSTATUS {
        register: VolatileCell<u32>,
    }
    #[doc = "MTB Lock Status"]
    pub mod lockstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::LOCKSTATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "MTB Master"]
    pub struct MASTER {
        register: VolatileCell<u32>,
    }
    #[doc = "MTB Master"]
    pub mod master {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MASTER {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASKR {
            bits: u8,
        }
        impl MASKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TSTARTENR {
            bits: bool,
        }
        impl TSTARTENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TSTOPENR {
            bits: bool,
        }
        impl TSTOPENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SFRWPRIVR {
            bits: bool,
        }
        impl SFRWPRIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAMPRIVR {
            bits: bool,
        }
        impl RAMPRIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HALTREQR {
            bits: bool,
        }
        impl HALTREQR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENR {
            bits: bool,
        }
        impl ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TSTARTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TSTARTENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TSTOPENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TSTOPENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SFRWPRIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SFRWPRIVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RAMPRIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RAMPRIVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HALTREQW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HALTREQW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - Maximum Value of the Trace Buffer in SRAM"]
            #[inline(always)]
            pub fn mask(&self) -> MASKR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MASKR { bits }
            }
            #[doc = "Bit 5 - Trace Start Input Enable"]
            #[inline(always)]
            pub fn tstarten(&self) -> TSTARTENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TSTARTENR { bits }
            }
            #[doc = "Bit 6 - Trace Stop Input Enable"]
            #[inline(always)]
            pub fn tstopen(&self) -> TSTOPENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TSTOPENR { bits }
            }
            #[doc = "Bit 7 - Special Function Register Write Privilege"]
            #[inline(always)]
            pub fn sfrwpriv(&self) -> SFRWPRIVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SFRWPRIVR { bits }
            }
            #[doc = "Bit 8 - SRAM Privilege"]
            #[inline(always)]
            pub fn rampriv(&self) -> RAMPRIVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RAMPRIVR { bits }
            }
            #[doc = "Bit 9 - Halt Request"]
            #[inline(always)]
            pub fn haltreq(&self) -> HALTREQR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HALTREQR { bits }
            }
            #[doc = "Bit 31 - Main Trace Enable"]
            #[inline(always)]
            pub fn en(&self) -> ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Maximum Value of the Trace Buffer in SRAM"]
            #[inline(always)]
            pub fn mask(&mut self) -> _MASKW {
                _MASKW { w: self }
            }
            #[doc = "Bit 5 - Trace Start Input Enable"]
            #[inline(always)]
            pub fn tstarten(&mut self) -> _TSTARTENW {
                _TSTARTENW { w: self }
            }
            #[doc = "Bit 6 - Trace Stop Input Enable"]
            #[inline(always)]
            pub fn tstopen(&mut self) -> _TSTOPENW {
                _TSTOPENW { w: self }
            }
            #[doc = "Bit 7 - Special Function Register Write Privilege"]
            #[inline(always)]
            pub fn sfrwpriv(&mut self) -> _SFRWPRIVW {
                _SFRWPRIVW { w: self }
            }
            #[doc = "Bit 8 - SRAM Privilege"]
            #[inline(always)]
            pub fn rampriv(&mut self) -> _RAMPRIVW {
                _RAMPRIVW { w: self }
            }
            #[doc = "Bit 9 - Halt Request"]
            #[inline(always)]
            pub fn haltreq(&mut self) -> _HALTREQW {
                _HALTREQW { w: self }
            }
            #[doc = "Bit 31 - Main Trace Enable"]
            #[inline(always)]
            pub fn en(&mut self) -> _ENW {
                _ENW { w: self }
            }
        }
    }
    #[doc = "CoreSight"]
    pub struct PID0 {
        register: VolatileCell<u32>,
    }
    #[doc = "CoreSight"]
    pub mod pid0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID0 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "CoreSight"]
    pub struct PID1 {
        register: VolatileCell<u32>,
    }
    #[doc = "CoreSight"]
    pub mod pid1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID1 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "CoreSight"]
    pub struct PID2 {
        register: VolatileCell<u32>,
    }
    #[doc = "CoreSight"]
    pub mod pid2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID2 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "CoreSight"]
    pub struct PID3 {
        register: VolatileCell<u32>,
    }
    #[doc = "CoreSight"]
    pub mod pid3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID3 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "CoreSight"]
    pub struct PID4 {
        register: VolatileCell<u32>,
    }
    #[doc = "CoreSight"]
    pub mod pid4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID4 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "CoreSight"]
    pub struct PID5 {
        register: VolatileCell<u32>,
    }
    #[doc = "CoreSight"]
    pub mod pid5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID5 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "CoreSight"]
    pub struct PID6 {
        register: VolatileCell<u32>,
    }
    #[doc = "CoreSight"]
    pub mod pid6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID6 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "CoreSight"]
    pub struct PID7 {
        register: VolatileCell<u32>,
    }
    #[doc = "CoreSight"]
    pub mod pid7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID7 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "MTB Position"]
    pub struct POSITION {
        register: VolatileCell<u32>,
    }
    #[doc = "MTB Position"]
    pub mod position {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POSITION {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRAPR {
            bits: bool,
        }
        impl WRAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POINTERR {
            bits: u32,
        }
        impl POINTERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POINTERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POINTERW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 536870911;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 2 - Pointer Value Wraps"]
            #[inline(always)]
            pub fn wrap(&self) -> WRAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WRAPR { bits }
            }
            #[doc = "Bits 3:31 - Trace Packet Location Pointer"]
            #[inline(always)]
            pub fn pointer(&self) -> POINTERR {
                let bits = {
                    const MASK: u32 = 536870911;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                POINTERR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 2 - Pointer Value Wraps"]
            #[inline(always)]
            pub fn wrap(&mut self) -> _WRAPW {
                _WRAPW { w: self }
            }
            #[doc = "Bits 3:31 - Trace Packet Location Pointer"]
            #[inline(always)]
            pub fn pointer(&mut self) -> _POINTERW {
                _POINTERW { w: self }
            }
        }
    }
}
#[doc = "Cortex-M0+ Micro-Trace Buffer"]
pub struct MTB {
    register_block: mtb::RegisterBlock,
}
impl Deref for MTB {
    type Target = mtb::RegisterBlock;
    fn deref(&self) -> &mtb::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Non-Volatile Memory Controller"]
pub const NVMCTRL: Peripheral<NVMCTRL> = unsafe { Peripheral::new(1090535424) };
#[doc = "Non-Volatile Memory Controller"]
pub mod nvmctrl {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control A"]
        pub ctrla: CTRLA,
        _reserved0: [u8; 2usize],
        #[doc = "0x04 - Control B"]
        pub ctrlb: CTRLB,
        #[doc = "0x08 - NVM Parameter"]
        pub param: PARAM,
        #[doc = "0x0c - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        _reserved1: [u8; 3usize],
        #[doc = "0x10 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        _reserved2: [u8; 3usize],
        #[doc = "0x14 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        _reserved3: [u8; 3usize],
        #[doc = "0x18 - Status"]
        pub status: STATUS,
        _reserved4: [u8; 2usize],
        #[doc = "0x1c - Address"]
        pub addr: ADDR,
        #[doc = "0x20 - Lock Section"]
        pub lock: LOCK,
    }
    #[doc = "Address"]
    pub struct ADDR {
        register: VolatileCell<u32>,
    }
    #[doc = "Address"]
    pub mod addr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ADDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDRR {
            bits: u32,
        }
        impl ADDRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4194303;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:21 - NVM Address"]
            #[inline(always)]
            pub fn addr(&self) -> ADDRR {
                let bits = {
                    const MASK: u32 = 4194303;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                ADDRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:21 - NVM Address"]
            #[inline(always)]
            pub fn addr(&mut self) -> _ADDRW {
                _ADDRW { w: self }
            }
        }
    }
    #[doc = "Control A"]
    pub struct CTRLA {
        register: VolatileCell<u16>,
    }
    #[doc = "Control A"]
    pub mod ctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::CTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CMD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMDR {
            #[doc = "Erase Row - Erases the row addressed by the ADDR register."]
            ER,
            #[doc = "Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register."]
            WP,
            #[doc = "Erase Auxiliary Row - Erases the auxiliary row addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
            EAR,
            #[doc = "Write Auxiliary Page - Writes the contents of the page buffer to the page addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
            WAP,
            #[doc = "Security Flow Command"]
            SF,
            #[doc = "Write lockbits"]
            WL,
            #[doc = "Lock Region - Locks the region containing the address location in the ADDR register."]
            LR,
            #[doc = "Unlock Region - Unlocks the region containing the address location in the ADDR register."]
            UR,
            #[doc = "Sets the power reduction mode."]
            SPRM,
            #[doc = "Clears the power reduction mode."]
            CPRM,
            #[doc = "Page Buffer Clear - Clears the page buffer."]
            PBC,
            #[doc = "Set Security Bit - Sets the security bit by writing 0x00 to the first byte in the lockbit row."]
            SSB,
            #[doc = "Invalidates all cache lines."]
            INVALL,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CMDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMDR::ER => 2,
                    CMDR::WP => 4,
                    CMDR::EAR => 5,
                    CMDR::WAP => 6,
                    CMDR::SF => 10,
                    CMDR::WL => 15,
                    CMDR::LR => 64,
                    CMDR::UR => 65,
                    CMDR::SPRM => 66,
                    CMDR::CPRM => 67,
                    CMDR::PBC => 68,
                    CMDR::SSB => 69,
                    CMDR::INVALL => 70,
                    CMDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CMDR {
                match value {
                    2 => CMDR::ER,
                    4 => CMDR::WP,
                    5 => CMDR::EAR,
                    6 => CMDR::WAP,
                    10 => CMDR::SF,
                    15 => CMDR::WL,
                    64 => CMDR::LR,
                    65 => CMDR::UR,
                    66 => CMDR::SPRM,
                    67 => CMDR::CPRM,
                    68 => CMDR::PBC,
                    69 => CMDR::SSB,
                    70 => CMDR::INVALL,
                    i => CMDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `ER`"]
            #[inline(always)]
            pub fn is_er(&self) -> bool {
                *self == CMDR::ER
            }
            #[doc = "Checks if the value of the field is `WP`"]
            #[inline(always)]
            pub fn is_wp(&self) -> bool {
                *self == CMDR::WP
            }
            #[doc = "Checks if the value of the field is `EAR`"]
            #[inline(always)]
            pub fn is_ear(&self) -> bool {
                *self == CMDR::EAR
            }
            #[doc = "Checks if the value of the field is `WAP`"]
            #[inline(always)]
            pub fn is_wap(&self) -> bool {
                *self == CMDR::WAP
            }
            #[doc = "Checks if the value of the field is `SF`"]
            #[inline(always)]
            pub fn is_sf(&self) -> bool {
                *self == CMDR::SF
            }
            #[doc = "Checks if the value of the field is `WL`"]
            #[inline(always)]
            pub fn is_wl(&self) -> bool {
                *self == CMDR::WL
            }
            #[doc = "Checks if the value of the field is `LR`"]
            #[inline(always)]
            pub fn is_lr(&self) -> bool {
                *self == CMDR::LR
            }
            #[doc = "Checks if the value of the field is `UR`"]
            #[inline(always)]
            pub fn is_ur(&self) -> bool {
                *self == CMDR::UR
            }
            #[doc = "Checks if the value of the field is `SPRM`"]
            #[inline(always)]
            pub fn is_sprm(&self) -> bool {
                *self == CMDR::SPRM
            }
            #[doc = "Checks if the value of the field is `CPRM`"]
            #[inline(always)]
            pub fn is_cprm(&self) -> bool {
                *self == CMDR::CPRM
            }
            #[doc = "Checks if the value of the field is `PBC`"]
            #[inline(always)]
            pub fn is_pbc(&self) -> bool {
                *self == CMDR::PBC
            }
            #[doc = "Checks if the value of the field is `SSB`"]
            #[inline(always)]
            pub fn is_ssb(&self) -> bool {
                *self == CMDR::SSB
            }
            #[doc = "Checks if the value of the field is `INVALL`"]
            #[inline(always)]
            pub fn is_invall(&self) -> bool {
                *self == CMDR::INVALL
            }
        }
        #[doc = "Possible values of the field `CMDEX`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMDEXR {
            #[doc = "Execution Key"]
            KEY,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CMDEXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMDEXR::KEY => 165,
                    CMDEXR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CMDEXR {
                match value {
                    165 => CMDEXR::KEY,
                    i => CMDEXR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `KEY`"]
            #[inline(always)]
            pub fn is_key(&self) -> bool {
                *self == CMDEXR::KEY
            }
        }
        #[doc = "Values that can be written to the field `CMD`"]
        pub enum CMDW {
            #[doc = "Erase Row - Erases the row addressed by the ADDR register."]
            ER,
            #[doc = "Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register."]
            WP,
            #[doc = "Erase Auxiliary Row - Erases the auxiliary row addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
            EAR,
            #[doc = "Write Auxiliary Page - Writes the contents of the page buffer to the page addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
            WAP,
            #[doc = "Security Flow Command"]
            SF,
            #[doc = "Write lockbits"]
            WL,
            #[doc = "Lock Region - Locks the region containing the address location in the ADDR register."]
            LR,
            #[doc = "Unlock Region - Unlocks the region containing the address location in the ADDR register."]
            UR,
            #[doc = "Sets the power reduction mode."]
            SPRM,
            #[doc = "Clears the power reduction mode."]
            CPRM,
            #[doc = "Page Buffer Clear - Clears the page buffer."]
            PBC,
            #[doc = "Set Security Bit - Sets the security bit by writing 0x00 to the first byte in the lockbit row."]
            SSB,
            #[doc = "Invalidates all cache lines."]
            INVALL,
        }
        impl CMDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMDW::ER => 2,
                    CMDW::WP => 4,
                    CMDW::EAR => 5,
                    CMDW::WAP => 6,
                    CMDW::SF => 10,
                    CMDW::WL => 15,
                    CMDW::LR => 64,
                    CMDW::UR => 65,
                    CMDW::SPRM => 66,
                    CMDW::CPRM => 67,
                    CMDW::PBC => 68,
                    CMDW::SSB => 69,
                    CMDW::INVALL => 70,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Erase Row - Erases the row addressed by the ADDR register."]
            #[inline(always)]
            pub fn er(self) -> &'a mut W {
                self.variant(CMDW::ER)
            }
            #[doc = "Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register."]
            #[inline(always)]
            pub fn wp(self) -> &'a mut W {
                self.variant(CMDW::WP)
            }
            #[doc = "Erase Auxiliary Row - Erases the auxiliary row addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
            #[inline(always)]
            pub fn ear(self) -> &'a mut W {
                self.variant(CMDW::EAR)
            }
            #[doc = "Write Auxiliary Page - Writes the contents of the page buffer to the page addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
            #[inline(always)]
            pub fn wap(self) -> &'a mut W {
                self.variant(CMDW::WAP)
            }
            #[doc = "Security Flow Command"]
            #[inline(always)]
            pub fn sf(self) -> &'a mut W {
                self.variant(CMDW::SF)
            }
            #[doc = "Write lockbits"]
            #[inline(always)]
            pub fn wl(self) -> &'a mut W {
                self.variant(CMDW::WL)
            }
            #[doc = "Lock Region - Locks the region containing the address location in the ADDR register."]
            #[inline(always)]
            pub fn lr(self) -> &'a mut W {
                self.variant(CMDW::LR)
            }
            #[doc = "Unlock Region - Unlocks the region containing the address location in the ADDR register."]
            #[inline(always)]
            pub fn ur(self) -> &'a mut W {
                self.variant(CMDW::UR)
            }
            #[doc = "Sets the power reduction mode."]
            #[inline(always)]
            pub fn sprm(self) -> &'a mut W {
                self.variant(CMDW::SPRM)
            }
            #[doc = "Clears the power reduction mode."]
            #[inline(always)]
            pub fn cprm(self) -> &'a mut W {
                self.variant(CMDW::CPRM)
            }
            #[doc = "Page Buffer Clear - Clears the page buffer."]
            #[inline(always)]
            pub fn pbc(self) -> &'a mut W {
                self.variant(CMDW::PBC)
            }
            #[doc = "Set Security Bit - Sets the security bit by writing 0x00 to the first byte in the lockbit row."]
            #[inline(always)]
            pub fn ssb(self) -> &'a mut W {
                self.variant(CMDW::SSB)
            }
            #[doc = "Invalidates all cache lines."]
            #[inline(always)]
            pub fn invall(self) -> &'a mut W {
                self.variant(CMDW::INVALL)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CMDEX`"]
        pub enum CMDEXW {
            #[doc = "Execution Key"]
            KEY,
        }
        impl CMDEXW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMDEXW::KEY => 165,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMDEXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMDEXW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMDEXW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Execution Key"]
            #[inline(always)]
            pub fn key(self) -> &'a mut W {
                self.variant(CMDEXW::KEY)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:6 - Command"]
            #[inline(always)]
            pub fn cmd(&self) -> CMDR {
                CMDR::_from({
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 8:15 - Command Execution"]
            #[inline(always)]
            pub fn cmdex(&self) -> CMDEXR {
                CMDEXR::_from({
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:6 - Command"]
            #[inline(always)]
            pub fn cmd(&mut self) -> _CMDW {
                _CMDW { w: self }
            }
            #[doc = "Bits 8:15 - Command Execution"]
            #[inline(always)]
            pub fn cmdex(&mut self) -> _CMDEXW {
                _CMDEXW { w: self }
            }
        }
    }
    #[doc = "Control B"]
    pub struct CTRLB {
        register: VolatileCell<u32>,
    }
    #[doc = "Control B"]
    pub mod ctrlb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRLB {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `RWS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RWSR {
            #[doc = "Single Auto Wait State"]
            SINGLE,
            #[doc = "Half Auto Wait State"]
            HALF,
            #[doc = "Dual Auto Wait State"]
            DUAL,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl RWSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    RWSR::SINGLE => 0,
                    RWSR::HALF => 1,
                    RWSR::DUAL => 2,
                    RWSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> RWSR {
                match value {
                    0 => RWSR::SINGLE,
                    1 => RWSR::HALF,
                    2 => RWSR::DUAL,
                    i => RWSR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `SINGLE`"]
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                *self == RWSR::SINGLE
            }
            #[doc = "Checks if the value of the field is `HALF`"]
            #[inline(always)]
            pub fn is_half(&self) -> bool {
                *self == RWSR::HALF
            }
            #[doc = "Checks if the value of the field is `DUAL`"]
            #[inline(always)]
            pub fn is_dual(&self) -> bool {
                *self == RWSR::DUAL
            }
        }
        #[doc = r" Value of the field"]
        pub struct MANWR {
            bits: bool,
        }
        impl MANWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SLEEPPRM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLEEPPRMR {
            #[doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode upon first access."]
            WAKEONACCESS,
            #[doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode when exiting sleep."]
            WAKEUPINSTANT,
            #[doc = "Auto power reduction disabled."]
            DISABLED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SLEEPPRMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SLEEPPRMR::WAKEONACCESS => 0,
                    SLEEPPRMR::WAKEUPINSTANT => 1,
                    SLEEPPRMR::DISABLED => 3,
                    SLEEPPRMR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SLEEPPRMR {
                match value {
                    0 => SLEEPPRMR::WAKEONACCESS,
                    1 => SLEEPPRMR::WAKEUPINSTANT,
                    3 => SLEEPPRMR::DISABLED,
                    i => SLEEPPRMR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `WAKEONACCESS`"]
            #[inline(always)]
            pub fn is_wakeonaccess(&self) -> bool {
                *self == SLEEPPRMR::WAKEONACCESS
            }
            #[doc = "Checks if the value of the field is `WAKEUPINSTANT`"]
            #[inline(always)]
            pub fn is_wakeupinstant(&self) -> bool {
                *self == SLEEPPRMR::WAKEUPINSTANT
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SLEEPPRMR::DISABLED
            }
        }
        #[doc = "Possible values of the field `READMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum READMODER {
            #[doc = "The NVM Controller (cache system) does not insert wait states on a cache miss. Gives the best system performance."]
            NO_MISS_PENALTY,
            #[doc = "Reduces power consumption of the cache system, but inserts a wait state each time there is a cache miss. This mode may not be relevant if CPU performance is required, as the application will be stalled and may lead to increase run time."]
            LOW_POWER,
            #[doc = "The cache system ensures that a cache hit or miss takes the same amount of time, determined by the number of programmed flash wait states. This mode can be used for real-time applications that require deterministic execution timings."]
            DETERMINISTIC,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl READMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    READMODER::NO_MISS_PENALTY => 0,
                    READMODER::LOW_POWER => 1,
                    READMODER::DETERMINISTIC => 2,
                    READMODER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> READMODER {
                match value {
                    0 => READMODER::NO_MISS_PENALTY,
                    1 => READMODER::LOW_POWER,
                    2 => READMODER::DETERMINISTIC,
                    i => READMODER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NO_MISS_PENALTY`"]
            #[inline(always)]
            pub fn is_no_miss_penalty(&self) -> bool {
                *self == READMODER::NO_MISS_PENALTY
            }
            #[doc = "Checks if the value of the field is `LOW_POWER`"]
            #[inline(always)]
            pub fn is_low_power(&self) -> bool {
                *self == READMODER::LOW_POWER
            }
            #[doc = "Checks if the value of the field is `DETERMINISTIC`"]
            #[inline(always)]
            pub fn is_deterministic(&self) -> bool {
                *self == READMODER::DETERMINISTIC
            }
        }
        #[doc = r" Value of the field"]
        pub struct CACHEDISR {
            bits: bool,
        }
        impl CACHEDISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `RWS`"]
        pub enum RWSW {
            #[doc = "Single Auto Wait State"]
            SINGLE,
            #[doc = "Half Auto Wait State"]
            HALF,
            #[doc = "Dual Auto Wait State"]
            DUAL,
        }
        impl RWSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RWSW::SINGLE => 0,
                    RWSW::HALF => 1,
                    RWSW::DUAL => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RWSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RWSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RWSW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Single Auto Wait State"]
            #[inline(always)]
            pub fn single(self) -> &'a mut W {
                self.variant(RWSW::SINGLE)
            }
            #[doc = "Half Auto Wait State"]
            #[inline(always)]
            pub fn half(self) -> &'a mut W {
                self.variant(RWSW::HALF)
            }
            #[doc = "Dual Auto Wait State"]
            #[inline(always)]
            pub fn dual(self) -> &'a mut W {
                self.variant(RWSW::DUAL)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MANWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MANWW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLEEPPRM`"]
        pub enum SLEEPPRMW {
            #[doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode upon first access."]
            WAKEONACCESS,
            #[doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode when exiting sleep."]
            WAKEUPINSTANT,
            #[doc = "Auto power reduction disabled."]
            DISABLED,
        }
        impl SLEEPPRMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SLEEPPRMW::WAKEONACCESS => 0,
                    SLEEPPRMW::WAKEUPINSTANT => 1,
                    SLEEPPRMW::DISABLED => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLEEPPRMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLEEPPRMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLEEPPRMW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode upon first access."]
            #[inline(always)]
            pub fn wakeonaccess(self) -> &'a mut W {
                self.variant(SLEEPPRMW::WAKEONACCESS)
            }
            #[doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode when exiting sleep."]
            #[inline(always)]
            pub fn wakeupinstant(self) -> &'a mut W {
                self.variant(SLEEPPRMW::WAKEUPINSTANT)
            }
            #[doc = "Auto power reduction disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SLEEPPRMW::DISABLED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `READMODE`"]
        pub enum READMODEW {
            #[doc = "The NVM Controller (cache system) does not insert wait states on a cache miss. Gives the best system performance."]
            NO_MISS_PENALTY,
            #[doc = "Reduces power consumption of the cache system, but inserts a wait state each time there is a cache miss. This mode may not be relevant if CPU performance is required, as the application will be stalled and may lead to increase run time."]
            LOW_POWER,
            #[doc = "The cache system ensures that a cache hit or miss takes the same amount of time, determined by the number of programmed flash wait states. This mode can be used for real-time applications that require deterministic execution timings."]
            DETERMINISTIC,
        }
        impl READMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    READMODEW::NO_MISS_PENALTY => 0,
                    READMODEW::LOW_POWER => 1,
                    READMODEW::DETERMINISTIC => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _READMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: READMODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "The NVM Controller (cache system) does not insert wait states on a cache miss. Gives the best system performance."]
            #[inline(always)]
            pub fn no_miss_penalty(self) -> &'a mut W {
                self.variant(READMODEW::NO_MISS_PENALTY)
            }
            #[doc = "Reduces power consumption of the cache system, but inserts a wait state each time there is a cache miss. This mode may not be relevant if CPU performance is required, as the application will be stalled and may lead to increase run time."]
            #[inline(always)]
            pub fn low_power(self) -> &'a mut W {
                self.variant(READMODEW::LOW_POWER)
            }
            #[doc = "The cache system ensures that a cache hit or miss takes the same amount of time, determined by the number of programmed flash wait states. This mode can be used for real-time applications that require deterministic execution timings."]
            #[inline(always)]
            pub fn deterministic(self) -> &'a mut W {
                self.variant(READMODEW::DETERMINISTIC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CACHEDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CACHEDISW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 1:4 - NVM Read Wait States"]
            #[inline(always)]
            pub fn rws(&self) -> RWSR {
                RWSR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 7 - Manual Write"]
            #[inline(always)]
            pub fn manw(&self) -> MANWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MANWR { bits }
            }
            #[doc = "Bits 8:9 - Power Reduction Mode during Sleep"]
            #[inline(always)]
            pub fn sleepprm(&self) -> SLEEPPRMR {
                SLEEPPRMR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 16:17 - NVMCTRL Read Mode"]
            #[inline(always)]
            pub fn readmode(&self) -> READMODER {
                READMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 18 - Cache Disable"]
            #[inline(always)]
            pub fn cachedis(&self) -> CACHEDISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CACHEDISR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 1:4 - NVM Read Wait States"]
            #[inline(always)]
            pub fn rws(&mut self) -> _RWSW {
                _RWSW { w: self }
            }
            #[doc = "Bit 7 - Manual Write"]
            #[inline(always)]
            pub fn manw(&mut self) -> _MANWW {
                _MANWW { w: self }
            }
            #[doc = "Bits 8:9 - Power Reduction Mode during Sleep"]
            #[inline(always)]
            pub fn sleepprm(&mut self) -> _SLEEPPRMW {
                _SLEEPPRMW { w: self }
            }
            #[doc = "Bits 16:17 - NVMCTRL Read Mode"]
            #[inline(always)]
            pub fn readmode(&mut self) -> _READMODEW {
                _READMODEW { w: self }
            }
            #[doc = "Bit 18 - Cache Disable"]
            #[inline(always)]
            pub fn cachedis(&mut self) -> _CACHEDISW {
                _CACHEDISW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct READYR {
            bits: bool,
        }
        impl READYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRORR {
            bits: bool,
        }
        impl ERRORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _READYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - NVM Ready Interrupt Enable"]
            #[inline(always)]
            pub fn ready(&self) -> READYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                READYR { bits }
            }
            #[doc = "Bit 1 - Error Interrupt Enable"]
            #[inline(always)]
            pub fn error(&self) -> ERRORR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ERRORR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - NVM Ready Interrupt Enable"]
            #[inline(always)]
            pub fn ready(&mut self) -> _READYW {
                _READYW { w: self }
            }
            #[doc = "Bit 1 - Error Interrupt Enable"]
            #[inline(always)]
            pub fn error(&mut self) -> _ERRORW {
                _ERRORW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct READYR {
            bits: bool,
        }
        impl READYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRORR {
            bits: bool,
        }
        impl ERRORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _READYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - NVM Ready Interrupt Enable"]
            #[inline(always)]
            pub fn ready(&self) -> READYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                READYR { bits }
            }
            #[doc = "Bit 1 - Error Interrupt Enable"]
            #[inline(always)]
            pub fn error(&self) -> ERRORR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ERRORR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - NVM Ready Interrupt Enable"]
            #[inline(always)]
            pub fn ready(&mut self) -> _READYW {
                _READYW { w: self }
            }
            #[doc = "Bit 1 - Error Interrupt Enable"]
            #[inline(always)]
            pub fn error(&mut self) -> _ERRORW {
                _ERRORW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct READYR {
            bits: bool,
        }
        impl READYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRORR {
            bits: bool,
        }
        impl ERRORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - NVM Ready"]
            #[inline(always)]
            pub fn ready(&self) -> READYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                READYR { bits }
            }
            #[doc = "Bit 1 - Error"]
            #[inline(always)]
            pub fn error(&self) -> ERRORR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ERRORR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Error"]
            #[inline(always)]
            pub fn error(&mut self) -> _ERRORW {
                _ERRORW { w: self }
            }
        }
    }
    #[doc = "Lock Section"]
    pub struct LOCK {
        register: VolatileCell<u16>,
    }
    #[doc = "Lock Section"]
    pub mod lock {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        impl super::LOCK {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOCKR {
            bits: u16,
        }
        impl LOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Region Lock Bits"]
            #[inline(always)]
            pub fn lock(&self) -> LOCKR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                LOCKR { bits }
            }
        }
    }
    #[doc = "NVM Parameter"]
    pub struct PARAM {
        register: VolatileCell<u32>,
    }
    #[doc = "NVM Parameter"]
    pub mod param {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PARAM {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct NVMPR {
            bits: u16,
        }
        impl NVMPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `PSZ`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PSZR {
            #[doc = "8 bytes"]
            _8,
            #[doc = "16 bytes"]
            _16,
            #[doc = "32 bytes"]
            _32,
            #[doc = "64 bytes"]
            _64,
            #[doc = "128 bytes"]
            _128,
            #[doc = "256 bytes"]
            _256,
            #[doc = "512 bytes"]
            _512,
            #[doc = "1024 bytes"]
            _1024,
        }
        impl PSZR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    PSZR::_8 => 0,
                    PSZR::_16 => 1,
                    PSZR::_32 => 2,
                    PSZR::_64 => 3,
                    PSZR::_128 => 4,
                    PSZR::_256 => 5,
                    PSZR::_512 => 6,
                    PSZR::_1024 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> PSZR {
                match value {
                    0 => PSZR::_8,
                    1 => PSZR::_16,
                    2 => PSZR::_32,
                    3 => PSZR::_64,
                    4 => PSZR::_128,
                    5 => PSZR::_256,
                    6 => PSZR::_512,
                    7 => PSZR::_1024,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_8`"]
            #[inline(always)]
            pub fn is_8(&self) -> bool {
                *self == PSZR::_8
            }
            #[doc = "Checks if the value of the field is `_16`"]
            #[inline(always)]
            pub fn is_16(&self) -> bool {
                *self == PSZR::_16
            }
            #[doc = "Checks if the value of the field is `_32`"]
            #[inline(always)]
            pub fn is_32(&self) -> bool {
                *self == PSZR::_32
            }
            #[doc = "Checks if the value of the field is `_64`"]
            #[inline(always)]
            pub fn is_64(&self) -> bool {
                *self == PSZR::_64
            }
            #[doc = "Checks if the value of the field is `_128`"]
            #[inline(always)]
            pub fn is_128(&self) -> bool {
                *self == PSZR::_128
            }
            #[doc = "Checks if the value of the field is `_256`"]
            #[inline(always)]
            pub fn is_256(&self) -> bool {
                *self == PSZR::_256
            }
            #[doc = "Checks if the value of the field is `_512`"]
            #[inline(always)]
            pub fn is_512(&self) -> bool {
                *self == PSZR::_512
            }
            #[doc = "Checks if the value of the field is `_1024`"]
            #[inline(always)]
            pub fn is_1024(&self) -> bool {
                *self == PSZR::_1024
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - NVM Pages"]
            #[inline(always)]
            pub fn nvmp(&self) -> NVMPR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NVMPR { bits }
            }
            #[doc = "Bits 16:18 - Page Size"]
            #[inline(always)]
            pub fn psz(&self) -> PSZR {
                PSZR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u16>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::STATUS {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRMR {
            bits: bool,
        }
        impl PRMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOADR {
            bits: bool,
        }
        impl LOADR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PROGER {
            bits: bool,
        }
        impl PROGER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOCKER {
            bits: bool,
        }
        impl LOCKER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NVMER {
            bits: bool,
        }
        impl NVMER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SBR {
            bits: bool,
        }
        impl SBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOADW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOADW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PROGEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PROGEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOCKEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOCKEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NVMEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NVMEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Power Reduction Mode"]
            #[inline(always)]
            pub fn prm(&self) -> PRMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PRMR { bits }
            }
            #[doc = "Bit 1 - NVM Page Buffer Active Loading"]
            #[inline(always)]
            pub fn load(&self) -> LOADR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                LOADR { bits }
            }
            #[doc = "Bit 2 - Programming Error Status"]
            #[inline(always)]
            pub fn proge(&self) -> PROGER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PROGER { bits }
            }
            #[doc = "Bit 3 - Lock Error Status"]
            #[inline(always)]
            pub fn locke(&self) -> LOCKER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                LOCKER { bits }
            }
            #[doc = "Bit 4 - NVM Error"]
            #[inline(always)]
            pub fn nvme(&self) -> NVMER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                NVMER { bits }
            }
            #[doc = "Bit 8 - Security Bit Status"]
            #[inline(always)]
            pub fn sb(&self) -> SBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                SBR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - NVM Page Buffer Active Loading"]
            #[inline(always)]
            pub fn load(&mut self) -> _LOADW {
                _LOADW { w: self }
            }
            #[doc = "Bit 2 - Programming Error Status"]
            #[inline(always)]
            pub fn proge(&mut self) -> _PROGEW {
                _PROGEW { w: self }
            }
            #[doc = "Bit 3 - Lock Error Status"]
            #[inline(always)]
            pub fn locke(&mut self) -> _LOCKEW {
                _LOCKEW { w: self }
            }
            #[doc = "Bit 4 - NVM Error"]
            #[inline(always)]
            pub fn nvme(&mut self) -> _NVMEW {
                _NVMEW { w: self }
            }
        }
    }
}
#[doc = "Non-Volatile Memory Controller"]
pub struct NVMCTRL {
    register_block: nvmctrl::RegisterBlock,
}
impl Deref for NVMCTRL {
    type Target = nvmctrl::RegisterBlock;
    fn deref(&self) -> &nvmctrl::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Peripheral Access Controller 0"]
pub const PAC0: Peripheral<PAC0> = unsafe { Peripheral::new(1073741824) };
#[doc = "Peripheral Access Controller 0"]
pub mod pac0 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Write Protection Clear"]
        pub wpclr: WPCLR,
        #[doc = "0x04 - Write Protection Set"]
        pub wpset: WPSET,
    }
    #[doc = "Write Protection Clear"]
    pub struct WPCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Write Protection Clear"]
    pub mod wpclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WPCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WPR {
            bits: u32,
        }
        impl WPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 2147483647;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 1:31 - Write Protection Clear"]
            #[inline(always)]
            pub fn wp(&self) -> WPR {
                let bits = {
                    const MASK: u32 = 2147483647;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                WPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 1:31 - Write Protection Clear"]
            #[inline(always)]
            pub fn wp(&mut self) -> _WPW {
                _WPW { w: self }
            }
        }
    }
    #[doc = "Write Protection Set"]
    pub struct WPSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Write Protection Set"]
    pub mod wpset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WPSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WPR {
            bits: u32,
        }
        impl WPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 2147483647;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 1:31 - Write Protection Set"]
            #[inline(always)]
            pub fn wp(&self) -> WPR {
                let bits = {
                    const MASK: u32 = 2147483647;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                WPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 1:31 - Write Protection Set"]
            #[inline(always)]
            pub fn wp(&mut self) -> _WPW {
                _WPW { w: self }
            }
        }
    }
}
#[doc = "Peripheral Access Controller 0"]
pub struct PAC0 {
    register_block: pac0::RegisterBlock,
}
impl Deref for PAC0 {
    type Target = pac0::RegisterBlock;
    fn deref(&self) -> &pac0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Peripheral Access Controller 1"]
pub const PAC1: Peripheral<PAC1> = unsafe { Peripheral::new(1090519040) };
#[doc = r" Register block"]
pub struct PAC1 {
    register_block: pac0::RegisterBlock,
}
impl Deref for PAC1 {
    type Target = pac0::RegisterBlock;
    fn deref(&self) -> &pac0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Peripheral Access Controller 2"]
pub const PAC2: Peripheral<PAC2> = unsafe { Peripheral::new(1107296256) };
#[doc = r" Register block"]
pub struct PAC2 {
    register_block: pac0::RegisterBlock,
}
impl Deref for PAC2 {
    type Target = pac0::RegisterBlock;
    fn deref(&self) -> &pac0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Power Manager"]
pub const PM: Peripheral<PM> = unsafe { Peripheral::new(1073742848) };
#[doc = "Power Manager"]
pub mod pm {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctrl: CTRL,
        #[doc = "0x01 - Sleep Mode"]
        pub sleep: SLEEP,
        _reserved0: [u8; 6usize],
        #[doc = "0x08 - CPU Clock Select"]
        pub cpusel: CPUSEL,
        #[doc = "0x09 - APBA Clock Select"]
        pub apbasel: APBASEL,
        #[doc = "0x0a - APBB Clock Select"]
        pub apbbsel: APBBSEL,
        #[doc = "0x0b - APBC Clock Select"]
        pub apbcsel: APBCSEL,
        _reserved1: [u8; 8usize],
        #[doc = "0x14 - AHB Mask"]
        pub ahbmask: AHBMASK,
        #[doc = "0x18 - APBA Mask"]
        pub apbamask: APBAMASK,
        #[doc = "0x1c - APBB Mask"]
        pub apbbmask: APBBMASK,
        #[doc = "0x20 - APBC Mask"]
        pub apbcmask: APBCMASK,
        _reserved2: [u8; 16usize],
        #[doc = "0x34 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x35 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x36 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        _reserved3: [u8; 1usize],
        #[doc = "0x38 - Reset Cause"]
        pub rcause: RCAUSE,
    }
    #[doc = "AHB Mask"]
    pub struct AHBMASK {
        register: VolatileCell<u32>,
    }
    #[doc = "AHB Mask"]
    pub mod ahbmask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::AHBMASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct HPB0R {
            bits: bool,
        }
        impl HPB0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HPB1R {
            bits: bool,
        }
        impl HPB1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HPB2R {
            bits: bool,
        }
        impl HPB2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DSUR {
            bits: bool,
        }
        impl DSUR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NVMCTRLR {
            bits: bool,
        }
        impl NVMCTRLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMACR {
            bits: bool,
        }
        impl DMACR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USBR {
            bits: bool,
        }
        impl USBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _HPB0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _HPB0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HPB1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _HPB1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HPB2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _HPB2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DSUW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DSUW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NVMCTRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NVMCTRLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMACW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMACW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _USBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - HPB0 AHB Clock Enable"]
            #[inline(always)]
            pub fn hpb0(&self) -> HPB0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HPB0R { bits }
            }
            #[doc = "Bit 1 - HPB1 AHB Clock Enable"]
            #[inline(always)]
            pub fn hpb1(&self) -> HPB1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HPB1R { bits }
            }
            #[doc = "Bit 2 - HPB2 AHB Clock Enable"]
            #[inline(always)]
            pub fn hpb2(&self) -> HPB2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HPB2R { bits }
            }
            #[doc = "Bit 3 - DSU AHB Clock Enable"]
            #[inline(always)]
            pub fn dsu(&self) -> DSUR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DSUR { bits }
            }
            #[doc = "Bit 4 - NVMCTRL AHB Clock Enable"]
            #[inline(always)]
            pub fn nvmctrl(&self) -> NVMCTRLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NVMCTRLR { bits }
            }
            #[doc = "Bit 5 - DMAC AHB Clock Enable"]
            #[inline(always)]
            pub fn dmac(&self) -> DMACR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMACR { bits }
            }
            #[doc = "Bit 6 - USB AHB Clock Enable"]
            #[inline(always)]
            pub fn usb(&self) -> USBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USBR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 127 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - HPB0 AHB Clock Enable"]
            #[inline(always)]
            pub fn hpb0(&mut self) -> _HPB0W {
                _HPB0W { w: self }
            }
            #[doc = "Bit 1 - HPB1 AHB Clock Enable"]
            #[inline(always)]
            pub fn hpb1(&mut self) -> _HPB1W {
                _HPB1W { w: self }
            }
            #[doc = "Bit 2 - HPB2 AHB Clock Enable"]
            #[inline(always)]
            pub fn hpb2(&mut self) -> _HPB2W {
                _HPB2W { w: self }
            }
            #[doc = "Bit 3 - DSU AHB Clock Enable"]
            #[inline(always)]
            pub fn dsu(&mut self) -> _DSUW {
                _DSUW { w: self }
            }
            #[doc = "Bit 4 - NVMCTRL AHB Clock Enable"]
            #[inline(always)]
            pub fn nvmctrl(&mut self) -> _NVMCTRLW {
                _NVMCTRLW { w: self }
            }
            #[doc = "Bit 5 - DMAC AHB Clock Enable"]
            #[inline(always)]
            pub fn dmac(&mut self) -> _DMACW {
                _DMACW { w: self }
            }
            #[doc = "Bit 6 - USB AHB Clock Enable"]
            #[inline(always)]
            pub fn usb(&mut self) -> _USBW {
                _USBW { w: self }
            }
        }
    }
    #[doc = "APBA Mask"]
    pub struct APBAMASK {
        register: VolatileCell<u32>,
    }
    #[doc = "APBA Mask"]
    pub mod apbamask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::APBAMASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PAC0R {
            bits: bool,
        }
        impl PAC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PMR {
            bits: bool,
        }
        impl PMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYSCTRLR {
            bits: bool,
        }
        impl SYSCTRLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct GCLKR {
            bits: bool,
        }
        impl GCLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDTR {
            bits: bool,
        }
        impl WDTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RTCR {
            bits: bool,
        }
        impl RTCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EICR {
            bits: bool,
        }
        impl EICR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PAC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PAC0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSCTRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSCTRLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GCLKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RTCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RTCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EICW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EICW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - PAC0 APB Clock Enable"]
            #[inline(always)]
            pub fn pac0(&self) -> PAC0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PAC0R { bits }
            }
            #[doc = "Bit 1 - PM APB Clock Enable"]
            #[inline(always)]
            pub fn pm(&self) -> PMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PMR { bits }
            }
            #[doc = "Bit 2 - SYSCTRL APB Clock Enable"]
            #[inline(always)]
            pub fn sysctrl(&self) -> SYSCTRLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SYSCTRLR { bits }
            }
            #[doc = "Bit 3 - GCLK APB Clock Enable"]
            #[inline(always)]
            pub fn gclk(&self) -> GCLKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GCLKR { bits }
            }
            #[doc = "Bit 4 - WDT APB Clock Enable"]
            #[inline(always)]
            pub fn wdt(&self) -> WDTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDTR { bits }
            }
            #[doc = "Bit 5 - RTC APB Clock Enable"]
            #[inline(always)]
            pub fn rtc(&self) -> RTCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RTCR { bits }
            }
            #[doc = "Bit 6 - EIC APB Clock Enable"]
            #[inline(always)]
            pub fn eic(&self) -> EICR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EICR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 127 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - PAC0 APB Clock Enable"]
            #[inline(always)]
            pub fn pac0(&mut self) -> _PAC0W {
                _PAC0W { w: self }
            }
            #[doc = "Bit 1 - PM APB Clock Enable"]
            #[inline(always)]
            pub fn pm(&mut self) -> _PMW {
                _PMW { w: self }
            }
            #[doc = "Bit 2 - SYSCTRL APB Clock Enable"]
            #[inline(always)]
            pub fn sysctrl(&mut self) -> _SYSCTRLW {
                _SYSCTRLW { w: self }
            }
            #[doc = "Bit 3 - GCLK APB Clock Enable"]
            #[inline(always)]
            pub fn gclk(&mut self) -> _GCLKW {
                _GCLKW { w: self }
            }
            #[doc = "Bit 4 - WDT APB Clock Enable"]
            #[inline(always)]
            pub fn wdt(&mut self) -> _WDTW {
                _WDTW { w: self }
            }
            #[doc = "Bit 5 - RTC APB Clock Enable"]
            #[inline(always)]
            pub fn rtc(&mut self) -> _RTCW {
                _RTCW { w: self }
            }
            #[doc = "Bit 6 - EIC APB Clock Enable"]
            #[inline(always)]
            pub fn eic(&mut self) -> _EICW {
                _EICW { w: self }
            }
        }
    }
    #[doc = "APBA Clock Select"]
    pub struct APBASEL {
        register: VolatileCell<u8>,
    }
    #[doc = "APBA Clock Select"]
    pub mod apbasel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::APBASEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `APBADIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum APBADIVR {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl APBADIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    APBADIVR::DIV1 => 0,
                    APBADIVR::DIV2 => 1,
                    APBADIVR::DIV4 => 2,
                    APBADIVR::DIV8 => 3,
                    APBADIVR::DIV16 => 4,
                    APBADIVR::DIV32 => 5,
                    APBADIVR::DIV64 => 6,
                    APBADIVR::DIV128 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> APBADIVR {
                match value {
                    0 => APBADIVR::DIV1,
                    1 => APBADIVR::DIV2,
                    2 => APBADIVR::DIV4,
                    3 => APBADIVR::DIV8,
                    4 => APBADIVR::DIV16,
                    5 => APBADIVR::DIV32,
                    6 => APBADIVR::DIV64,
                    7 => APBADIVR::DIV128,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == APBADIVR::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == APBADIVR::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == APBADIVR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == APBADIVR::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == APBADIVR::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == APBADIVR::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == APBADIVR::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == APBADIVR::DIV128
            }
        }
        #[doc = "Values that can be written to the field `APBADIV`"]
        pub enum APBADIVW {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl APBADIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    APBADIVW::DIV1 => 0,
                    APBADIVW::DIV2 => 1,
                    APBADIVW::DIV4 => 2,
                    APBADIVW::DIV8 => 3,
                    APBADIVW::DIV16 => 4,
                    APBADIVW::DIV32 => 5,
                    APBADIVW::DIV64 => 6,
                    APBADIVW::DIV128 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _APBADIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _APBADIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: APBADIVW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Divide by 1"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(APBADIVW::DIV1)
            }
            #[doc = "Divide by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(APBADIVW::DIV2)
            }
            #[doc = "Divide by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(APBADIVW::DIV4)
            }
            #[doc = "Divide by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(APBADIVW::DIV8)
            }
            #[doc = "Divide by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(APBADIVW::DIV16)
            }
            #[doc = "Divide by 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut W {
                self.variant(APBADIVW::DIV32)
            }
            #[doc = "Divide by 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(APBADIVW::DIV64)
            }
            #[doc = "Divide by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(APBADIVW::DIV128)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:2 - APBA Prescaler Selection"]
            #[inline(always)]
            pub fn apbadiv(&self) -> APBADIVR {
                APBADIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - APBA Prescaler Selection"]
            #[inline(always)]
            pub fn apbadiv(&mut self) -> _APBADIVW {
                _APBADIVW { w: self }
            }
        }
    }
    #[doc = "APBB Mask"]
    pub struct APBBMASK {
        register: VolatileCell<u32>,
    }
    #[doc = "APBB Mask"]
    pub mod apbbmask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::APBBMASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PAC1R {
            bits: bool,
        }
        impl PAC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DSUR {
            bits: bool,
        }
        impl DSUR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NVMCTRLR {
            bits: bool,
        }
        impl NVMCTRLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PORTR {
            bits: bool,
        }
        impl PORTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMACR {
            bits: bool,
        }
        impl DMACR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USBR {
            bits: bool,
        }
        impl USBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PAC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PAC1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DSUW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DSUW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NVMCTRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NVMCTRLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PORTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMACW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMACW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _USBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - PAC1 APB Clock Enable"]
            #[inline(always)]
            pub fn pac1(&self) -> PAC1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PAC1R { bits }
            }
            #[doc = "Bit 1 - DSU APB Clock Enable"]
            #[inline(always)]
            pub fn dsu(&self) -> DSUR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DSUR { bits }
            }
            #[doc = "Bit 2 - NVMCTRL APB Clock Enable"]
            #[inline(always)]
            pub fn nvmctrl(&self) -> NVMCTRLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NVMCTRLR { bits }
            }
            #[doc = "Bit 3 - PORT APB Clock Enable"]
            #[inline(always)]
            pub fn port(&self) -> PORTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PORTR { bits }
            }
            #[doc = "Bit 4 - DMAC APB Clock Enable"]
            #[inline(always)]
            pub fn dmac(&self) -> DMACR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMACR { bits }
            }
            #[doc = "Bit 5 - USB APB Clock Enable"]
            #[inline(always)]
            pub fn usb(&self) -> USBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USBR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 127 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - PAC1 APB Clock Enable"]
            #[inline(always)]
            pub fn pac1(&mut self) -> _PAC1W {
                _PAC1W { w: self }
            }
            #[doc = "Bit 1 - DSU APB Clock Enable"]
            #[inline(always)]
            pub fn dsu(&mut self) -> _DSUW {
                _DSUW { w: self }
            }
            #[doc = "Bit 2 - NVMCTRL APB Clock Enable"]
            #[inline(always)]
            pub fn nvmctrl(&mut self) -> _NVMCTRLW {
                _NVMCTRLW { w: self }
            }
            #[doc = "Bit 3 - PORT APB Clock Enable"]
            #[inline(always)]
            pub fn port(&mut self) -> _PORTW {
                _PORTW { w: self }
            }
            #[doc = "Bit 4 - DMAC APB Clock Enable"]
            #[inline(always)]
            pub fn dmac(&mut self) -> _DMACW {
                _DMACW { w: self }
            }
            #[doc = "Bit 5 - USB APB Clock Enable"]
            #[inline(always)]
            pub fn usb(&mut self) -> _USBW {
                _USBW { w: self }
            }
        }
    }
    #[doc = "APBB Clock Select"]
    pub struct APBBSEL {
        register: VolatileCell<u8>,
    }
    #[doc = "APBB Clock Select"]
    pub mod apbbsel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::APBBSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `APBBDIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum APBBDIVR {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl APBBDIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    APBBDIVR::DIV1 => 0,
                    APBBDIVR::DIV2 => 1,
                    APBBDIVR::DIV4 => 2,
                    APBBDIVR::DIV8 => 3,
                    APBBDIVR::DIV16 => 4,
                    APBBDIVR::DIV32 => 5,
                    APBBDIVR::DIV64 => 6,
                    APBBDIVR::DIV128 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> APBBDIVR {
                match value {
                    0 => APBBDIVR::DIV1,
                    1 => APBBDIVR::DIV2,
                    2 => APBBDIVR::DIV4,
                    3 => APBBDIVR::DIV8,
                    4 => APBBDIVR::DIV16,
                    5 => APBBDIVR::DIV32,
                    6 => APBBDIVR::DIV64,
                    7 => APBBDIVR::DIV128,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == APBBDIVR::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == APBBDIVR::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == APBBDIVR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == APBBDIVR::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == APBBDIVR::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == APBBDIVR::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == APBBDIVR::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == APBBDIVR::DIV128
            }
        }
        #[doc = "Values that can be written to the field `APBBDIV`"]
        pub enum APBBDIVW {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl APBBDIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    APBBDIVW::DIV1 => 0,
                    APBBDIVW::DIV2 => 1,
                    APBBDIVW::DIV4 => 2,
                    APBBDIVW::DIV8 => 3,
                    APBBDIVW::DIV16 => 4,
                    APBBDIVW::DIV32 => 5,
                    APBBDIVW::DIV64 => 6,
                    APBBDIVW::DIV128 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _APBBDIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _APBBDIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: APBBDIVW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Divide by 1"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV1)
            }
            #[doc = "Divide by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV2)
            }
            #[doc = "Divide by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV4)
            }
            #[doc = "Divide by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV8)
            }
            #[doc = "Divide by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV16)
            }
            #[doc = "Divide by 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV32)
            }
            #[doc = "Divide by 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV64)
            }
            #[doc = "Divide by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV128)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:2 - APBB Prescaler Selection"]
            #[inline(always)]
            pub fn apbbdiv(&self) -> APBBDIVR {
                APBBDIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - APBB Prescaler Selection"]
            #[inline(always)]
            pub fn apbbdiv(&mut self) -> _APBBDIVW {
                _APBBDIVW { w: self }
            }
        }
    }
    #[doc = "APBC Mask"]
    pub struct APBCMASK {
        register: VolatileCell<u32>,
    }
    #[doc = "APBC Mask"]
    pub mod apbcmask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::APBCMASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PAC2R {
            bits: bool,
        }
        impl PAC2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVSYSR {
            bits: bool,
        }
        impl EVSYSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SERCOM0R {
            bits: bool,
        }
        impl SERCOM0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SERCOM1R {
            bits: bool,
        }
        impl SERCOM1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SERCOM2R {
            bits: bool,
        }
        impl SERCOM2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SERCOM3R {
            bits: bool,
        }
        impl SERCOM3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SERCOM4R {
            bits: bool,
        }
        impl SERCOM4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SERCOM5R {
            bits: bool,
        }
        impl SERCOM5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCC0R {
            bits: bool,
        }
        impl TCC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCC1R {
            bits: bool,
        }
        impl TCC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCC2R {
            bits: bool,
        }
        impl TCC2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TC3R {
            bits: bool,
        }
        impl TC3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TC4R {
            bits: bool,
        }
        impl TC4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TC5R {
            bits: bool,
        }
        impl TC5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADCR {
            bits: bool,
        }
        impl ADCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACR {
            bits: bool,
        }
        impl ACR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACR {
            bits: bool,
        }
        impl DACR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2SR {
            bits: bool,
        }
        impl I2SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ATWR {
            bits: bool,
        }
        impl ATWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PAC2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PAC2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVSYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVSYSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SERCOM0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SERCOM0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SERCOM1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SERCOM1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SERCOM2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SERCOM2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SERCOM3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SERCOM3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SERCOM4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SERCOM4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SERCOM5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SERCOM5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCC0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCC1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCC2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCC2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TC3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TC3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TC4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TC4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TC5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TC5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2SW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ATWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ATWW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - PAC2 APB Clock Enable"]
            #[inline(always)]
            pub fn pac2(&self) -> PAC2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PAC2R { bits }
            }
            #[doc = "Bit 1 - EVSYS APB Clock Enable"]
            #[inline(always)]
            pub fn evsys(&self) -> EVSYSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVSYSR { bits }
            }
            #[doc = "Bit 2 - SERCOM0 APB Clock Enable"]
            #[inline(always)]
            pub fn sercom0(&self) -> SERCOM0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SERCOM0R { bits }
            }
            #[doc = "Bit 3 - SERCOM1 APB Clock Enable"]
            #[inline(always)]
            pub fn sercom1(&self) -> SERCOM1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SERCOM1R { bits }
            }
            #[doc = "Bit 4 - SERCOM2 APB Clock Enable"]
            #[inline(always)]
            pub fn sercom2(&self) -> SERCOM2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SERCOM2R { bits }
            }
            #[doc = "Bit 5 - SERCOM3 APB Clock Enable"]
            #[inline(always)]
            pub fn sercom3(&self) -> SERCOM3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SERCOM3R { bits }
            }
            #[doc = "Bit 6 - SERCOM4 APB Clock Enable"]
            #[inline(always)]
            pub fn sercom4(&self) -> SERCOM4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SERCOM4R { bits }
            }
            #[doc = "Bit 7 - SERCOM5 APB Clock Enable"]
            #[inline(always)]
            pub fn sercom5(&self) -> SERCOM5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SERCOM5R { bits }
            }
            #[doc = "Bit 8 - TCC0 APB Clock Enable"]
            #[inline(always)]
            pub fn tcc0(&self) -> TCC0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TCC0R { bits }
            }
            #[doc = "Bit 9 - TCC1 APB Clock Enable"]
            #[inline(always)]
            pub fn tcc1(&self) -> TCC1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TCC1R { bits }
            }
            #[doc = "Bit 10 - TCC2 APB Clock Enable"]
            #[inline(always)]
            pub fn tcc2(&self) -> TCC2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TCC2R { bits }
            }
            #[doc = "Bit 11 - TC3 APB Clock Enable"]
            #[inline(always)]
            pub fn tc3(&self) -> TC3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TC3R { bits }
            }
            #[doc = "Bit 12 - TC4 APB Clock Enable"]
            #[inline(always)]
            pub fn tc4(&self) -> TC4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TC4R { bits }
            }
            #[doc = "Bit 13 - TC5 APB Clock Enable"]
            #[inline(always)]
            pub fn tc5(&self) -> TC5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TC5R { bits }
            }
            #[doc = "Bit 16 - ADC APB Clock Enable"]
            #[inline(always)]
            pub fn adc(&self) -> ADCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADCR { bits }
            }
            #[doc = "Bit 17 - AC APB Clock Enable"]
            #[inline(always)]
            pub fn ac(&self) -> ACR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ACR { bits }
            }
            #[doc = "Bit 18 - DAC APB Clock Enable"]
            #[inline(always)]
            pub fn dac(&self) -> DACR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DACR { bits }
            }
            #[doc = "Bit 20 - I2S APB Clock Enable"]
            #[inline(always)]
            pub fn i2s(&self) -> I2SR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2SR { bits }
            }
            #[doc = "Bit 23 - ATW APB Clock Enable"]
            #[inline(always)]
            pub fn atw(&self) -> ATWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ATWR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 65536 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - PAC2 APB Clock Enable"]
            #[inline(always)]
            pub fn pac2(&mut self) -> _PAC2W {
                _PAC2W { w: self }
            }
            #[doc = "Bit 1 - EVSYS APB Clock Enable"]
            #[inline(always)]
            pub fn evsys(&mut self) -> _EVSYSW {
                _EVSYSW { w: self }
            }
            #[doc = "Bit 2 - SERCOM0 APB Clock Enable"]
            #[inline(always)]
            pub fn sercom0(&mut self) -> _SERCOM0W {
                _SERCOM0W { w: self }
            }
            #[doc = "Bit 3 - SERCOM1 APB Clock Enable"]
            #[inline(always)]
            pub fn sercom1(&mut self) -> _SERCOM1W {
                _SERCOM1W { w: self }
            }
            #[doc = "Bit 4 - SERCOM2 APB Clock Enable"]
            #[inline(always)]
            pub fn sercom2(&mut self) -> _SERCOM2W {
                _SERCOM2W { w: self }
            }
            #[doc = "Bit 5 - SERCOM3 APB Clock Enable"]
            #[inline(always)]
            pub fn sercom3(&mut self) -> _SERCOM3W {
                _SERCOM3W { w: self }
            }
            #[doc = "Bit 6 - SERCOM4 APB Clock Enable"]
            #[inline(always)]
            pub fn sercom4(&mut self) -> _SERCOM4W {
                _SERCOM4W { w: self }
            }
            #[doc = "Bit 7 - SERCOM5 APB Clock Enable"]
            #[inline(always)]
            pub fn sercom5(&mut self) -> _SERCOM5W {
                _SERCOM5W { w: self }
            }
            #[doc = "Bit 8 - TCC0 APB Clock Enable"]
            #[inline(always)]
            pub fn tcc0(&mut self) -> _TCC0W {
                _TCC0W { w: self }
            }
            #[doc = "Bit 9 - TCC1 APB Clock Enable"]
            #[inline(always)]
            pub fn tcc1(&mut self) -> _TCC1W {
                _TCC1W { w: self }
            }
            #[doc = "Bit 10 - TCC2 APB Clock Enable"]
            #[inline(always)]
            pub fn tcc2(&mut self) -> _TCC2W {
                _TCC2W { w: self }
            }
            #[doc = "Bit 11 - TC3 APB Clock Enable"]
            #[inline(always)]
            pub fn tc3(&mut self) -> _TC3W {
                _TC3W { w: self }
            }
            #[doc = "Bit 12 - TC4 APB Clock Enable"]
            #[inline(always)]
            pub fn tc4(&mut self) -> _TC4W {
                _TC4W { w: self }
            }
            #[doc = "Bit 13 - TC5 APB Clock Enable"]
            #[inline(always)]
            pub fn tc5(&mut self) -> _TC5W {
                _TC5W { w: self }
            }
            #[doc = "Bit 16 - ADC APB Clock Enable"]
            #[inline(always)]
            pub fn adc(&mut self) -> _ADCW {
                _ADCW { w: self }
            }
            #[doc = "Bit 17 - AC APB Clock Enable"]
            #[inline(always)]
            pub fn ac(&mut self) -> _ACW {
                _ACW { w: self }
            }
            #[doc = "Bit 18 - DAC APB Clock Enable"]
            #[inline(always)]
            pub fn dac(&mut self) -> _DACW {
                _DACW { w: self }
            }
            #[doc = "Bit 20 - I2S APB Clock Enable"]
            #[inline(always)]
            pub fn i2s(&mut self) -> _I2SW {
                _I2SW { w: self }
            }
            #[doc = "Bit 23 - ATW APB Clock Enable"]
            #[inline(always)]
            pub fn atw(&mut self) -> _ATWW {
                _ATWW { w: self }
            }
        }
    }
    #[doc = "APBC Clock Select"]
    pub struct APBCSEL {
        register: VolatileCell<u8>,
    }
    #[doc = "APBC Clock Select"]
    pub mod apbcsel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::APBCSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `APBCDIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum APBCDIVR {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl APBCDIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    APBCDIVR::DIV1 => 0,
                    APBCDIVR::DIV2 => 1,
                    APBCDIVR::DIV4 => 2,
                    APBCDIVR::DIV8 => 3,
                    APBCDIVR::DIV16 => 4,
                    APBCDIVR::DIV32 => 5,
                    APBCDIVR::DIV64 => 6,
                    APBCDIVR::DIV128 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> APBCDIVR {
                match value {
                    0 => APBCDIVR::DIV1,
                    1 => APBCDIVR::DIV2,
                    2 => APBCDIVR::DIV4,
                    3 => APBCDIVR::DIV8,
                    4 => APBCDIVR::DIV16,
                    5 => APBCDIVR::DIV32,
                    6 => APBCDIVR::DIV64,
                    7 => APBCDIVR::DIV128,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == APBCDIVR::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == APBCDIVR::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == APBCDIVR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == APBCDIVR::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == APBCDIVR::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == APBCDIVR::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == APBCDIVR::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == APBCDIVR::DIV128
            }
        }
        #[doc = "Values that can be written to the field `APBCDIV`"]
        pub enum APBCDIVW {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl APBCDIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    APBCDIVW::DIV1 => 0,
                    APBCDIVW::DIV2 => 1,
                    APBCDIVW::DIV4 => 2,
                    APBCDIVW::DIV8 => 3,
                    APBCDIVW::DIV16 => 4,
                    APBCDIVW::DIV32 => 5,
                    APBCDIVW::DIV64 => 6,
                    APBCDIVW::DIV128 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _APBCDIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _APBCDIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: APBCDIVW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Divide by 1"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV1)
            }
            #[doc = "Divide by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV2)
            }
            #[doc = "Divide by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV4)
            }
            #[doc = "Divide by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV8)
            }
            #[doc = "Divide by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV16)
            }
            #[doc = "Divide by 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV32)
            }
            #[doc = "Divide by 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV64)
            }
            #[doc = "Divide by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV128)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:2 - APBC Prescaler Selection"]
            #[inline(always)]
            pub fn apbcdiv(&self) -> APBCDIVR {
                APBCDIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - APBC Prescaler Selection"]
            #[inline(always)]
            pub fn apbcdiv(&mut self) -> _APBCDIVW {
                _APBCDIVW { w: self }
            }
        }
    }
    #[doc = "CPU Clock Select"]
    pub struct CPUSEL {
        register: VolatileCell<u8>,
    }
    #[doc = "CPU Clock Select"]
    pub mod cpusel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CPUSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CPUDIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPUDIVR {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl CPUDIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CPUDIVR::DIV1 => 0,
                    CPUDIVR::DIV2 => 1,
                    CPUDIVR::DIV4 => 2,
                    CPUDIVR::DIV8 => 3,
                    CPUDIVR::DIV16 => 4,
                    CPUDIVR::DIV32 => 5,
                    CPUDIVR::DIV64 => 6,
                    CPUDIVR::DIV128 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CPUDIVR {
                match value {
                    0 => CPUDIVR::DIV1,
                    1 => CPUDIVR::DIV2,
                    2 => CPUDIVR::DIV4,
                    3 => CPUDIVR::DIV8,
                    4 => CPUDIVR::DIV16,
                    5 => CPUDIVR::DIV32,
                    6 => CPUDIVR::DIV64,
                    7 => CPUDIVR::DIV128,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CPUDIVR::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CPUDIVR::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CPUDIVR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == CPUDIVR::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == CPUDIVR::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == CPUDIVR::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == CPUDIVR::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == CPUDIVR::DIV128
            }
        }
        #[doc = "Values that can be written to the field `CPUDIV`"]
        pub enum CPUDIVW {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl CPUDIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CPUDIVW::DIV1 => 0,
                    CPUDIVW::DIV2 => 1,
                    CPUDIVW::DIV4 => 2,
                    CPUDIVW::DIV8 => 3,
                    CPUDIVW::DIV16 => 4,
                    CPUDIVW::DIV32 => 5,
                    CPUDIVW::DIV64 => 6,
                    CPUDIVW::DIV128 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPUDIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPUDIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CPUDIVW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Divide by 1"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV1)
            }
            #[doc = "Divide by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV2)
            }
            #[doc = "Divide by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV4)
            }
            #[doc = "Divide by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV8)
            }
            #[doc = "Divide by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV16)
            }
            #[doc = "Divide by 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV32)
            }
            #[doc = "Divide by 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV64)
            }
            #[doc = "Divide by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV128)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:2 - CPU Prescaler Selection"]
            #[inline(always)]
            pub fn cpudiv(&self) -> CPUDIVR {
                CPUDIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - CPU Prescaler Selection"]
            #[inline(always)]
            pub fn cpudiv(&mut self) -> _CPUDIVW {
                _CPUDIVW { w: self }
            }
        }
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CFDENR {
            bits: bool,
        }
        impl CFDENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BKUPCLKR {
            bits: bool,
        }
        impl BKUPCLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFDENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BKUPCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BKUPCLKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 2 - Clock Failure Detector Enable"]
            #[inline(always)]
            pub fn cfden(&self) -> CFDENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CFDENR { bits }
            }
            #[doc = "Bit 4 - Backup Clock Select"]
            #[inline(always)]
            pub fn bkupclk(&self) -> BKUPCLKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                BKUPCLKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 2 - Clock Failure Detector Enable"]
            #[inline(always)]
            pub fn cfden(&mut self) -> _CFDENW {
                _CFDENW { w: self }
            }
            #[doc = "Bit 4 - Backup Clock Select"]
            #[inline(always)]
            pub fn bkupclk(&mut self) -> _BKUPCLKW {
                _BKUPCLKW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKRDYR {
            bits: bool,
        }
        impl CKRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CFDR {
            bits: bool,
        }
        impl CFDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Clock Ready Interrupt Enable"]
            #[inline(always)]
            pub fn ckrdy(&self) -> CKRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CKRDYR { bits }
            }
            #[doc = "Bit 1 - Clock Failure Detector Interrupt Enable"]
            #[inline(always)]
            pub fn cfd(&self) -> CFDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CFDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Clock Ready Interrupt Enable"]
            #[inline(always)]
            pub fn ckrdy(&mut self) -> _CKRDYW {
                _CKRDYW { w: self }
            }
            #[doc = "Bit 1 - Clock Failure Detector Interrupt Enable"]
            #[inline(always)]
            pub fn cfd(&mut self) -> _CFDW {
                _CFDW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKRDYR {
            bits: bool,
        }
        impl CKRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CFDR {
            bits: bool,
        }
        impl CFDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Clock Ready Interrupt Enable"]
            #[inline(always)]
            pub fn ckrdy(&self) -> CKRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CKRDYR { bits }
            }
            #[doc = "Bit 1 - Clock Failure Detector Interrupt Enable"]
            #[inline(always)]
            pub fn cfd(&self) -> CFDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CFDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Clock Ready Interrupt Enable"]
            #[inline(always)]
            pub fn ckrdy(&mut self) -> _CKRDYW {
                _CKRDYW { w: self }
            }
            #[doc = "Bit 1 - Clock Failure Detector Interrupt Enable"]
            #[inline(always)]
            pub fn cfd(&mut self) -> _CFDW {
                _CFDW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKRDYR {
            bits: bool,
        }
        impl CKRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CFDR {
            bits: bool,
        }
        impl CFDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Clock Ready"]
            #[inline(always)]
            pub fn ckrdy(&self) -> CKRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CKRDYR { bits }
            }
            #[doc = "Bit 1 - Clock Failure Detector"]
            #[inline(always)]
            pub fn cfd(&self) -> CFDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CFDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Clock Ready"]
            #[inline(always)]
            pub fn ckrdy(&mut self) -> _CKRDYW {
                _CKRDYW { w: self }
            }
            #[doc = "Bit 1 - Clock Failure Detector"]
            #[inline(always)]
            pub fn cfd(&mut self) -> _CFDW {
                _CFDW { w: self }
            }
        }
    }
    #[doc = "Reset Cause"]
    pub struct RCAUSE {
        register: VolatileCell<u8>,
    }
    #[doc = "Reset Cause"]
    pub mod rcause {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::RCAUSE {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PORR {
            bits: bool,
        }
        impl PORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD12R {
            bits: bool,
        }
        impl BOD12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33R {
            bits: bool,
        }
        impl BOD33R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTR {
            bits: bool,
        }
        impl EXTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDTR {
            bits: bool,
        }
        impl WDTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYSTR {
            bits: bool,
        }
        impl SYSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Power On Reset"]
            #[inline(always)]
            pub fn por(&self) -> PORR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                PORR { bits }
            }
            #[doc = "Bit 1 - Brown Out 12 Detector Reset"]
            #[inline(always)]
            pub fn bod12(&self) -> BOD12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                BOD12R { bits }
            }
            #[doc = "Bit 2 - Brown Out 33 Detector Reset"]
            #[inline(always)]
            pub fn bod33(&self) -> BOD33R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                BOD33R { bits }
            }
            #[doc = "Bit 4 - External Reset"]
            #[inline(always)]
            pub fn ext(&self) -> EXTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EXTR { bits }
            }
            #[doc = "Bit 5 - Watchdog Reset"]
            #[inline(always)]
            pub fn wdt(&self) -> WDTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WDTR { bits }
            }
            #[doc = "Bit 6 - System Reset Request"]
            #[inline(always)]
            pub fn syst(&self) -> SYSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYSTR { bits }
            }
        }
    }
    #[doc = "Sleep Mode"]
    pub struct SLEEP {
        register: VolatileCell<u8>,
    }
    #[doc = "Sleep Mode"]
    pub mod sleep {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::SLEEP {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `IDLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDLER {
            #[doc = "The CPU clock domain is stopped"]
            CPU,
            #[doc = "The CPU and AHB clock domains are stopped"]
            AHB,
            #[doc = "The CPU, AHB and APB clock domains are stopped"]
            APB,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl IDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    IDLER::CPU => 0,
                    IDLER::AHB => 1,
                    IDLER::APB => 2,
                    IDLER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> IDLER {
                match value {
                    0 => IDLER::CPU,
                    1 => IDLER::AHB,
                    2 => IDLER::APB,
                    i => IDLER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `CPU`"]
            #[inline(always)]
            pub fn is_cpu(&self) -> bool {
                *self == IDLER::CPU
            }
            #[doc = "Checks if the value of the field is `AHB`"]
            #[inline(always)]
            pub fn is_ahb(&self) -> bool {
                *self == IDLER::AHB
            }
            #[doc = "Checks if the value of the field is `APB`"]
            #[inline(always)]
            pub fn is_apb(&self) -> bool {
                *self == IDLER::APB
            }
        }
        #[doc = "Values that can be written to the field `IDLE`"]
        pub enum IDLEW {
            #[doc = "The CPU clock domain is stopped"]
            CPU,
            #[doc = "The CPU and AHB clock domains are stopped"]
            AHB,
            #[doc = "The CPU, AHB and APB clock domains are stopped"]
            APB,
        }
        impl IDLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IDLEW::CPU => 0,
                    IDLEW::AHB => 1,
                    IDLEW::APB => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IDLEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "The CPU clock domain is stopped"]
            #[inline(always)]
            pub fn cpu(self) -> &'a mut W {
                self.variant(IDLEW::CPU)
            }
            #[doc = "The CPU and AHB clock domains are stopped"]
            #[inline(always)]
            pub fn ahb(self) -> &'a mut W {
                self.variant(IDLEW::AHB)
            }
            #[doc = "The CPU, AHB and APB clock domains are stopped"]
            #[inline(always)]
            pub fn apb(self) -> &'a mut W {
                self.variant(IDLEW::APB)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:1 - Idle Mode Configuration"]
            #[inline(always)]
            pub fn idle(&self) -> IDLER {
                IDLER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Idle Mode Configuration"]
            #[inline(always)]
            pub fn idle(&mut self) -> _IDLEW {
                _IDLEW { w: self }
            }
        }
    }
}
#[doc = "Power Manager"]
pub struct PM {
    register_block: pm::RegisterBlock,
}
impl Deref for PM {
    type Target = pm::RegisterBlock;
    fn deref(&self) -> &pm::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Port Module"]
pub const PORT: Peripheral<PORT> = unsafe { Peripheral::new(1090536448) };
#[doc = "Port Module"]
pub mod port {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Data Direction"]
        pub dir0: DIR,
        #[doc = "0x04 - Data Direction Clear"]
        pub dirclr0: DIRCLR,
        #[doc = "0x08 - Data Direction Set"]
        pub dirset0: DIRSET,
        #[doc = "0x0c - Data Direction Toggle"]
        pub dirtgl0: DIRTGL,
        #[doc = "0x10 - Data Output Value"]
        pub out0: OUT,
        #[doc = "0x14 - Data Output Value Clear"]
        pub outclr0: OUTCLR,
        #[doc = "0x18 - Data Output Value Set"]
        pub outset0: OUTSET,
        #[doc = "0x1c - Data Output Value Toggle"]
        pub outtgl0: OUTTGL,
        #[doc = "0x20 - Data Input Value"]
        pub in0: IN,
        #[doc = "0x24 - Control"]
        pub ctrl0: CTRL,
        #[doc = "0x28 - Write Configuration"]
        pub wrconfig0: WRCONFIG,
        _reserved0: [u8; 4usize],
        #[doc = "0x30 - Peripheral Multiplexing n - Group 0"]
        pub pmux0_0: PMUX0_,
        #[doc = "0x31 - Peripheral Multiplexing n - Group 0"]
        pub pmux0_1: PMUX0_,
        #[doc = "0x32 - Peripheral Multiplexing n - Group 0"]
        pub pmux0_2: PMUX0_,
        #[doc = "0x33 - Peripheral Multiplexing n - Group 0"]
        pub pmux0_3: PMUX0_,
        #[doc = "0x34 - Peripheral Multiplexing n - Group 0"]
        pub pmux0_4: PMUX0_,
        #[doc = "0x35 - Peripheral Multiplexing n - Group 0"]
        pub pmux0_5: PMUX0_,
        #[doc = "0x36 - Peripheral Multiplexing n - Group 0"]
        pub pmux0_6: PMUX0_,
        #[doc = "0x37 - Peripheral Multiplexing n - Group 0"]
        pub pmux0_7: PMUX0_,
        #[doc = "0x38 - Peripheral Multiplexing n - Group 0"]
        pub pmux0_8: PMUX0_,
        #[doc = "0x39 - Peripheral Multiplexing n - Group 0"]
        pub pmux0_9: PMUX0_,
        #[doc = "0x3a - Peripheral Multiplexing n - Group 0"]
        pub pmux0_10: PMUX0_,
        #[doc = "0x3b - Peripheral Multiplexing n - Group 0"]
        pub pmux0_11: PMUX0_,
        #[doc = "0x3c - Peripheral Multiplexing n - Group 0"]
        pub pmux0_12: PMUX0_,
        #[doc = "0x3d - Peripheral Multiplexing n - Group 0"]
        pub pmux0_13: PMUX0_,
        #[doc = "0x3e - Peripheral Multiplexing n - Group 0"]
        pub pmux0_14: PMUX0_,
        #[doc = "0x3f - Peripheral Multiplexing n - Group 0"]
        pub pmux0_15: PMUX0_,
        #[doc = "0x40 - Pin Configuration n - Group 0"]
        pub pincfg0_0: PINCFG0_,
        #[doc = "0x41 - Pin Configuration n - Group 0"]
        pub pincfg0_1: PINCFG0_,
        #[doc = "0x42 - Pin Configuration n - Group 0"]
        pub pincfg0_2: PINCFG0_,
        #[doc = "0x43 - Pin Configuration n - Group 0"]
        pub pincfg0_3: PINCFG0_,
        #[doc = "0x44 - Pin Configuration n - Group 0"]
        pub pincfg0_4: PINCFG0_,
        #[doc = "0x45 - Pin Configuration n - Group 0"]
        pub pincfg0_5: PINCFG0_,
        #[doc = "0x46 - Pin Configuration n - Group 0"]
        pub pincfg0_6: PINCFG0_,
        #[doc = "0x47 - Pin Configuration n - Group 0"]
        pub pincfg0_7: PINCFG0_,
        #[doc = "0x48 - Pin Configuration n - Group 0"]
        pub pincfg0_8: PINCFG0_,
        #[doc = "0x49 - Pin Configuration n - Group 0"]
        pub pincfg0_9: PINCFG0_,
        #[doc = "0x4a - Pin Configuration n - Group 0"]
        pub pincfg0_10: PINCFG0_,
        #[doc = "0x4b - Pin Configuration n - Group 0"]
        pub pincfg0_11: PINCFG0_,
        #[doc = "0x4c - Pin Configuration n - Group 0"]
        pub pincfg0_12: PINCFG0_,
        #[doc = "0x4d - Pin Configuration n - Group 0"]
        pub pincfg0_13: PINCFG0_,
        #[doc = "0x4e - Pin Configuration n - Group 0"]
        pub pincfg0_14: PINCFG0_,
        #[doc = "0x4f - Pin Configuration n - Group 0"]
        pub pincfg0_15: PINCFG0_,
        #[doc = "0x50 - Pin Configuration n - Group 0"]
        pub pincfg0_16: PINCFG0_,
        #[doc = "0x51 - Pin Configuration n - Group 0"]
        pub pincfg0_17: PINCFG0_,
        #[doc = "0x52 - Pin Configuration n - Group 0"]
        pub pincfg0_18: PINCFG0_,
        #[doc = "0x53 - Pin Configuration n - Group 0"]
        pub pincfg0_19: PINCFG0_,
        #[doc = "0x54 - Pin Configuration n - Group 0"]
        pub pincfg0_20: PINCFG0_,
        #[doc = "0x55 - Pin Configuration n - Group 0"]
        pub pincfg0_21: PINCFG0_,
        #[doc = "0x56 - Pin Configuration n - Group 0"]
        pub pincfg0_22: PINCFG0_,
        #[doc = "0x57 - Pin Configuration n - Group 0"]
        pub pincfg0_23: PINCFG0_,
        #[doc = "0x58 - Pin Configuration n - Group 0"]
        pub pincfg0_24: PINCFG0_,
        #[doc = "0x59 - Pin Configuration n - Group 0"]
        pub pincfg0_25: PINCFG0_,
        #[doc = "0x5a - Pin Configuration n - Group 0"]
        pub pincfg0_26: PINCFG0_,
        #[doc = "0x5b - Pin Configuration n - Group 0"]
        pub pincfg0_27: PINCFG0_,
        #[doc = "0x5c - Pin Configuration n - Group 0"]
        pub pincfg0_28: PINCFG0_,
        #[doc = "0x5d - Pin Configuration n - Group 0"]
        pub pincfg0_29: PINCFG0_,
        #[doc = "0x5e - Pin Configuration n - Group 0"]
        pub pincfg0_30: PINCFG0_,
        #[doc = "0x5f - Pin Configuration n - Group 0"]
        pub pincfg0_31: PINCFG0_,
        _reserved1: [u8; 32usize],
        #[doc = "0x80 - Data Direction"]
        pub dir1: DIR,
        #[doc = "0x84 - Data Direction Clear"]
        pub dirclr1: DIRCLR,
        #[doc = "0x88 - Data Direction Set"]
        pub dirset1: DIRSET,
        #[doc = "0x8c - Data Direction Toggle"]
        pub dirtgl1: DIRTGL,
        #[doc = "0x90 - Data Output Value"]
        pub out1: OUT,
        #[doc = "0x94 - Data Output Value Clear"]
        pub outclr1: OUTCLR,
        #[doc = "0x98 - Data Output Value Set"]
        pub outset1: OUTSET,
        #[doc = "0x9c - Data Output Value Toggle"]
        pub outtgl1: OUTTGL,
        #[doc = "0xa0 - Data Input Value"]
        pub in1: IN,
        #[doc = "0xa4 - Control"]
        pub ctrl1: CTRL,
        #[doc = "0xa8 - Write Configuration"]
        pub wrconfig1: WRCONFIG,
        _reserved2: [u8; 4usize],
        #[doc = "0xb0 - Peripheral Multiplexing n - Group 1"]
        pub pmux1_0: PMUX1_,
        #[doc = "0xb4 - Peripheral Multiplexing n - Group 1"]
        pub pmux1_4: PMUX1_,
        #[doc = "0xb8 - Peripheral Multiplexing n - Group 1"]
        pub pmux1_8: PMUX1_,
        #[doc = "0xbc - Peripheral Multiplexing n - Group 1"]
        pub pmux1_12: PMUX1_,
        #[doc = "0xc0 - Pin Configuration n - Group 1"]
        pub pincfg1_0: PINCFG1_,
        #[doc = "0xc4 - Pin Configuration n - Group 1"]
        pub pincfg1_4: PINCFG1_,
        #[doc = "0xc8 - Pin Configuration n - Group 1"]
        pub pincfg1_8: PINCFG1_,
        #[doc = "0xcc - Pin Configuration n - Group 1"]
        pub pincfg1_12: PINCFG1_,
        #[doc = "0xd0 - Pin Configuration n - Group 1"]
        pub pincfg1_16: PINCFG1_,
        #[doc = "0xd4 - Pin Configuration n - Group 1"]
        pub pincfg1_20: PINCFG1_,
        #[doc = "0xd8 - Pin Configuration n - Group 1"]
        pub pincfg1_24: PINCFG1_,
        #[doc = "0xdc - Pin Configuration n - Group 1"]
        pub pincfg1_28: PINCFG1_,
        _reserved3: [u8; 32usize],
        #[doc = "0x100 - Data Direction"]
        pub dir2: DIR,
        #[doc = "0x104 - Data Direction Clear"]
        pub dirclr2: DIRCLR,
        #[doc = "0x108 - Data Direction Set"]
        pub dirset2: DIRSET,
        #[doc = "0x10c - Data Direction Toggle"]
        pub dirtgl2: DIRTGL,
        #[doc = "0x110 - Data Output Value"]
        pub out2: OUT,
        #[doc = "0x114 - Data Output Value Clear"]
        pub outclr2: OUTCLR,
        #[doc = "0x118 - Data Output Value Set"]
        pub outset2: OUTSET,
        #[doc = "0x11c - Data Output Value Toggle"]
        pub outtgl2: OUTTGL,
        #[doc = "0x120 - Data Input Value"]
        pub in2: IN,
        #[doc = "0x124 - Control"]
        pub ctrl2: CTRL,
        #[doc = "0x128 - Write Configuration"]
        pub wrconfig2: WRCONFIG,
        _reserved4: [u8; 4usize],
        #[doc = "0x130 - Peripheral Multiplexing n - Group 2"]
        pub pmux2_0: PMUX2_,
        #[doc = "0x134 - Peripheral Multiplexing n - Group 2"]
        pub pmux2_4: PMUX2_,
        #[doc = "0x138 - Peripheral Multiplexing n - Group 2"]
        pub pmux2_8: PMUX2_,
        #[doc = "0x13c - Peripheral Multiplexing n - Group 2"]
        pub pmux2_12: PMUX2_,
        #[doc = "0x140 - Pin Configuration n - Group 2"]
        pub pincfg2_0: PINCFG2_,
        #[doc = "0x144 - Pin Configuration n - Group 2"]
        pub pincfg2_4: PINCFG2_,
        #[doc = "0x148 - Pin Configuration n - Group 2"]
        pub pincfg2_8: PINCFG2_,
        #[doc = "0x14c - Pin Configuration n - Group 2"]
        pub pincfg2_12: PINCFG2_,
        #[doc = "0x150 - Pin Configuration n - Group 2"]
        pub pincfg2_16: PINCFG2_,
        #[doc = "0x154 - Pin Configuration n - Group 2"]
        pub pincfg2_20: PINCFG2_,
        #[doc = "0x158 - Pin Configuration n - Group 2"]
        pub pincfg2_24: PINCFG2_,
        #[doc = "0x15c - Pin Configuration n - Group 2"]
        pub pincfg2_28: PINCFG2_,
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _SAMPLINGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SAMPLINGW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Input Sampling Mode"]
            #[inline(always)]
            pub fn sampling(&mut self) -> _SAMPLINGW {
                _SAMPLINGW { w: self }
            }
        }
    }
    #[doc = "Data Direction"]
    pub struct DIR {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Direction"]
    pub mod dir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRR {
            bits: u32,
        }
        impl DIRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Direction"]
            #[inline(always)]
            pub fn dir(&self) -> DIRR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DIRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Direction"]
            #[inline(always)]
            pub fn dir(&mut self) -> _DIRW {
                _DIRW { w: self }
            }
        }
    }
    #[doc = "Data Direction Clear"]
    pub struct DIRCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Direction Clear"]
    pub mod dirclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIRCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRCLRR {
            bits: u32,
        }
        impl DIRCLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRCLRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Direction Clear"]
            #[inline(always)]
            pub fn dirclr(&self) -> DIRCLRR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DIRCLRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Direction Clear"]
            #[inline(always)]
            pub fn dirclr(&mut self) -> _DIRCLRW {
                _DIRCLRW { w: self }
            }
        }
    }
    #[doc = "Data Direction Set"]
    pub struct DIRSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Direction Set"]
    pub mod dirset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIRSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRSETR {
            bits: u32,
        }
        impl DIRSETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRSETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRSETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Direction Set"]
            #[inline(always)]
            pub fn dirset(&self) -> DIRSETR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DIRSETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Direction Set"]
            #[inline(always)]
            pub fn dirset(&mut self) -> _DIRSETW {
                _DIRSETW { w: self }
            }
        }
    }
    #[doc = "Data Direction Toggle"]
    pub struct DIRTGL {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Direction Toggle"]
    pub mod dirtgl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIRTGL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRTGLR {
            bits: u32,
        }
        impl DIRTGLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRTGLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRTGLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Direction Toggle"]
            #[inline(always)]
            pub fn dirtgl(&self) -> DIRTGLR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DIRTGLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Direction Toggle"]
            #[inline(always)]
            pub fn dirtgl(&mut self) -> _DIRTGLW {
                _DIRTGLW { w: self }
            }
        }
    }
    #[doc = "Data Input Value"]
    pub struct IN {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Input Value"]
    pub mod in_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::IN {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct INR {
            bits: u32,
        }
        impl INR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Input Value"]
            #[inline(always)]
            pub fn in_(&self) -> INR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                INR { bits }
            }
        }
    }
    #[doc = "Data Output Value"]
    pub struct OUT {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Output Value"]
    pub mod out {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OUTR {
            bits: u32,
        }
        impl OUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Output Value"]
            #[inline(always)]
            pub fn out(&self) -> OUTR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OUTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Output Value"]
            #[inline(always)]
            pub fn out(&mut self) -> _OUTW {
                _OUTW { w: self }
            }
        }
    }
    #[doc = "Data Output Value Clear"]
    pub struct OUTCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Output Value Clear"]
    pub mod outclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OUTCLRR {
            bits: u32,
        }
        impl OUTCLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTCLRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Output Value Clear"]
            #[inline(always)]
            pub fn outclr(&self) -> OUTCLRR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OUTCLRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Output Value Clear"]
            #[inline(always)]
            pub fn outclr(&mut self) -> _OUTCLRW {
                _OUTCLRW { w: self }
            }
        }
    }
    #[doc = "Data Output Value Set"]
    pub struct OUTSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Output Value Set"]
    pub mod outset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OUTSETR {
            bits: u32,
        }
        impl OUTSETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTSETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTSETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Output Value Set"]
            #[inline(always)]
            pub fn outset(&self) -> OUTSETR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OUTSETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Output Value Set"]
            #[inline(always)]
            pub fn outset(&mut self) -> _OUTSETW {
                _OUTSETW { w: self }
            }
        }
    }
    #[doc = "Data Output Value Toggle"]
    pub struct OUTTGL {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Output Value Toggle"]
    pub mod outtgl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTTGL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OUTTGLR {
            bits: u32,
        }
        impl OUTTGLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTTGLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTTGLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Output Value Toggle"]
            #[inline(always)]
            pub fn outtgl(&self) -> OUTTGLR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OUTTGLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Output Value Toggle"]
            #[inline(always)]
            pub fn outtgl(&mut self) -> _OUTTGLW {
                _OUTTGLW { w: self }
            }
        }
    }
    #[doc = "Pin Configuration n - Group 0"]
    pub struct PINCFG0_ {
        register: VolatileCell<u8>,
    }
    #[doc = "Pin Configuration n - Group 0"]
    pub mod pincfg0_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::PINCFG0_ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PMUXENR {
            bits: bool,
        }
        impl PMUXENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INENR {
            bits: bool,
        }
        impl INENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PULLENR {
            bits: bool,
        }
        impl PULLENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMUXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMUXENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PULLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PULLENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRVSTRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRVSTRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral Multiplexer Enable"]
            #[inline(always)]
            pub fn pmuxen(&self) -> PMUXENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                PMUXENR { bits }
            }
            #[doc = "Bit 1 - Input Enable"]
            #[inline(always)]
            pub fn inen(&self) -> INENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                INENR { bits }
            }
            #[doc = "Bit 2 - Pull Enable"]
            #[inline(always)]
            pub fn pullen(&self) -> PULLENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                PULLENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral Multiplexer Enable"]
            #[inline(always)]
            pub fn pmuxen(&mut self) -> _PMUXENW {
                _PMUXENW { w: self }
            }
            #[doc = "Bit 1 - Input Enable"]
            #[inline(always)]
            pub fn inen(&mut self) -> _INENW {
                _INENW { w: self }
            }
            #[doc = "Bit 2 - Pull Enable"]
            #[inline(always)]
            pub fn pullen(&mut self) -> _PULLENW {
                _PULLENW { w: self }
            }
            #[doc = "Bit 6 - Output Driver Strength Selection"]
            #[inline(always)]
            pub fn drvstr(&mut self) -> _DRVSTRW {
                _DRVSTRW { w: self }
            }
        }
    }
    #[doc = "Pin Configuration n - Group 1"]
    pub struct PINCFG1_ {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin Configuration n - Group 1"]
    pub mod pincfg1_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINCFG1_ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pin Configuration n - Group 2"]
    pub struct PINCFG2_ {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin Configuration n - Group 2"]
    pub mod pincfg2_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINCFG2_ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Peripheral Multiplexing n - Group 0"]
    pub struct PMUX0_ {
        register: VolatileCell<u8>,
    }
    #[doc = "Peripheral Multiplexing n - Group 0"]
    pub mod pmux0_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::PMUX0_ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PMUXE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PMUXER {
            #[doc = "Peripheral function A selected"]
            A,
            #[doc = "Peripheral function B selected"]
            B,
            #[doc = "Peripheral function C selected"]
            C,
            #[doc = "Peripheral function D selected"]
            D,
            #[doc = "Peripheral function E selected"]
            E,
            #[doc = "Peripheral function F selected"]
            F,
            #[doc = "Peripheral function G selected"]
            G,
            #[doc = "Peripheral function H selected"]
            H,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PMUXER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    PMUXER::A => 0,
                    PMUXER::B => 1,
                    PMUXER::C => 2,
                    PMUXER::D => 3,
                    PMUXER::E => 4,
                    PMUXER::F => 5,
                    PMUXER::G => 6,
                    PMUXER::H => 7,
                    PMUXER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> PMUXER {
                match value {
                    0 => PMUXER::A,
                    1 => PMUXER::B,
                    2 => PMUXER::C,
                    3 => PMUXER::D,
                    4 => PMUXER::E,
                    5 => PMUXER::F,
                    6 => PMUXER::G,
                    7 => PMUXER::H,
                    i => PMUXER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `A`"]
            #[inline(always)]
            pub fn is_a(&self) -> bool {
                *self == PMUXER::A
            }
            #[doc = "Checks if the value of the field is `B`"]
            #[inline(always)]
            pub fn is_b(&self) -> bool {
                *self == PMUXER::B
            }
            #[doc = "Checks if the value of the field is `C`"]
            #[inline(always)]
            pub fn is_c(&self) -> bool {
                *self == PMUXER::C
            }
            #[doc = "Checks if the value of the field is `D`"]
            #[inline(always)]
            pub fn is_d(&self) -> bool {
                *self == PMUXER::D
            }
            #[doc = "Checks if the value of the field is `E`"]
            #[inline(always)]
            pub fn is_e(&self) -> bool {
                *self == PMUXER::E
            }
            #[doc = "Checks if the value of the field is `F`"]
            #[inline(always)]
            pub fn is_f(&self) -> bool {
                *self == PMUXER::F
            }
            #[doc = "Checks if the value of the field is `G`"]
            #[inline(always)]
            pub fn is_g(&self) -> bool {
                *self == PMUXER::G
            }
            #[doc = "Checks if the value of the field is `H`"]
            #[inline(always)]
            pub fn is_h(&self) -> bool {
                *self == PMUXER::H
            }
        }
        #[doc = "Possible values of the field `PMUXO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PMUXOR {
            #[doc = "Peripheral function A selected"]
            A,
            #[doc = "Peripheral function B selected"]
            B,
            #[doc = "Peripheral function C selected"]
            C,
            #[doc = "Peripheral function D selected"]
            D,
            #[doc = "Peripheral function E selected"]
            E,
            #[doc = "Peripheral function F selected"]
            F,
            #[doc = "Peripheral function G selected"]
            G,
            #[doc = "Peripheral function H selected"]
            H,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PMUXOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    PMUXOR::A => 0,
                    PMUXOR::B => 1,
                    PMUXOR::C => 2,
                    PMUXOR::D => 3,
                    PMUXOR::E => 4,
                    PMUXOR::F => 5,
                    PMUXOR::G => 6,
                    PMUXOR::H => 7,
                    PMUXOR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> PMUXOR {
                match value {
                    0 => PMUXOR::A,
                    1 => PMUXOR::B,
                    2 => PMUXOR::C,
                    3 => PMUXOR::D,
                    4 => PMUXOR::E,
                    5 => PMUXOR::F,
                    6 => PMUXOR::G,
                    7 => PMUXOR::H,
                    i => PMUXOR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `A`"]
            #[inline(always)]
            pub fn is_a(&self) -> bool {
                *self == PMUXOR::A
            }
            #[doc = "Checks if the value of the field is `B`"]
            #[inline(always)]
            pub fn is_b(&self) -> bool {
                *self == PMUXOR::B
            }
            #[doc = "Checks if the value of the field is `C`"]
            #[inline(always)]
            pub fn is_c(&self) -> bool {
                *self == PMUXOR::C
            }
            #[doc = "Checks if the value of the field is `D`"]
            #[inline(always)]
            pub fn is_d(&self) -> bool {
                *self == PMUXOR::D
            }
            #[doc = "Checks if the value of the field is `E`"]
            #[inline(always)]
            pub fn is_e(&self) -> bool {
                *self == PMUXOR::E
            }
            #[doc = "Checks if the value of the field is `F`"]
            #[inline(always)]
            pub fn is_f(&self) -> bool {
                *self == PMUXOR::F
            }
            #[doc = "Checks if the value of the field is `G`"]
            #[inline(always)]
            pub fn is_g(&self) -> bool {
                *self == PMUXOR::G
            }
            #[doc = "Checks if the value of the field is `H`"]
            #[inline(always)]
            pub fn is_h(&self) -> bool {
                *self == PMUXOR::H
            }
        }
        #[doc = "Values that can be written to the field `PMUXE`"]
        pub enum PMUXEW {
            #[doc = "Peripheral function A selected"]
            A,
            #[doc = "Peripheral function B selected"]
            B,
            #[doc = "Peripheral function C selected"]
            C,
            #[doc = "Peripheral function D selected"]
            D,
            #[doc = "Peripheral function E selected"]
            E,
            #[doc = "Peripheral function F selected"]
            F,
            #[doc = "Peripheral function G selected"]
            G,
            #[doc = "Peripheral function H selected"]
            H,
        }
        impl PMUXEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PMUXEW::A => 0,
                    PMUXEW::B => 1,
                    PMUXEW::C => 2,
                    PMUXEW::D => 3,
                    PMUXEW::E => 4,
                    PMUXEW::F => 5,
                    PMUXEW::G => 6,
                    PMUXEW::H => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMUXEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMUXEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PMUXEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Peripheral function A selected"]
            #[inline(always)]
            pub fn a(self) -> &'a mut W {
                self.variant(PMUXEW::A)
            }
            #[doc = "Peripheral function B selected"]
            #[inline(always)]
            pub fn b(self) -> &'a mut W {
                self.variant(PMUXEW::B)
            }
            #[doc = "Peripheral function C selected"]
            #[inline(always)]
            pub fn c(self) -> &'a mut W {
                self.variant(PMUXEW::C)
            }
            #[doc = "Peripheral function D selected"]
            #[inline(always)]
            pub fn d(self) -> &'a mut W {
                self.variant(PMUXEW::D)
            }
            #[doc = "Peripheral function E selected"]
            #[inline(always)]
            pub fn e(self) -> &'a mut W {
                self.variant(PMUXEW::E)
            }
            #[doc = "Peripheral function F selected"]
            #[inline(always)]
            pub fn f(self) -> &'a mut W {
                self.variant(PMUXEW::F)
            }
            #[doc = "Peripheral function G selected"]
            #[inline(always)]
            pub fn g(self) -> &'a mut W {
                self.variant(PMUXEW::G)
            }
            #[doc = "Peripheral function H selected"]
            #[inline(always)]
            pub fn h(self) -> &'a mut W {
                self.variant(PMUXEW::H)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PMUXO`"]
        pub enum PMUXOW {
            #[doc = "Peripheral function A selected"]
            A,
            #[doc = "Peripheral function B selected"]
            B,
            #[doc = "Peripheral function C selected"]
            C,
            #[doc = "Peripheral function D selected"]
            D,
            #[doc = "Peripheral function E selected"]
            E,
            #[doc = "Peripheral function F selected"]
            F,
            #[doc = "Peripheral function G selected"]
            G,
            #[doc = "Peripheral function H selected"]
            H,
        }
        impl PMUXOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PMUXOW::A => 0,
                    PMUXOW::B => 1,
                    PMUXOW::C => 2,
                    PMUXOW::D => 3,
                    PMUXOW::E => 4,
                    PMUXOW::F => 5,
                    PMUXOW::G => 6,
                    PMUXOW::H => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMUXOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMUXOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PMUXOW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Peripheral function A selected"]
            #[inline(always)]
            pub fn a(self) -> &'a mut W {
                self.variant(PMUXOW::A)
            }
            #[doc = "Peripheral function B selected"]
            #[inline(always)]
            pub fn b(self) -> &'a mut W {
                self.variant(PMUXOW::B)
            }
            #[doc = "Peripheral function C selected"]
            #[inline(always)]
            pub fn c(self) -> &'a mut W {
                self.variant(PMUXOW::C)
            }
            #[doc = "Peripheral function D selected"]
            #[inline(always)]
            pub fn d(self) -> &'a mut W {
                self.variant(PMUXOW::D)
            }
            #[doc = "Peripheral function E selected"]
            #[inline(always)]
            pub fn e(self) -> &'a mut W {
                self.variant(PMUXOW::E)
            }
            #[doc = "Peripheral function F selected"]
            #[inline(always)]
            pub fn f(self) -> &'a mut W {
                self.variant(PMUXOW::F)
            }
            #[doc = "Peripheral function G selected"]
            #[inline(always)]
            pub fn g(self) -> &'a mut W {
                self.variant(PMUXOW::G)
            }
            #[doc = "Peripheral function H selected"]
            #[inline(always)]
            pub fn h(self) -> &'a mut W {
                self.variant(PMUXOW::H)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:3 - Peripheral Multiplexing Even"]
            #[inline(always)]
            pub fn pmuxe(&self) -> PMUXER {
                PMUXER::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bits 4:7 - Peripheral Multiplexing Odd"]
            #[inline(always)]
            pub fn pmuxo(&self) -> PMUXOR {
                PMUXOR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Peripheral Multiplexing Even"]
            #[inline(always)]
            pub fn pmuxe(&mut self) -> _PMUXEW {
                _PMUXEW { w: self }
            }
            #[doc = "Bits 4:7 - Peripheral Multiplexing Odd"]
            #[inline(always)]
            pub fn pmuxo(&mut self) -> _PMUXOW {
                _PMUXOW { w: self }
            }
        }
    }
    #[doc = "Peripheral Multiplexing n - Group 1"]
    pub struct PMUX1_ {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Multiplexing n - Group 1"]
    pub mod pmux1_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PMUX1_ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Peripheral Multiplexing n - Group 2"]
    pub struct PMUX2_ {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Multiplexing n - Group 2"]
    pub mod pmux2_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PMUX2_ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Write Configuration"]
    pub struct WRCONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "Write Configuration"]
    pub mod wrconfig {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WRCONFIG {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINMASKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINMASKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMUXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMUXENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PULLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PULLENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRVSTRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRVSTRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMUXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMUXW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRPMUXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRPMUXW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRPINCFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRPINCFGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HWSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HWSELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Pin Mask for Multiple Pin Configuration"]
            #[inline(always)]
            pub fn pinmask(&mut self) -> _PINMASKW {
                _PINMASKW { w: self }
            }
            #[doc = "Bit 16 - Peripheral Multiplexer Enable"]
            #[inline(always)]
            pub fn pmuxen(&mut self) -> _PMUXENW {
                _PMUXENW { w: self }
            }
            #[doc = "Bit 17 - Input Enable"]
            #[inline(always)]
            pub fn inen(&mut self) -> _INENW {
                _INENW { w: self }
            }
            #[doc = "Bit 18 - Pull Enable"]
            #[inline(always)]
            pub fn pullen(&mut self) -> _PULLENW {
                _PULLENW { w: self }
            }
            #[doc = "Bit 22 - Output Driver Strength Selection"]
            #[inline(always)]
            pub fn drvstr(&mut self) -> _DRVSTRW {
                _DRVSTRW { w: self }
            }
            #[doc = "Bits 24:27 - Peripheral Multiplexing"]
            #[inline(always)]
            pub fn pmux(&mut self) -> _PMUXW {
                _PMUXW { w: self }
            }
            #[doc = "Bit 28 - Write PMUX"]
            #[inline(always)]
            pub fn wrpmux(&mut self) -> _WRPMUXW {
                _WRPMUXW { w: self }
            }
            #[doc = "Bit 30 - Write PINCFG"]
            #[inline(always)]
            pub fn wrpincfg(&mut self) -> _WRPINCFGW {
                _WRPINCFGW { w: self }
            }
            #[doc = "Bit 31 - Half-Word Select"]
            #[inline(always)]
            pub fn hwsel(&mut self) -> _HWSELW {
                _HWSELW { w: self }
            }
        }
    }
}
#[doc = "Port Module"]
pub struct PORT {
    register_block: port::RegisterBlock,
}
impl Deref for PORT {
    type Target = port::RegisterBlock;
    fn deref(&self) -> &port::RegisterBlock {
        &self.register_block
    }
}
#[doc = "System Control"]
pub const SYSCTRL: Peripheral<SYSCTRL> = unsafe { Peripheral::new(1073743872) };
#[doc = "System Control"]
pub mod sysctrl {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x04 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x08 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        #[doc = "0x0c - Power and Clocks Status"]
        pub pclksr: PCLKSR,
        #[doc = "0x10 - External Multipurpose Crystal Oscillator (XOSC) Control"]
        pub xosc: XOSC,
        _reserved0: [u8; 2usize],
        #[doc = "0x14 - 32kHz External Crystal Oscillator (XOSC32K) Control"]
        pub xosc32k: XOSC32K,
        _reserved1: [u8; 2usize],
        #[doc = "0x18 - 32kHz Internal Oscillator (OSC32K) Control"]
        pub osc32k: OSC32K,
        #[doc = "0x1c - 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control"]
        pub osculp32k: OSCULP32K,
        _reserved2: [u8; 3usize],
        #[doc = "0x20 - 8MHz Internal Oscillator (OSC8M) Control"]
        pub osc8m: OSC8M,
        #[doc = "0x24 - DFLL48M Control"]
        pub dfllctrl: DFLLCTRL,
        _reserved3: [u8; 2usize],
        #[doc = "0x28 - DFLL48M Value"]
        pub dfllval: DFLLVAL,
        #[doc = "0x2c - DFLL48M Multiplier"]
        pub dfllmul: DFLLMUL,
        #[doc = "0x30 - DFLL48M Synchronization"]
        pub dfllsync: DFLLSYNC,
        _reserved4: [u8; 3usize],
        #[doc = "0x34 - 3.3V Brown-Out Detector (BOD33) Control"]
        pub bod33: BOD33,
        _reserved5: [u8; 8usize],
        #[doc = "0x40 - Voltage References System (VREF) Control"]
        pub vref: VREF,
        #[doc = "0x44 - DPLL Control A"]
        pub dpllctrla: DPLLCTRLA,
        _reserved6: [u8; 3usize],
        #[doc = "0x48 - DPLL Ratio Control"]
        pub dpllratio: DPLLRATIO,
        #[doc = "0x4c - DPLL Control B"]
        pub dpllctrlb: DPLLCTRLB,
        #[doc = "0x50 - DPLL Status"]
        pub dpllstatus: DPLLSTATUS,
    }
    #[doc = "3.3V Brown-Out Detector (BOD33) Control"]
    pub struct BOD33 {
        register: VolatileCell<u32>,
    }
    #[doc = "3.3V Brown-Out Detector (BOD33) Control"]
    pub mod bod33 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BOD33 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HYSTR {
            bits: bool,
        }
        impl HYSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `ACTION`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACTIONR {
            #[doc = "No action"]
            NONE,
            #[doc = "The BOD33 generates a reset"]
            RESET,
            #[doc = "The BOD33 generates an interrupt"]
            INTERRUPT,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl ACTIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    ACTIONR::NONE => 0,
                    ACTIONR::RESET => 1,
                    ACTIONR::INTERRUPT => 2,
                    ACTIONR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> ACTIONR {
                match value {
                    0 => ACTIONR::NONE,
                    1 => ACTIONR::RESET,
                    2 => ACTIONR::INTERRUPT,
                    i => ACTIONR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == ACTIONR::NONE
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == ACTIONR::RESET
            }
            #[doc = "Checks if the value of the field is `INTERRUPT`"]
            #[inline(always)]
            pub fn is_interrupt(&self) -> bool {
                *self == ACTIONR::INTERRUPT
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODER {
            bits: bool,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CENR {
            bits: bool,
        }
        impl CENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `PSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PSELR {
            #[doc = "Divide clock by 2"]
            DIV2,
            #[doc = "Divide clock by 4"]
            DIV4,
            #[doc = "Divide clock by 8"]
            DIV8,
            #[doc = "Divide clock by 16"]
            DIV16,
            #[doc = "Divide clock by 32"]
            DIV32,
            #[doc = "Divide clock by 64"]
            DIV64,
            #[doc = "Divide clock by 128"]
            DIV128,
            #[doc = "Divide clock by 256"]
            DIV256,
            #[doc = "Divide clock by 512"]
            DIV512,
            #[doc = "Divide clock by 1024"]
            DIV1K,
            #[doc = "Divide clock by 2048"]
            DIV2K,
            #[doc = "Divide clock by 4096"]
            DIV4K,
            #[doc = "Divide clock by 8192"]
            DIV8K,
            #[doc = "Divide clock by 16384"]
            DIV16K,
            #[doc = "Divide clock by 32768"]
            DIV32K,
            #[doc = "Divide clock by 65536"]
            DIV64K,
        }
        impl PSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    PSELR::DIV2 => 0,
                    PSELR::DIV4 => 1,
                    PSELR::DIV8 => 2,
                    PSELR::DIV16 => 3,
                    PSELR::DIV32 => 4,
                    PSELR::DIV64 => 5,
                    PSELR::DIV128 => 6,
                    PSELR::DIV256 => 7,
                    PSELR::DIV512 => 8,
                    PSELR::DIV1K => 9,
                    PSELR::DIV2K => 10,
                    PSELR::DIV4K => 11,
                    PSELR::DIV8K => 12,
                    PSELR::DIV16K => 13,
                    PSELR::DIV32K => 14,
                    PSELR::DIV64K => 15,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> PSELR {
                match value {
                    0 => PSELR::DIV2,
                    1 => PSELR::DIV4,
                    2 => PSELR::DIV8,
                    3 => PSELR::DIV16,
                    4 => PSELR::DIV32,
                    5 => PSELR::DIV64,
                    6 => PSELR::DIV128,
                    7 => PSELR::DIV256,
                    8 => PSELR::DIV512,
                    9 => PSELR::DIV1K,
                    10 => PSELR::DIV2K,
                    11 => PSELR::DIV4K,
                    12 => PSELR::DIV8K,
                    13 => PSELR::DIV16K,
                    14 => PSELR::DIV32K,
                    15 => PSELR::DIV64K,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == PSELR::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == PSELR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == PSELR::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == PSELR::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == PSELR::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == PSELR::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == PSELR::DIV128
            }
            #[doc = "Checks if the value of the field is `DIV256`"]
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == PSELR::DIV256
            }
            #[doc = "Checks if the value of the field is `DIV512`"]
            #[inline(always)]
            pub fn is_div512(&self) -> bool {
                *self == PSELR::DIV512
            }
            #[doc = "Checks if the value of the field is `DIV1K`"]
            #[inline(always)]
            pub fn is_div1k(&self) -> bool {
                *self == PSELR::DIV1K
            }
            #[doc = "Checks if the value of the field is `DIV2K`"]
            #[inline(always)]
            pub fn is_div2k(&self) -> bool {
                *self == PSELR::DIV2K
            }
            #[doc = "Checks if the value of the field is `DIV4K`"]
            #[inline(always)]
            pub fn is_div4k(&self) -> bool {
                *self == PSELR::DIV4K
            }
            #[doc = "Checks if the value of the field is `DIV8K`"]
            #[inline(always)]
            pub fn is_div8k(&self) -> bool {
                *self == PSELR::DIV8K
            }
            #[doc = "Checks if the value of the field is `DIV16K`"]
            #[inline(always)]
            pub fn is_div16k(&self) -> bool {
                *self == PSELR::DIV16K
            }
            #[doc = "Checks if the value of the field is `DIV32K`"]
            #[inline(always)]
            pub fn is_div32k(&self) -> bool {
                *self == PSELR::DIV32K
            }
            #[doc = "Checks if the value of the field is `DIV64K`"]
            #[inline(always)]
            pub fn is_div64k(&self) -> bool {
                *self == PSELR::DIV64K
            }
        }
        #[doc = r" Value of the field"]
        pub struct LEVELR {
            bits: u8,
        }
        impl LEVELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACTION`"]
        pub enum ACTIONW {
            #[doc = "No action"]
            NONE,
            #[doc = "The BOD33 generates a reset"]
            RESET,
            #[doc = "The BOD33 generates an interrupt"]
            INTERRUPT,
        }
        impl ACTIONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ACTIONW::NONE => 0,
                    ACTIONW::RESET => 1,
                    ACTIONW::INTERRUPT => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACTIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACTIONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ACTIONW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No action"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(ACTIONW::NONE)
            }
            #[doc = "The BOD33 generates a reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(ACTIONW::RESET)
            }
            #[doc = "The BOD33 generates an interrupt"]
            #[inline(always)]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(ACTIONW::INTERRUPT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PSEL`"]
        pub enum PSELW {
            #[doc = "Divide clock by 2"]
            DIV2,
            #[doc = "Divide clock by 4"]
            DIV4,
            #[doc = "Divide clock by 8"]
            DIV8,
            #[doc = "Divide clock by 16"]
            DIV16,
            #[doc = "Divide clock by 32"]
            DIV32,
            #[doc = "Divide clock by 64"]
            DIV64,
            #[doc = "Divide clock by 128"]
            DIV128,
            #[doc = "Divide clock by 256"]
            DIV256,
            #[doc = "Divide clock by 512"]
            DIV512,
            #[doc = "Divide clock by 1024"]
            DIV1K,
            #[doc = "Divide clock by 2048"]
            DIV2K,
            #[doc = "Divide clock by 4096"]
            DIV4K,
            #[doc = "Divide clock by 8192"]
            DIV8K,
            #[doc = "Divide clock by 16384"]
            DIV16K,
            #[doc = "Divide clock by 32768"]
            DIV32K,
            #[doc = "Divide clock by 65536"]
            DIV64K,
        }
        impl PSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PSELW::DIV2 => 0,
                    PSELW::DIV4 => 1,
                    PSELW::DIV8 => 2,
                    PSELW::DIV16 => 3,
                    PSELW::DIV32 => 4,
                    PSELW::DIV64 => 5,
                    PSELW::DIV128 => 6,
                    PSELW::DIV256 => 7,
                    PSELW::DIV512 => 8,
                    PSELW::DIV1K => 9,
                    PSELW::DIV2K => 10,
                    PSELW::DIV4K => 11,
                    PSELW::DIV8K => 12,
                    PSELW::DIV16K => 13,
                    PSELW::DIV32K => 14,
                    PSELW::DIV64K => 15,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Divide clock by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PSELW::DIV2)
            }
            #[doc = "Divide clock by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PSELW::DIV4)
            }
            #[doc = "Divide clock by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PSELW::DIV8)
            }
            #[doc = "Divide clock by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PSELW::DIV16)
            }
            #[doc = "Divide clock by 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut W {
                self.variant(PSELW::DIV32)
            }
            #[doc = "Divide clock by 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(PSELW::DIV64)
            }
            #[doc = "Divide clock by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(PSELW::DIV128)
            }
            #[doc = "Divide clock by 256"]
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(PSELW::DIV256)
            }
            #[doc = "Divide clock by 512"]
            #[inline(always)]
            pub fn div512(self) -> &'a mut W {
                self.variant(PSELW::DIV512)
            }
            #[doc = "Divide clock by 1024"]
            #[inline(always)]
            pub fn div1k(self) -> &'a mut W {
                self.variant(PSELW::DIV1K)
            }
            #[doc = "Divide clock by 2048"]
            #[inline(always)]
            pub fn div2k(self) -> &'a mut W {
                self.variant(PSELW::DIV2K)
            }
            #[doc = "Divide clock by 4096"]
            #[inline(always)]
            pub fn div4k(self) -> &'a mut W {
                self.variant(PSELW::DIV4K)
            }
            #[doc = "Divide clock by 8192"]
            #[inline(always)]
            pub fn div8k(self) -> &'a mut W {
                self.variant(PSELW::DIV8K)
            }
            #[doc = "Divide clock by 16384"]
            #[inline(always)]
            pub fn div16k(self) -> &'a mut W {
                self.variant(PSELW::DIV16K)
            }
            #[doc = "Divide clock by 32768"]
            #[inline(always)]
            pub fn div32k(self) -> &'a mut W {
                self.variant(PSELW::DIV32K)
            }
            #[doc = "Divide clock by 65536"]
            #[inline(always)]
            pub fn div64k(self) -> &'a mut W {
                self.variant(PSELW::DIV64K)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LEVELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LEVELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Hysteresis"]
            #[inline(always)]
            pub fn hyst(&self) -> HYSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HYSTR { bits }
            }
            #[doc = "Bits 3:4 - BOD33 Action"]
            #[inline(always)]
            pub fn action(&self) -> ACTIONR {
                ACTIONR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 8 - Operation Mode"]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MODER { bits }
            }
            #[doc = "Bit 9 - Clock Enable"]
            #[inline(always)]
            pub fn cen(&self) -> CENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CENR { bits }
            }
            #[doc = "Bits 12:15 - Prescaler Select"]
            #[inline(always)]
            pub fn psel(&self) -> PSELR {
                PSELR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 16:21 - BOD33 Threshold Level"]
            #[inline(always)]
            pub fn level(&self) -> LEVELR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LEVELR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Hysteresis"]
            #[inline(always)]
            pub fn hyst(&mut self) -> _HYSTW {
                _HYSTW { w: self }
            }
            #[doc = "Bits 3:4 - BOD33 Action"]
            #[inline(always)]
            pub fn action(&mut self) -> _ACTIONW {
                _ACTIONW { w: self }
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 8 - Operation Mode"]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 9 - Clock Enable"]
            #[inline(always)]
            pub fn cen(&mut self) -> _CENW {
                _CENW { w: self }
            }
            #[doc = "Bits 12:15 - Prescaler Select"]
            #[inline(always)]
            pub fn psel(&mut self) -> _PSELW {
                _PSELW { w: self }
            }
            #[doc = "Bits 16:21 - BOD33 Threshold Level"]
            #[inline(always)]
            pub fn level(&mut self) -> _LEVELW {
                _LEVELW { w: self }
            }
        }
    }
    #[doc = "DFLL48M Control"]
    pub struct DFLLCTRL {
        register: VolatileCell<u16>,
    }
    #[doc = "DFLL48M Control"]
    pub mod dfllctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::DFLLCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODER {
            bits: bool,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STABLER {
            bits: bool,
        }
        impl STABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LLAWR {
            bits: bool,
        }
        impl LLAWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USBCRMR {
            bits: bool,
        }
        impl USBCRMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONDEMANDR {
            bits: bool,
        }
        impl ONDEMANDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCDISR {
            bits: bool,
        }
        impl CCDISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct QLDISR {
            bits: bool,
        }
        impl QLDISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BPLCKCR {
            bits: bool,
        }
        impl BPLCKCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAITLOCKR {
            bits: bool,
        }
        impl WAITLOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LLAWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LLAWW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _USBCRMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USBCRMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONDEMANDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONDEMANDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCDISW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _QLDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _QLDISW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BPLCKCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BPLCKCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAITLOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAITLOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 1 - DFLL Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Operating Mode Selection"]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                MODER { bits }
            }
            #[doc = "Bit 3 - Stable DFLL Frequency"]
            #[inline(always)]
            pub fn stable(&self) -> STABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                STABLER { bits }
            }
            #[doc = "Bit 4 - Lose Lock After Wake"]
            #[inline(always)]
            pub fn llaw(&self) -> LLAWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                LLAWR { bits }
            }
            #[doc = "Bit 5 - USB Clock Recovery Mode"]
            #[inline(always)]
            pub fn usbcrm(&self) -> USBCRMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                USBCRMR { bits }
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 7 - On Demand Control"]
            #[inline(always)]
            pub fn ondemand(&self) -> ONDEMANDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ONDEMANDR { bits }
            }
            #[doc = "Bit 8 - Chill Cycle Disable"]
            #[inline(always)]
            pub fn ccdis(&self) -> CCDISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                CCDISR { bits }
            }
            #[doc = "Bit 9 - Quick Lock Disable"]
            #[inline(always)]
            pub fn qldis(&self) -> QLDISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                QLDISR { bits }
            }
            #[doc = "Bit 10 - Bypass Coarse Lock"]
            #[inline(always)]
            pub fn bplckc(&self) -> BPLCKCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                BPLCKCR { bits }
            }
            #[doc = "Bit 11 - Wait Lock"]
            #[inline(always)]
            pub fn waitlock(&self) -> WAITLOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                WAITLOCKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 128 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - DFLL Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Operating Mode Selection"]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 3 - Stable DFLL Frequency"]
            #[inline(always)]
            pub fn stable(&mut self) -> _STABLEW {
                _STABLEW { w: self }
            }
            #[doc = "Bit 4 - Lose Lock After Wake"]
            #[inline(always)]
            pub fn llaw(&mut self) -> _LLAWW {
                _LLAWW { w: self }
            }
            #[doc = "Bit 5 - USB Clock Recovery Mode"]
            #[inline(always)]
            pub fn usbcrm(&mut self) -> _USBCRMW {
                _USBCRMW { w: self }
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 7 - On Demand Control"]
            #[inline(always)]
            pub fn ondemand(&mut self) -> _ONDEMANDW {
                _ONDEMANDW { w: self }
            }
            #[doc = "Bit 8 - Chill Cycle Disable"]
            #[inline(always)]
            pub fn ccdis(&mut self) -> _CCDISW {
                _CCDISW { w: self }
            }
            #[doc = "Bit 9 - Quick Lock Disable"]
            #[inline(always)]
            pub fn qldis(&mut self) -> _QLDISW {
                _QLDISW { w: self }
            }
            #[doc = "Bit 10 - Bypass Coarse Lock"]
            #[inline(always)]
            pub fn bplckc(&mut self) -> _BPLCKCW {
                _BPLCKCW { w: self }
            }
            #[doc = "Bit 11 - Wait Lock"]
            #[inline(always)]
            pub fn waitlock(&mut self) -> _WAITLOCKW {
                _WAITLOCKW { w: self }
            }
        }
    }
    #[doc = "DFLL48M Multiplier"]
    pub struct DFLLMUL {
        register: VolatileCell<u32>,
    }
    #[doc = "DFLL48M Multiplier"]
    pub mod dfllmul {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DFLLMUL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MULR {
            bits: u16,
        }
        impl MULR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FSTEPR {
            bits: u16,
        }
        impl FSTEPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CSTEPR {
            bits: u8,
        }
        impl CSTEPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MULW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MULW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FSTEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FSTEPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 1023;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CSTEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CSTEPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - DFLL Multiply Factor"]
            #[inline(always)]
            pub fn mul(&self) -> MULR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                MULR { bits }
            }
            #[doc = "Bits 16:25 - Fine Maximum Step"]
            #[inline(always)]
            pub fn fstep(&self) -> FSTEPR {
                let bits = {
                    const MASK: u16 = 1023;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                FSTEPR { bits }
            }
            #[doc = "Bits 26:31 - Coarse Maximum Step"]
            #[inline(always)]
            pub fn cstep(&self) -> CSTEPR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CSTEPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - DFLL Multiply Factor"]
            #[inline(always)]
            pub fn mul(&mut self) -> _MULW {
                _MULW { w: self }
            }
            #[doc = "Bits 16:25 - Fine Maximum Step"]
            #[inline(always)]
            pub fn fstep(&mut self) -> _FSTEPW {
                _FSTEPW { w: self }
            }
            #[doc = "Bits 26:31 - Coarse Maximum Step"]
            #[inline(always)]
            pub fn cstep(&mut self) -> _CSTEPW {
                _CSTEPW { w: self }
            }
        }
    }
    #[doc = "DFLL48M Synchronization"]
    pub struct DFLLSYNC {
        register: VolatileCell<u8>,
    }
    #[doc = "DFLL48M Synchronization"]
    pub mod dfllsync {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::DFLLSYNC {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _READREQW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READREQW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Read Request"]
            #[inline(always)]
            pub fn readreq(&mut self) -> _READREQW {
                _READREQW { w: self }
            }
        }
    }
    #[doc = "DFLL48M Value"]
    pub struct DFLLVAL {
        register: VolatileCell<u32>,
    }
    #[doc = "DFLL48M Value"]
    pub mod dfllval {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DFLLVAL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FINER {
            bits: u16,
        }
        impl FINER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct COARSER {
            bits: u8,
        }
        impl COARSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIFFR {
            bits: u16,
        }
        impl DIFFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _FINEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FINEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 1023;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COARSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COARSEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:9 - Fine Value"]
            #[inline(always)]
            pub fn fine(&self) -> FINER {
                let bits = {
                    const MASK: u16 = 1023;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                FINER { bits }
            }
            #[doc = "Bits 10:15 - Coarse Value"]
            #[inline(always)]
            pub fn coarse(&self) -> COARSER {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                COARSER { bits }
            }
            #[doc = "Bits 16:31 - Multiplication Ratio Difference"]
            #[inline(always)]
            pub fn diff(&self) -> DIFFR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIFFR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:9 - Fine Value"]
            #[inline(always)]
            pub fn fine(&mut self) -> _FINEW {
                _FINEW { w: self }
            }
            #[doc = "Bits 10:15 - Coarse Value"]
            #[inline(always)]
            pub fn coarse(&mut self) -> _COARSEW {
                _COARSEW { w: self }
            }
        }
    }
    #[doc = "DPLL Control A"]
    pub struct DPLLCTRLA {
        register: VolatileCell<u8>,
    }
    #[doc = "DPLL Control A"]
    pub mod dpllctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::DPLLCTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONDEMANDR {
            bits: bool,
        }
        impl ONDEMANDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONDEMANDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONDEMANDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 1 - DPLL Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 7 - On Demand Clock Activation"]
            #[inline(always)]
            pub fn ondemand(&self) -> ONDEMANDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ONDEMANDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 128 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - DPLL Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 7 - On Demand Clock Activation"]
            #[inline(always)]
            pub fn ondemand(&mut self) -> _ONDEMANDW {
                _ONDEMANDW { w: self }
            }
        }
    }
    #[doc = "DPLL Control B"]
    pub struct DPLLCTRLB {
        register: VolatileCell<u32>,
    }
    #[doc = "DPLL Control B"]
    pub mod dpllctrlb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DPLLCTRLB {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FILTER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FILTERR {
            #[doc = "Default filter mode"]
            DEFAULT,
            #[doc = "Low bandwidth filter"]
            LBFILT,
            #[doc = "High bandwidth filter"]
            HBFILT,
            #[doc = "High damping filter"]
            HDFILT,
        }
        impl FILTERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    FILTERR::DEFAULT => 0,
                    FILTERR::LBFILT => 1,
                    FILTERR::HBFILT => 2,
                    FILTERR::HDFILT => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> FILTERR {
                match value {
                    0 => FILTERR::DEFAULT,
                    1 => FILTERR::LBFILT,
                    2 => FILTERR::HBFILT,
                    3 => FILTERR::HDFILT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DEFAULT`"]
            #[inline(always)]
            pub fn is_default(&self) -> bool {
                *self == FILTERR::DEFAULT
            }
            #[doc = "Checks if the value of the field is `LBFILT`"]
            #[inline(always)]
            pub fn is_lbfilt(&self) -> bool {
                *self == FILTERR::LBFILT
            }
            #[doc = "Checks if the value of the field is `HBFILT`"]
            #[inline(always)]
            pub fn is_hbfilt(&self) -> bool {
                *self == FILTERR::HBFILT
            }
            #[doc = "Checks if the value of the field is `HDFILT`"]
            #[inline(always)]
            pub fn is_hdfilt(&self) -> bool {
                *self == FILTERR::HDFILT
            }
        }
        #[doc = r" Value of the field"]
        pub struct LPENR {
            bits: bool,
        }
        impl LPENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WUFR {
            bits: bool,
        }
        impl WUFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `REFCLK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REFCLKR {
            #[doc = "CLK_DPLL_REF0 clock reference"]
            REF0,
            #[doc = "CLK_DPLL_REF1 clock reference"]
            REF1,
            #[doc = "GCLK_DPLL clock reference"]
            GCLK,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl REFCLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    REFCLKR::REF0 => 0,
                    REFCLKR::REF1 => 1,
                    REFCLKR::GCLK => 2,
                    REFCLKR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> REFCLKR {
                match value {
                    0 => REFCLKR::REF0,
                    1 => REFCLKR::REF1,
                    2 => REFCLKR::GCLK,
                    i => REFCLKR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `REF0`"]
            #[inline(always)]
            pub fn is_ref0(&self) -> bool {
                *self == REFCLKR::REF0
            }
            #[doc = "Checks if the value of the field is `REF1`"]
            #[inline(always)]
            pub fn is_ref1(&self) -> bool {
                *self == REFCLKR::REF1
            }
            #[doc = "Checks if the value of the field is `GCLK`"]
            #[inline(always)]
            pub fn is_gclk(&self) -> bool {
                *self == REFCLKR::GCLK
            }
        }
        #[doc = "Possible values of the field `LTIME`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LTIMER {
            #[doc = "Default\tNo time-out"]
            _0X0,
            #[doc = "8MS\tTime-out if no lock within 8 ms"]
            _0X4,
            #[doc = "9MS\tTime-out if no lock within 9 ms"]
            _0X5,
            #[doc = "10MS\tTime-out if no lock within 10 ms"]
            _0X6,
            #[doc = "11MS\tTime-out if no lock within 11 ms"]
            _0X7,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl LTIMER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    LTIMER::_0X0 => 0,
                    LTIMER::_0X4 => 4,
                    LTIMER::_0X5 => 5,
                    LTIMER::_0X6 => 6,
                    LTIMER::_0X7 => 7,
                    LTIMER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> LTIMER {
                match value {
                    0 => LTIMER::_0X0,
                    4 => LTIMER::_0X4,
                    5 => LTIMER::_0X5,
                    6 => LTIMER::_0X6,
                    7 => LTIMER::_0X7,
                    i => LTIMER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_0X0`"]
            #[inline(always)]
            pub fn is_0x0(&self) -> bool {
                *self == LTIMER::_0X0
            }
            #[doc = "Checks if the value of the field is `_0X4`"]
            #[inline(always)]
            pub fn is_0x4(&self) -> bool {
                *self == LTIMER::_0X4
            }
            #[doc = "Checks if the value of the field is `_0X5`"]
            #[inline(always)]
            pub fn is_0x5(&self) -> bool {
                *self == LTIMER::_0X5
            }
            #[doc = "Checks if the value of the field is `_0X6`"]
            #[inline(always)]
            pub fn is_0x6(&self) -> bool {
                *self == LTIMER::_0X6
            }
            #[doc = "Checks if the value of the field is `_0X7`"]
            #[inline(always)]
            pub fn is_0x7(&self) -> bool {
                *self == LTIMER::_0X7
            }
        }
        #[doc = r" Value of the field"]
        pub struct LBYPASSR {
            bits: bool,
        }
        impl LBYPASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u16,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `FILTER`"]
        pub enum FILTERW {
            #[doc = "Default filter mode"]
            DEFAULT,
            #[doc = "Low bandwidth filter"]
            LBFILT,
            #[doc = "High bandwidth filter"]
            HBFILT,
            #[doc = "High damping filter"]
            HDFILT,
        }
        impl FILTERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FILTERW::DEFAULT => 0,
                    FILTERW::LBFILT => 1,
                    FILTERW::HBFILT => 2,
                    FILTERW::HDFILT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FILTERW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Default filter mode"]
            #[inline(always)]
            pub fn default(self) -> &'a mut W {
                self.variant(FILTERW::DEFAULT)
            }
            #[doc = "Low bandwidth filter"]
            #[inline(always)]
            pub fn lbfilt(self) -> &'a mut W {
                self.variant(FILTERW::LBFILT)
            }
            #[doc = "High bandwidth filter"]
            #[inline(always)]
            pub fn hbfilt(self) -> &'a mut W {
                self.variant(FILTERW::HBFILT)
            }
            #[doc = "High damping filter"]
            #[inline(always)]
            pub fn hdfilt(self) -> &'a mut W {
                self.variant(FILTERW::HDFILT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LPENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LPENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WUFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WUFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `REFCLK`"]
        pub enum REFCLKW {
            #[doc = "CLK_DPLL_REF0 clock reference"]
            REF0,
            #[doc = "CLK_DPLL_REF1 clock reference"]
            REF1,
            #[doc = "GCLK_DPLL clock reference"]
            GCLK,
        }
        impl REFCLKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    REFCLKW::REF0 => 0,
                    REFCLKW::REF1 => 1,
                    REFCLKW::GCLK => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REFCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REFCLKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: REFCLKW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "CLK_DPLL_REF0 clock reference"]
            #[inline(always)]
            pub fn ref0(self) -> &'a mut W {
                self.variant(REFCLKW::REF0)
            }
            #[doc = "CLK_DPLL_REF1 clock reference"]
            #[inline(always)]
            pub fn ref1(self) -> &'a mut W {
                self.variant(REFCLKW::REF1)
            }
            #[doc = "GCLK_DPLL clock reference"]
            #[inline(always)]
            pub fn gclk(self) -> &'a mut W {
                self.variant(REFCLKW::GCLK)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LTIME`"]
        pub enum LTIMEW {
            #[doc = "Default\tNo time-out"]
            _0X0,
            #[doc = "8MS\tTime-out if no lock within 8 ms"]
            _0X4,
            #[doc = "9MS\tTime-out if no lock within 9 ms"]
            _0X5,
            #[doc = "10MS\tTime-out if no lock within 10 ms"]
            _0X6,
            #[doc = "11MS\tTime-out if no lock within 11 ms"]
            _0X7,
        }
        impl LTIMEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LTIMEW::_0X0 => 0,
                    LTIMEW::_0X4 => 4,
                    LTIMEW::_0X5 => 5,
                    LTIMEW::_0X6 => 6,
                    LTIMEW::_0X7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LTIMEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LTIMEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LTIMEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Default No time-out"]
            #[inline(always)]
            pub fn _0x0(self) -> &'a mut W {
                self.variant(LTIMEW::_0X0)
            }
            #[doc = "8MS Time-out if no lock within 8 ms"]
            #[inline(always)]
            pub fn _0x4(self) -> &'a mut W {
                self.variant(LTIMEW::_0X4)
            }
            #[doc = "9MS Time-out if no lock within 9 ms"]
            #[inline(always)]
            pub fn _0x5(self) -> &'a mut W {
                self.variant(LTIMEW::_0X5)
            }
            #[doc = "10MS Time-out if no lock within 10 ms"]
            #[inline(always)]
            pub fn _0x6(self) -> &'a mut W {
                self.variant(LTIMEW::_0X6)
            }
            #[doc = "11MS Time-out if no lock within 11 ms"]
            #[inline(always)]
            pub fn _0x7(self) -> &'a mut W {
                self.variant(LTIMEW::_0X7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LBYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LBYPASSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 2047;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Proportional Integral Filter Selection"]
            #[inline(always)]
            pub fn filter(&self) -> FILTERR {
                FILTERR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 2 - Low-Power Enable"]
            #[inline(always)]
            pub fn lpen(&self) -> LPENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LPENR { bits }
            }
            #[doc = "Bit 3 - Wake Up Fast"]
            #[inline(always)]
            pub fn wuf(&self) -> WUFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WUFR { bits }
            }
            #[doc = "Bits 4:5 - Reference Clock Selection"]
            #[inline(always)]
            pub fn refclk(&self) -> REFCLKR {
                REFCLKR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:10 - Lock Time"]
            #[inline(always)]
            pub fn ltime(&self) -> LTIMER {
                LTIMER::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 12 - Lock Bypass"]
            #[inline(always)]
            pub fn lbypass(&self) -> LBYPASSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LBYPASSR { bits }
            }
            #[doc = "Bits 16:26 - Clock Divider"]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u16 = 2047;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Proportional Integral Filter Selection"]
            #[inline(always)]
            pub fn filter(&mut self) -> _FILTERW {
                _FILTERW { w: self }
            }
            #[doc = "Bit 2 - Low-Power Enable"]
            #[inline(always)]
            pub fn lpen(&mut self) -> _LPENW {
                _LPENW { w: self }
            }
            #[doc = "Bit 3 - Wake Up Fast"]
            #[inline(always)]
            pub fn wuf(&mut self) -> _WUFW {
                _WUFW { w: self }
            }
            #[doc = "Bits 4:5 - Reference Clock Selection"]
            #[inline(always)]
            pub fn refclk(&mut self) -> _REFCLKW {
                _REFCLKW { w: self }
            }
            #[doc = "Bits 8:10 - Lock Time"]
            #[inline(always)]
            pub fn ltime(&mut self) -> _LTIMEW {
                _LTIMEW { w: self }
            }
            #[doc = "Bit 12 - Lock Bypass"]
            #[inline(always)]
            pub fn lbypass(&mut self) -> _LBYPASSW {
                _LBYPASSW { w: self }
            }
            #[doc = "Bits 16:26 - Clock Divider"]
            #[inline(always)]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "DPLL Ratio Control"]
    pub struct DPLLRATIO {
        register: VolatileCell<u32>,
    }
    #[doc = "DPLL Ratio Control"]
    pub mod dpllratio {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DPLLRATIO {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LDRR {
            bits: u16,
        }
        impl LDRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LDRFRACR {
            bits: u8,
        }
        impl LDRFRACR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LDRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LDRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LDRFRACW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LDRFRACW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Loop Divider Ratio"]
            #[inline(always)]
            pub fn ldr(&self) -> LDRR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                LDRR { bits }
            }
            #[doc = "Bits 16:19 - Loop Divider Ratio Fractional Part"]
            #[inline(always)]
            pub fn ldrfrac(&self) -> LDRFRACR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LDRFRACR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Loop Divider Ratio"]
            #[inline(always)]
            pub fn ldr(&mut self) -> _LDRW {
                _LDRW { w: self }
            }
            #[doc = "Bits 16:19 - Loop Divider Ratio Fractional Part"]
            #[inline(always)]
            pub fn ldrfrac(&mut self) -> _LDRFRACW {
                _LDRFRACW { w: self }
            }
        }
    }
    #[doc = "DPLL Status"]
    pub struct DPLLSTATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "DPLL Status"]
    pub mod dpllstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::DPLLSTATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOCKR {
            bits: bool,
        }
        impl LOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKRDYR {
            bits: bool,
        }
        impl CLKRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: bool,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - DPLL Lock Status"]
            #[inline(always)]
            pub fn lock(&self) -> LOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                LOCKR { bits }
            }
            #[doc = "Bit 1 - Output Clock Ready"]
            #[inline(always)]
            pub fn clkrdy(&self) -> CLKRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CLKRDYR { bits }
            }
            #[doc = "Bit 2 - DPLL Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 3 - Divider Enable"]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DIVR { bits }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSCRDYR {
            bits: bool,
        }
        impl XOSCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSC32KRDYR {
            bits: bool,
        }
        impl XOSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC32KRDYR {
            bits: bool,
        }
        impl OSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC8MRDYR {
            bits: bool,
        }
        impl OSC8MRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRDYR {
            bits: bool,
        }
        impl DFLLRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLOOBR {
            bits: bool,
        }
        impl DFLLOOBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKFR {
            bits: bool,
        }
        impl DFLLLCKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKCR {
            bits: bool,
        }
        impl DFLLLCKCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRCSR {
            bits: bool,
        }
        impl DFLLRCSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33RDYR {
            bits: bool,
        }
        impl BOD33RDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33DETR {
            bits: bool,
        }
        impl BOD33DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct B33SRDYR {
            bits: bool,
        }
        impl B33SRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DPLLLCKRR {
            bits: bool,
        }
        impl DPLLLCKRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DPLLLCKFR {
            bits: bool,
        }
        impl DPLLLCKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DPLLLTOR {
            bits: bool,
        }
        impl DPLLLTOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _XOSCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XOSCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _XOSC32KRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XOSC32KRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSC32KRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSC32KRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSC8MRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSC8MRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLOOBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLOOBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLLCKFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLLCKFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLLCKCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLLCKCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLRCSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLRCSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD33RDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD33RDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD33DETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD33DETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _B33SRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _B33SRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DPLLLCKRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DPLLLCKRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DPLLLCKFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DPLLLCKFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DPLLLTOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DPLLLTOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - XOSC Ready Interrupt Enable"]
            #[inline(always)]
            pub fn xoscrdy(&self) -> XOSCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSCRDYR { bits }
            }
            #[doc = "Bit 1 - XOSC32K Ready Interrupt Enable"]
            #[inline(always)]
            pub fn xosc32krdy(&self) -> XOSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSC32KRDYR { bits }
            }
            #[doc = "Bit 2 - OSC32K Ready Interrupt Enable"]
            #[inline(always)]
            pub fn osc32krdy(&self) -> OSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC32KRDYR { bits }
            }
            #[doc = "Bit 3 - OSC8M Ready Interrupt Enable"]
            #[inline(always)]
            pub fn osc8mrdy(&self) -> OSC8MRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC8MRDYR { bits }
            }
            #[doc = "Bit 4 - DFLL Ready Interrupt Enable"]
            #[inline(always)]
            pub fn dfllrdy(&self) -> DFLLRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRDYR { bits }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds Interrupt Enable"]
            #[inline(always)]
            pub fn dflloob(&self) -> DFLLOOBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLOOBR { bits }
            }
            #[doc = "Bit 6 - DFLL Lock Fine Interrupt Enable"]
            #[inline(always)]
            pub fn dflllckf(&self) -> DFLLLCKFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKFR { bits }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse Interrupt Enable"]
            #[inline(always)]
            pub fn dflllckc(&self) -> DFLLLCKCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKCR { bits }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped Interrupt Enable"]
            #[inline(always)]
            pub fn dfllrcs(&self) -> DFLLRCSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRCSR { bits }
            }
            #[doc = "Bit 9 - BOD33 Ready Interrupt Enable"]
            #[inline(always)]
            pub fn bod33rdy(&self) -> BOD33RDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33RDYR { bits }
            }
            #[doc = "Bit 10 - BOD33 Detection Interrupt Enable"]
            #[inline(always)]
            pub fn bod33det(&self) -> BOD33DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33DETR { bits }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready Interrupt Enable"]
            #[inline(always)]
            pub fn b33srdy(&self) -> B33SRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                B33SRDYR { bits }
            }
            #[doc = "Bit 15 - DPLL Lock Rise Interrupt Enable"]
            #[inline(always)]
            pub fn dplllckr(&self) -> DPLLLCKRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DPLLLCKRR { bits }
            }
            #[doc = "Bit 16 - DPLL Lock Fall Interrupt Enable"]
            #[inline(always)]
            pub fn dplllckf(&self) -> DPLLLCKFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DPLLLCKFR { bits }
            }
            #[doc = "Bit 17 - DPLL Lock Timeout Interrupt Enable"]
            #[inline(always)]
            pub fn dplllto(&self) -> DPLLLTOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DPLLLTOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - XOSC Ready Interrupt Enable"]
            #[inline(always)]
            pub fn xoscrdy(&mut self) -> _XOSCRDYW {
                _XOSCRDYW { w: self }
            }
            #[doc = "Bit 1 - XOSC32K Ready Interrupt Enable"]
            #[inline(always)]
            pub fn xosc32krdy(&mut self) -> _XOSC32KRDYW {
                _XOSC32KRDYW { w: self }
            }
            #[doc = "Bit 2 - OSC32K Ready Interrupt Enable"]
            #[inline(always)]
            pub fn osc32krdy(&mut self) -> _OSC32KRDYW {
                _OSC32KRDYW { w: self }
            }
            #[doc = "Bit 3 - OSC8M Ready Interrupt Enable"]
            #[inline(always)]
            pub fn osc8mrdy(&mut self) -> _OSC8MRDYW {
                _OSC8MRDYW { w: self }
            }
            #[doc = "Bit 4 - DFLL Ready Interrupt Enable"]
            #[inline(always)]
            pub fn dfllrdy(&mut self) -> _DFLLRDYW {
                _DFLLRDYW { w: self }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds Interrupt Enable"]
            #[inline(always)]
            pub fn dflloob(&mut self) -> _DFLLOOBW {
                _DFLLOOBW { w: self }
            }
            #[doc = "Bit 6 - DFLL Lock Fine Interrupt Enable"]
            #[inline(always)]
            pub fn dflllckf(&mut self) -> _DFLLLCKFW {
                _DFLLLCKFW { w: self }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse Interrupt Enable"]
            #[inline(always)]
            pub fn dflllckc(&mut self) -> _DFLLLCKCW {
                _DFLLLCKCW { w: self }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped Interrupt Enable"]
            #[inline(always)]
            pub fn dfllrcs(&mut self) -> _DFLLRCSW {
                _DFLLRCSW { w: self }
            }
            #[doc = "Bit 9 - BOD33 Ready Interrupt Enable"]
            #[inline(always)]
            pub fn bod33rdy(&mut self) -> _BOD33RDYW {
                _BOD33RDYW { w: self }
            }
            #[doc = "Bit 10 - BOD33 Detection Interrupt Enable"]
            #[inline(always)]
            pub fn bod33det(&mut self) -> _BOD33DETW {
                _BOD33DETW { w: self }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready Interrupt Enable"]
            #[inline(always)]
            pub fn b33srdy(&mut self) -> _B33SRDYW {
                _B33SRDYW { w: self }
            }
            #[doc = "Bit 15 - DPLL Lock Rise Interrupt Enable"]
            #[inline(always)]
            pub fn dplllckr(&mut self) -> _DPLLLCKRW {
                _DPLLLCKRW { w: self }
            }
            #[doc = "Bit 16 - DPLL Lock Fall Interrupt Enable"]
            #[inline(always)]
            pub fn dplllckf(&mut self) -> _DPLLLCKFW {
                _DPLLLCKFW { w: self }
            }
            #[doc = "Bit 17 - DPLL Lock Timeout Interrupt Enable"]
            #[inline(always)]
            pub fn dplllto(&mut self) -> _DPLLLTOW {
                _DPLLLTOW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSCRDYR {
            bits: bool,
        }
        impl XOSCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSC32KRDYR {
            bits: bool,
        }
        impl XOSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC32KRDYR {
            bits: bool,
        }
        impl OSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC8MRDYR {
            bits: bool,
        }
        impl OSC8MRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRDYR {
            bits: bool,
        }
        impl DFLLRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLOOBR {
            bits: bool,
        }
        impl DFLLOOBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKFR {
            bits: bool,
        }
        impl DFLLLCKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKCR {
            bits: bool,
        }
        impl DFLLLCKCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRCSR {
            bits: bool,
        }
        impl DFLLRCSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33RDYR {
            bits: bool,
        }
        impl BOD33RDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33DETR {
            bits: bool,
        }
        impl BOD33DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct B33SRDYR {
            bits: bool,
        }
        impl B33SRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DPLLLCKRR {
            bits: bool,
        }
        impl DPLLLCKRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DPLLLCKFR {
            bits: bool,
        }
        impl DPLLLCKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DPLLLTOR {
            bits: bool,
        }
        impl DPLLLTOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _XOSCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XOSCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _XOSC32KRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XOSC32KRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSC32KRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSC32KRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSC8MRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSC8MRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLOOBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLOOBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLLCKFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLLCKFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLLCKCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLLCKCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLRCSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLRCSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD33RDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD33RDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD33DETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD33DETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _B33SRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _B33SRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DPLLLCKRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DPLLLCKRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DPLLLCKFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DPLLLCKFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DPLLLTOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DPLLLTOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - XOSC Ready Interrupt Enable"]
            #[inline(always)]
            pub fn xoscrdy(&self) -> XOSCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSCRDYR { bits }
            }
            #[doc = "Bit 1 - XOSC32K Ready Interrupt Enable"]
            #[inline(always)]
            pub fn xosc32krdy(&self) -> XOSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSC32KRDYR { bits }
            }
            #[doc = "Bit 2 - OSC32K Ready Interrupt Enable"]
            #[inline(always)]
            pub fn osc32krdy(&self) -> OSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC32KRDYR { bits }
            }
            #[doc = "Bit 3 - OSC8M Ready Interrupt Enable"]
            #[inline(always)]
            pub fn osc8mrdy(&self) -> OSC8MRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC8MRDYR { bits }
            }
            #[doc = "Bit 4 - DFLL Ready Interrupt Enable"]
            #[inline(always)]
            pub fn dfllrdy(&self) -> DFLLRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRDYR { bits }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds Interrupt Enable"]
            #[inline(always)]
            pub fn dflloob(&self) -> DFLLOOBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLOOBR { bits }
            }
            #[doc = "Bit 6 - DFLL Lock Fine Interrupt Enable"]
            #[inline(always)]
            pub fn dflllckf(&self) -> DFLLLCKFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKFR { bits }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse Interrupt Enable"]
            #[inline(always)]
            pub fn dflllckc(&self) -> DFLLLCKCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKCR { bits }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped Interrupt Enable"]
            #[inline(always)]
            pub fn dfllrcs(&self) -> DFLLRCSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRCSR { bits }
            }
            #[doc = "Bit 9 - BOD33 Ready Interrupt Enable"]
            #[inline(always)]
            pub fn bod33rdy(&self) -> BOD33RDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33RDYR { bits }
            }
            #[doc = "Bit 10 - BOD33 Detection Interrupt Enable"]
            #[inline(always)]
            pub fn bod33det(&self) -> BOD33DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33DETR { bits }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready Interrupt Enable"]
            #[inline(always)]
            pub fn b33srdy(&self) -> B33SRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                B33SRDYR { bits }
            }
            #[doc = "Bit 15 - DPLL Lock Rise Interrupt Enable"]
            #[inline(always)]
            pub fn dplllckr(&self) -> DPLLLCKRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DPLLLCKRR { bits }
            }
            #[doc = "Bit 16 - DPLL Lock Fall Interrupt Enable"]
            #[inline(always)]
            pub fn dplllckf(&self) -> DPLLLCKFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DPLLLCKFR { bits }
            }
            #[doc = "Bit 17 - DPLL Lock Timeout Interrupt Enable"]
            #[inline(always)]
            pub fn dplllto(&self) -> DPLLLTOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DPLLLTOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - XOSC Ready Interrupt Enable"]
            #[inline(always)]
            pub fn xoscrdy(&mut self) -> _XOSCRDYW {
                _XOSCRDYW { w: self }
            }
            #[doc = "Bit 1 - XOSC32K Ready Interrupt Enable"]
            #[inline(always)]
            pub fn xosc32krdy(&mut self) -> _XOSC32KRDYW {
                _XOSC32KRDYW { w: self }
            }
            #[doc = "Bit 2 - OSC32K Ready Interrupt Enable"]
            #[inline(always)]
            pub fn osc32krdy(&mut self) -> _OSC32KRDYW {
                _OSC32KRDYW { w: self }
            }
            #[doc = "Bit 3 - OSC8M Ready Interrupt Enable"]
            #[inline(always)]
            pub fn osc8mrdy(&mut self) -> _OSC8MRDYW {
                _OSC8MRDYW { w: self }
            }
            #[doc = "Bit 4 - DFLL Ready Interrupt Enable"]
            #[inline(always)]
            pub fn dfllrdy(&mut self) -> _DFLLRDYW {
                _DFLLRDYW { w: self }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds Interrupt Enable"]
            #[inline(always)]
            pub fn dflloob(&mut self) -> _DFLLOOBW {
                _DFLLOOBW { w: self }
            }
            #[doc = "Bit 6 - DFLL Lock Fine Interrupt Enable"]
            #[inline(always)]
            pub fn dflllckf(&mut self) -> _DFLLLCKFW {
                _DFLLLCKFW { w: self }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse Interrupt Enable"]
            #[inline(always)]
            pub fn dflllckc(&mut self) -> _DFLLLCKCW {
                _DFLLLCKCW { w: self }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped Interrupt Enable"]
            #[inline(always)]
            pub fn dfllrcs(&mut self) -> _DFLLRCSW {
                _DFLLRCSW { w: self }
            }
            #[doc = "Bit 9 - BOD33 Ready Interrupt Enable"]
            #[inline(always)]
            pub fn bod33rdy(&mut self) -> _BOD33RDYW {
                _BOD33RDYW { w: self }
            }
            #[doc = "Bit 10 - BOD33 Detection Interrupt Enable"]
            #[inline(always)]
            pub fn bod33det(&mut self) -> _BOD33DETW {
                _BOD33DETW { w: self }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready Interrupt Enable"]
            #[inline(always)]
            pub fn b33srdy(&mut self) -> _B33SRDYW {
                _B33SRDYW { w: self }
            }
            #[doc = "Bit 15 - DPLL Lock Rise Interrupt Enable"]
            #[inline(always)]
            pub fn dplllckr(&mut self) -> _DPLLLCKRW {
                _DPLLLCKRW { w: self }
            }
            #[doc = "Bit 16 - DPLL Lock Fall Interrupt Enable"]
            #[inline(always)]
            pub fn dplllckf(&mut self) -> _DPLLLCKFW {
                _DPLLLCKFW { w: self }
            }
            #[doc = "Bit 17 - DPLL Lock Timeout Interrupt Enable"]
            #[inline(always)]
            pub fn dplllto(&mut self) -> _DPLLLTOW {
                _DPLLLTOW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSCRDYR {
            bits: bool,
        }
        impl XOSCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSC32KRDYR {
            bits: bool,
        }
        impl XOSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC32KRDYR {
            bits: bool,
        }
        impl OSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC8MRDYR {
            bits: bool,
        }
        impl OSC8MRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRDYR {
            bits: bool,
        }
        impl DFLLRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLOOBR {
            bits: bool,
        }
        impl DFLLOOBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKFR {
            bits: bool,
        }
        impl DFLLLCKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKCR {
            bits: bool,
        }
        impl DFLLLCKCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRCSR {
            bits: bool,
        }
        impl DFLLRCSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33RDYR {
            bits: bool,
        }
        impl BOD33RDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33DETR {
            bits: bool,
        }
        impl BOD33DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct B33SRDYR {
            bits: bool,
        }
        impl B33SRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DPLLLCKRR {
            bits: bool,
        }
        impl DPLLLCKRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DPLLLCKFR {
            bits: bool,
        }
        impl DPLLLCKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DPLLLTOR {
            bits: bool,
        }
        impl DPLLLTOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _XOSCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XOSCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _XOSC32KRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XOSC32KRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSC32KRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSC32KRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSC8MRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSC8MRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLOOBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLOOBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLLCKFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLLCKFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLLCKCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLLCKCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLRCSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLRCSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD33RDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD33RDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD33DETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD33DETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _B33SRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _B33SRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DPLLLCKRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DPLLLCKRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DPLLLCKFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DPLLLCKFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DPLLLTOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DPLLLTOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - XOSC Ready"]
            #[inline(always)]
            pub fn xoscrdy(&self) -> XOSCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSCRDYR { bits }
            }
            #[doc = "Bit 1 - XOSC32K Ready"]
            #[inline(always)]
            pub fn xosc32krdy(&self) -> XOSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSC32KRDYR { bits }
            }
            #[doc = "Bit 2 - OSC32K Ready"]
            #[inline(always)]
            pub fn osc32krdy(&self) -> OSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC32KRDYR { bits }
            }
            #[doc = "Bit 3 - OSC8M Ready"]
            #[inline(always)]
            pub fn osc8mrdy(&self) -> OSC8MRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC8MRDYR { bits }
            }
            #[doc = "Bit 4 - DFLL Ready"]
            #[inline(always)]
            pub fn dfllrdy(&self) -> DFLLRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRDYR { bits }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds"]
            #[inline(always)]
            pub fn dflloob(&self) -> DFLLOOBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLOOBR { bits }
            }
            #[doc = "Bit 6 - DFLL Lock Fine"]
            #[inline(always)]
            pub fn dflllckf(&self) -> DFLLLCKFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKFR { bits }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse"]
            #[inline(always)]
            pub fn dflllckc(&self) -> DFLLLCKCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKCR { bits }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped"]
            #[inline(always)]
            pub fn dfllrcs(&self) -> DFLLRCSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRCSR { bits }
            }
            #[doc = "Bit 9 - BOD33 Ready"]
            #[inline(always)]
            pub fn bod33rdy(&self) -> BOD33RDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33RDYR { bits }
            }
            #[doc = "Bit 10 - BOD33 Detection"]
            #[inline(always)]
            pub fn bod33det(&self) -> BOD33DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33DETR { bits }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready"]
            #[inline(always)]
            pub fn b33srdy(&self) -> B33SRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                B33SRDYR { bits }
            }
            #[doc = "Bit 15 - DPLL Lock Rise"]
            #[inline(always)]
            pub fn dplllckr(&self) -> DPLLLCKRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DPLLLCKRR { bits }
            }
            #[doc = "Bit 16 - DPLL Lock Fall"]
            #[inline(always)]
            pub fn dplllckf(&self) -> DPLLLCKFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DPLLLCKFR { bits }
            }
            #[doc = "Bit 17 - DPLL Lock Timeout"]
            #[inline(always)]
            pub fn dplllto(&self) -> DPLLLTOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DPLLLTOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - XOSC Ready"]
            #[inline(always)]
            pub fn xoscrdy(&mut self) -> _XOSCRDYW {
                _XOSCRDYW { w: self }
            }
            #[doc = "Bit 1 - XOSC32K Ready"]
            #[inline(always)]
            pub fn xosc32krdy(&mut self) -> _XOSC32KRDYW {
                _XOSC32KRDYW { w: self }
            }
            #[doc = "Bit 2 - OSC32K Ready"]
            #[inline(always)]
            pub fn osc32krdy(&mut self) -> _OSC32KRDYW {
                _OSC32KRDYW { w: self }
            }
            #[doc = "Bit 3 - OSC8M Ready"]
            #[inline(always)]
            pub fn osc8mrdy(&mut self) -> _OSC8MRDYW {
                _OSC8MRDYW { w: self }
            }
            #[doc = "Bit 4 - DFLL Ready"]
            #[inline(always)]
            pub fn dfllrdy(&mut self) -> _DFLLRDYW {
                _DFLLRDYW { w: self }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds"]
            #[inline(always)]
            pub fn dflloob(&mut self) -> _DFLLOOBW {
                _DFLLOOBW { w: self }
            }
            #[doc = "Bit 6 - DFLL Lock Fine"]
            #[inline(always)]
            pub fn dflllckf(&mut self) -> _DFLLLCKFW {
                _DFLLLCKFW { w: self }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse"]
            #[inline(always)]
            pub fn dflllckc(&mut self) -> _DFLLLCKCW {
                _DFLLLCKCW { w: self }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped"]
            #[inline(always)]
            pub fn dfllrcs(&mut self) -> _DFLLRCSW {
                _DFLLRCSW { w: self }
            }
            #[doc = "Bit 9 - BOD33 Ready"]
            #[inline(always)]
            pub fn bod33rdy(&mut self) -> _BOD33RDYW {
                _BOD33RDYW { w: self }
            }
            #[doc = "Bit 10 - BOD33 Detection"]
            #[inline(always)]
            pub fn bod33det(&mut self) -> _BOD33DETW {
                _BOD33DETW { w: self }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready"]
            #[inline(always)]
            pub fn b33srdy(&mut self) -> _B33SRDYW {
                _B33SRDYW { w: self }
            }
            #[doc = "Bit 15 - DPLL Lock Rise"]
            #[inline(always)]
            pub fn dplllckr(&mut self) -> _DPLLLCKRW {
                _DPLLLCKRW { w: self }
            }
            #[doc = "Bit 16 - DPLL Lock Fall"]
            #[inline(always)]
            pub fn dplllckf(&mut self) -> _DPLLLCKFW {
                _DPLLLCKFW { w: self }
            }
            #[doc = "Bit 17 - DPLL Lock Timeout"]
            #[inline(always)]
            pub fn dplllto(&mut self) -> _DPLLLTOW {
                _DPLLLTOW { w: self }
            }
        }
    }
    #[doc = "32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control"]
    pub struct OSCULP32K {
        register: VolatileCell<u8>,
    }
    #[doc = "32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control"]
    pub mod osculp32k {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::OSCULP32K {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALIBR {
            bits: u8,
        }
        impl CALIBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRTLOCKR {
            bits: bool,
        }
        impl WRTLOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALIBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALIBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRTLOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRTLOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:4 - Oscillator Calibration"]
            #[inline(always)]
            pub fn calib(&self) -> CALIBR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                CALIBR { bits }
            }
            #[doc = "Bit 7 - Write Lock"]
            #[inline(always)]
            pub fn wrtlock(&self) -> WRTLOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WRTLOCKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 31 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Oscillator Calibration"]
            #[inline(always)]
            pub fn calib(&mut self) -> _CALIBW {
                _CALIBW { w: self }
            }
            #[doc = "Bit 7 - Write Lock"]
            #[inline(always)]
            pub fn wrtlock(&mut self) -> _WRTLOCKW {
                _WRTLOCKW { w: self }
            }
        }
    }
    #[doc = "8MHz Internal Oscillator (OSC8M) Control"]
    pub struct OSC8M {
        register: VolatileCell<u32>,
    }
    #[doc = "8MHz Internal Oscillator (OSC8M) Control"]
    pub mod osc8m {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OSC8M {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONDEMANDR {
            bits: bool,
        }
        impl ONDEMANDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `PRESC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PRESCR {
            #[doc = "1"]
            _0X0,
            #[doc = "2"]
            _0X1,
            #[doc = "4"]
            _0X2,
            #[doc = "8"]
            _0X3,
        }
        impl PRESCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    PRESCR::_0X0 => 0,
                    PRESCR::_0X1 => 1,
                    PRESCR::_0X2 => 2,
                    PRESCR::_0X3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> PRESCR {
                match value {
                    0 => PRESCR::_0X0,
                    1 => PRESCR::_0X1,
                    2 => PRESCR::_0X2,
                    3 => PRESCR::_0X3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_0X0`"]
            #[inline(always)]
            pub fn is_0x0(&self) -> bool {
                *self == PRESCR::_0X0
            }
            #[doc = "Checks if the value of the field is `_0X1`"]
            #[inline(always)]
            pub fn is_0x1(&self) -> bool {
                *self == PRESCR::_0X1
            }
            #[doc = "Checks if the value of the field is `_0X2`"]
            #[inline(always)]
            pub fn is_0x2(&self) -> bool {
                *self == PRESCR::_0X2
            }
            #[doc = "Checks if the value of the field is `_0X3`"]
            #[inline(always)]
            pub fn is_0x3(&self) -> bool {
                *self == PRESCR::_0X3
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALIBR {
            bits: u16,
        }
        impl CALIBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `FRANGE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FRANGER {
            #[doc = "4 to 6MHz"]
            _0X0,
            #[doc = "6 to 8MHz"]
            _0X1,
            #[doc = "8 to 11MHz"]
            _0X2,
            #[doc = "11 to 15MHz"]
            _0X3,
        }
        impl FRANGER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    FRANGER::_0X0 => 0,
                    FRANGER::_0X1 => 1,
                    FRANGER::_0X2 => 2,
                    FRANGER::_0X3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> FRANGER {
                match value {
                    0 => FRANGER::_0X0,
                    1 => FRANGER::_0X1,
                    2 => FRANGER::_0X2,
                    3 => FRANGER::_0X3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_0X0`"]
            #[inline(always)]
            pub fn is_0x0(&self) -> bool {
                *self == FRANGER::_0X0
            }
            #[doc = "Checks if the value of the field is `_0X1`"]
            #[inline(always)]
            pub fn is_0x1(&self) -> bool {
                *self == FRANGER::_0X1
            }
            #[doc = "Checks if the value of the field is `_0X2`"]
            #[inline(always)]
            pub fn is_0x2(&self) -> bool {
                *self == FRANGER::_0X2
            }
            #[doc = "Checks if the value of the field is `_0X3`"]
            #[inline(always)]
            pub fn is_0x3(&self) -> bool {
                *self == FRANGER::_0X3
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONDEMANDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONDEMANDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PRESC`"]
        pub enum PRESCW {
            #[doc = "1"]
            _0X0,
            #[doc = "2"]
            _0X1,
            #[doc = "4"]
            _0X2,
            #[doc = "8"]
            _0X3,
        }
        impl PRESCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PRESCW::_0X0 => 0,
                    PRESCW::_0X1 => 1,
                    PRESCW::_0X2 => 2,
                    PRESCW::_0X3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRESCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRESCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PRESCW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "1"]
            #[inline(always)]
            pub fn _0x0(self) -> &'a mut W {
                self.variant(PRESCW::_0X0)
            }
            #[doc = "2"]
            #[inline(always)]
            pub fn _0x1(self) -> &'a mut W {
                self.variant(PRESCW::_0X1)
            }
            #[doc = "4"]
            #[inline(always)]
            pub fn _0x2(self) -> &'a mut W {
                self.variant(PRESCW::_0X2)
            }
            #[doc = "8"]
            #[inline(always)]
            pub fn _0x3(self) -> &'a mut W {
                self.variant(PRESCW::_0X3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALIBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALIBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FRANGE`"]
        pub enum FRANGEW {
            #[doc = "4 to 6MHz"]
            _0X0,
            #[doc = "6 to 8MHz"]
            _0X1,
            #[doc = "8 to 11MHz"]
            _0X2,
            #[doc = "11 to 15MHz"]
            _0X3,
        }
        impl FRANGEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FRANGEW::_0X0 => 0,
                    FRANGEW::_0X1 => 1,
                    FRANGEW::_0X2 => 2,
                    FRANGEW::_0X3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRANGEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRANGEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FRANGEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "4 to 6MHz"]
            #[inline(always)]
            pub fn _0x0(self) -> &'a mut W {
                self.variant(FRANGEW::_0X0)
            }
            #[doc = "6 to 8MHz"]
            #[inline(always)]
            pub fn _0x1(self) -> &'a mut W {
                self.variant(FRANGEW::_0X1)
            }
            #[doc = "8 to 11MHz"]
            #[inline(always)]
            pub fn _0x2(self) -> &'a mut W {
                self.variant(FRANGEW::_0X2)
            }
            #[doc = "11 to 15MHz"]
            #[inline(always)]
            pub fn _0x3(self) -> &'a mut W {
                self.variant(FRANGEW::_0X3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Oscillator Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 7 - On Demand Control"]
            #[inline(always)]
            pub fn ondemand(&self) -> ONDEMANDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ONDEMANDR { bits }
            }
            #[doc = "Bits 8:9 - Oscillator Prescaler"]
            #[inline(always)]
            pub fn presc(&self) -> PRESCR {
                PRESCR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 16:27 - Oscillator Calibration"]
            #[inline(always)]
            pub fn calib(&self) -> CALIBR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CALIBR { bits }
            }
            #[doc = "Bits 30:31 - Oscillator Frequency Range"]
            #[inline(always)]
            pub fn frange(&self) -> FRANGER {
                FRANGER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 2265383810 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Oscillator Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 7 - On Demand Control"]
            #[inline(always)]
            pub fn ondemand(&mut self) -> _ONDEMANDW {
                _ONDEMANDW { w: self }
            }
            #[doc = "Bits 8:9 - Oscillator Prescaler"]
            #[inline(always)]
            pub fn presc(&mut self) -> _PRESCW {
                _PRESCW { w: self }
            }
            #[doc = "Bits 16:27 - Oscillator Calibration"]
            #[inline(always)]
            pub fn calib(&mut self) -> _CALIBW {
                _CALIBW { w: self }
            }
            #[doc = "Bits 30:31 - Oscillator Frequency Range"]
            #[inline(always)]
            pub fn frange(&mut self) -> _FRANGEW {
                _FRANGEW { w: self }
            }
        }
    }
    #[doc = "32kHz Internal Oscillator (OSC32K) Control"]
    pub struct OSC32K {
        register: VolatileCell<u32>,
    }
    #[doc = "32kHz Internal Oscillator (OSC32K) Control"]
    pub mod osc32k {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OSC32K {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EN32KR {
            bits: bool,
        }
        impl EN32KR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EN1KR {
            bits: bool,
        }
        impl EN1KR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONDEMANDR {
            bits: bool,
        }
        impl ONDEMANDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTUPR {
            bits: u8,
        }
        impl STARTUPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRTLOCKR {
            bits: bool,
        }
        impl WRTLOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALIBR {
            bits: u8,
        }
        impl CALIBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EN32KW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EN32KW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EN1KW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EN1KW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONDEMANDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONDEMANDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTUPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTUPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRTLOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRTLOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALIBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALIBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Oscillator Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - 32kHz Output Enable"]
            #[inline(always)]
            pub fn en32k(&self) -> EN32KR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EN32KR { bits }
            }
            #[doc = "Bit 3 - 1kHz Output Enable"]
            #[inline(always)]
            pub fn en1k(&self) -> EN1KR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EN1KR { bits }
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 7 - On Demand Control"]
            #[inline(always)]
            pub fn ondemand(&self) -> ONDEMANDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ONDEMANDR { bits }
            }
            #[doc = "Bits 8:10 - Oscillator Start-Up Time"]
            #[inline(always)]
            pub fn startup(&self) -> STARTUPR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STARTUPR { bits }
            }
            #[doc = "Bit 12 - Write Lock"]
            #[inline(always)]
            pub fn wrtlock(&self) -> WRTLOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WRTLOCKR { bits }
            }
            #[doc = "Bits 16:22 - Oscillator Calibration"]
            #[inline(always)]
            pub fn calib(&self) -> CALIBR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CALIBR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 4128896 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Oscillator Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - 32kHz Output Enable"]
            #[inline(always)]
            pub fn en32k(&mut self) -> _EN32KW {
                _EN32KW { w: self }
            }
            #[doc = "Bit 3 - 1kHz Output Enable"]
            #[inline(always)]
            pub fn en1k(&mut self) -> _EN1KW {
                _EN1KW { w: self }
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 7 - On Demand Control"]
            #[inline(always)]
            pub fn ondemand(&mut self) -> _ONDEMANDW {
                _ONDEMANDW { w: self }
            }
            #[doc = "Bits 8:10 - Oscillator Start-Up Time"]
            #[inline(always)]
            pub fn startup(&mut self) -> _STARTUPW {
                _STARTUPW { w: self }
            }
            #[doc = "Bit 12 - Write Lock"]
            #[inline(always)]
            pub fn wrtlock(&mut self) -> _WRTLOCKW {
                _WRTLOCKW { w: self }
            }
            #[doc = "Bits 16:22 - Oscillator Calibration"]
            #[inline(always)]
            pub fn calib(&mut self) -> _CALIBW {
                _CALIBW { w: self }
            }
        }
    }
    #[doc = "Power and Clocks Status"]
    pub struct PCLKSR {
        register: VolatileCell<u32>,
    }
    #[doc = "Power and Clocks Status"]
    pub mod pclksr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PCLKSR {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSCRDYR {
            bits: bool,
        }
        impl XOSCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSC32KRDYR {
            bits: bool,
        }
        impl XOSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC32KRDYR {
            bits: bool,
        }
        impl OSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC8MRDYR {
            bits: bool,
        }
        impl OSC8MRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRDYR {
            bits: bool,
        }
        impl DFLLRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLOOBR {
            bits: bool,
        }
        impl DFLLOOBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKFR {
            bits: bool,
        }
        impl DFLLLCKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKCR {
            bits: bool,
        }
        impl DFLLLCKCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRCSR {
            bits: bool,
        }
        impl DFLLRCSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33RDYR {
            bits: bool,
        }
        impl BOD33RDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33DETR {
            bits: bool,
        }
        impl BOD33DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct B33SRDYR {
            bits: bool,
        }
        impl B33SRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DPLLLCKRR {
            bits: bool,
        }
        impl DPLLLCKRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DPLLLCKFR {
            bits: bool,
        }
        impl DPLLLCKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DPLLLTOR {
            bits: bool,
        }
        impl DPLLLTOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - XOSC Ready"]
            #[inline(always)]
            pub fn xoscrdy(&self) -> XOSCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSCRDYR { bits }
            }
            #[doc = "Bit 1 - XOSC32K Ready"]
            #[inline(always)]
            pub fn xosc32krdy(&self) -> XOSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSC32KRDYR { bits }
            }
            #[doc = "Bit 2 - OSC32K Ready"]
            #[inline(always)]
            pub fn osc32krdy(&self) -> OSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC32KRDYR { bits }
            }
            #[doc = "Bit 3 - OSC8M Ready"]
            #[inline(always)]
            pub fn osc8mrdy(&self) -> OSC8MRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC8MRDYR { bits }
            }
            #[doc = "Bit 4 - DFLL Ready"]
            #[inline(always)]
            pub fn dfllrdy(&self) -> DFLLRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRDYR { bits }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds"]
            #[inline(always)]
            pub fn dflloob(&self) -> DFLLOOBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLOOBR { bits }
            }
            #[doc = "Bit 6 - DFLL Lock Fine"]
            #[inline(always)]
            pub fn dflllckf(&self) -> DFLLLCKFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKFR { bits }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse"]
            #[inline(always)]
            pub fn dflllckc(&self) -> DFLLLCKCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKCR { bits }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped"]
            #[inline(always)]
            pub fn dfllrcs(&self) -> DFLLRCSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRCSR { bits }
            }
            #[doc = "Bit 9 - BOD33 Ready"]
            #[inline(always)]
            pub fn bod33rdy(&self) -> BOD33RDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33RDYR { bits }
            }
            #[doc = "Bit 10 - BOD33 Detection"]
            #[inline(always)]
            pub fn bod33det(&self) -> BOD33DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33DETR { bits }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready"]
            #[inline(always)]
            pub fn b33srdy(&self) -> B33SRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                B33SRDYR { bits }
            }
            #[doc = "Bit 15 - DPLL Lock Rise"]
            #[inline(always)]
            pub fn dplllckr(&self) -> DPLLLCKRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DPLLLCKRR { bits }
            }
            #[doc = "Bit 16 - DPLL Lock Fall"]
            #[inline(always)]
            pub fn dplllckf(&self) -> DPLLLCKFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DPLLLCKFR { bits }
            }
            #[doc = "Bit 17 - DPLL Lock Timeout"]
            #[inline(always)]
            pub fn dplllto(&self) -> DPLLLTOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DPLLLTOR { bits }
            }
        }
    }
    #[doc = "Voltage References System (VREF) Control"]
    pub struct VREF {
        register: VolatileCell<u32>,
    }
    #[doc = "Voltage References System (VREF) Control"]
    pub mod vref {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::VREF {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TSENR {
            bits: bool,
        }
        impl TSENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BGOUTENR {
            bits: bool,
        }
        impl BGOUTENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALIBR {
            bits: u16,
        }
        impl CALIBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TSENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TSENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BGOUTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BGOUTENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALIBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALIBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 2047;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Temperature Sensor Enable"]
            #[inline(always)]
            pub fn tsen(&self) -> TSENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TSENR { bits }
            }
            #[doc = "Bit 2 - Bandgap Output Enable"]
            #[inline(always)]
            pub fn bgouten(&self) -> BGOUTENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BGOUTENR { bits }
            }
            #[doc = "Bits 16:26 - Bandgap Voltage Generator Calibration"]
            #[inline(always)]
            pub fn calib(&self) -> CALIBR {
                let bits = {
                    const MASK: u16 = 2047;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CALIBR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Temperature Sensor Enable"]
            #[inline(always)]
            pub fn tsen(&mut self) -> _TSENW {
                _TSENW { w: self }
            }
            #[doc = "Bit 2 - Bandgap Output Enable"]
            #[inline(always)]
            pub fn bgouten(&mut self) -> _BGOUTENW {
                _BGOUTENW { w: self }
            }
            #[doc = "Bits 16:26 - Bandgap Voltage Generator Calibration"]
            #[inline(always)]
            pub fn calib(&mut self) -> _CALIBW {
                _CALIBW { w: self }
            }
        }
    }
    #[doc = "External Multipurpose Crystal Oscillator (XOSC) Control"]
    pub struct XOSC {
        register: VolatileCell<u16>,
    }
    #[doc = "External Multipurpose Crystal Oscillator (XOSC) Control"]
    pub mod xosc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::XOSC {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct XTALENR {
            bits: bool,
        }
        impl XTALENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONDEMANDR {
            bits: bool,
        }
        impl ONDEMANDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `GAIN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GAINR {
            #[doc = "2MHz"]
            _0X0,
            #[doc = "4MHz"]
            _0X1,
            #[doc = "8MHz"]
            _0X2,
            #[doc = "16MHz"]
            _0X3,
            #[doc = "30MHz"]
            _0X4,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl GAINR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    GAINR::_0X0 => 0,
                    GAINR::_0X1 => 1,
                    GAINR::_0X2 => 2,
                    GAINR::_0X3 => 3,
                    GAINR::_0X4 => 4,
                    GAINR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> GAINR {
                match value {
                    0 => GAINR::_0X0,
                    1 => GAINR::_0X1,
                    2 => GAINR::_0X2,
                    3 => GAINR::_0X3,
                    4 => GAINR::_0X4,
                    i => GAINR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_0X0`"]
            #[inline(always)]
            pub fn is_0x0(&self) -> bool {
                *self == GAINR::_0X0
            }
            #[doc = "Checks if the value of the field is `_0X1`"]
            #[inline(always)]
            pub fn is_0x1(&self) -> bool {
                *self == GAINR::_0X1
            }
            #[doc = "Checks if the value of the field is `_0X2`"]
            #[inline(always)]
            pub fn is_0x2(&self) -> bool {
                *self == GAINR::_0X2
            }
            #[doc = "Checks if the value of the field is `_0X3`"]
            #[inline(always)]
            pub fn is_0x3(&self) -> bool {
                *self == GAINR::_0X3
            }
            #[doc = "Checks if the value of the field is `_0X4`"]
            #[inline(always)]
            pub fn is_0x4(&self) -> bool {
                *self == GAINR::_0X4
            }
        }
        #[doc = r" Value of the field"]
        pub struct AMPGCR {
            bits: bool,
        }
        impl AMPGCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTUPR {
            bits: u8,
        }
        impl STARTUPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _XTALENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XTALENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONDEMANDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONDEMANDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GAIN`"]
        pub enum GAINW {
            #[doc = "2MHz"]
            _0X0,
            #[doc = "4MHz"]
            _0X1,
            #[doc = "8MHz"]
            _0X2,
            #[doc = "16MHz"]
            _0X3,
            #[doc = "30MHz"]
            _0X4,
        }
        impl GAINW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    GAINW::_0X0 => 0,
                    GAINW::_0X1 => 1,
                    GAINW::_0X2 => 2,
                    GAINW::_0X3 => 3,
                    GAINW::_0X4 => 4,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GAINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GAINW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: GAINW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "2MHz"]
            #[inline(always)]
            pub fn _0x0(self) -> &'a mut W {
                self.variant(GAINW::_0X0)
            }
            #[doc = "4MHz"]
            #[inline(always)]
            pub fn _0x1(self) -> &'a mut W {
                self.variant(GAINW::_0X1)
            }
            #[doc = "8MHz"]
            #[inline(always)]
            pub fn _0x2(self) -> &'a mut W {
                self.variant(GAINW::_0X2)
            }
            #[doc = "16MHz"]
            #[inline(always)]
            pub fn _0x3(self) -> &'a mut W {
                self.variant(GAINW::_0X3)
            }
            #[doc = "30MHz"]
            #[inline(always)]
            pub fn _0x4(self) -> &'a mut W {
                self.variant(GAINW::_0X4)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AMPGCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AMPGCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTUPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTUPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 1 - Oscillator Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Crystal Oscillator Enable"]
            #[inline(always)]
            pub fn xtalen(&self) -> XTALENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                XTALENR { bits }
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 7 - On Demand Control"]
            #[inline(always)]
            pub fn ondemand(&self) -> ONDEMANDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ONDEMANDR { bits }
            }
            #[doc = "Bits 8:10 - Oscillator Gain"]
            #[inline(always)]
            pub fn gain(&self) -> GAINR {
                GAINR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bit 11 - Automatic Amplitude Gain Control"]
            #[inline(always)]
            pub fn ampgc(&self) -> AMPGCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                AMPGCR { bits }
            }
            #[doc = "Bits 12:15 - Start-Up Time"]
            #[inline(always)]
            pub fn startup(&self) -> STARTUPR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                STARTUPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 128 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Oscillator Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Crystal Oscillator Enable"]
            #[inline(always)]
            pub fn xtalen(&mut self) -> _XTALENW {
                _XTALENW { w: self }
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 7 - On Demand Control"]
            #[inline(always)]
            pub fn ondemand(&mut self) -> _ONDEMANDW {
                _ONDEMANDW { w: self }
            }
            #[doc = "Bits 8:10 - Oscillator Gain"]
            #[inline(always)]
            pub fn gain(&mut self) -> _GAINW {
                _GAINW { w: self }
            }
            #[doc = "Bit 11 - Automatic Amplitude Gain Control"]
            #[inline(always)]
            pub fn ampgc(&mut self) -> _AMPGCW {
                _AMPGCW { w: self }
            }
            #[doc = "Bits 12:15 - Start-Up Time"]
            #[inline(always)]
            pub fn startup(&mut self) -> _STARTUPW {
                _STARTUPW { w: self }
            }
        }
    }
    #[doc = "32kHz External Crystal Oscillator (XOSC32K) Control"]
    pub struct XOSC32K {
        register: VolatileCell<u16>,
    }
    #[doc = "32kHz External Crystal Oscillator (XOSC32K) Control"]
    pub mod xosc32k {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::XOSC32K {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct XTALENR {
            bits: bool,
        }
        impl XTALENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EN32KR {
            bits: bool,
        }
        impl EN32KR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EN1KR {
            bits: bool,
        }
        impl EN1KR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AAMPENR {
            bits: bool,
        }
        impl AAMPENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONDEMANDR {
            bits: bool,
        }
        impl ONDEMANDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTUPR {
            bits: u8,
        }
        impl STARTUPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRTLOCKR {
            bits: bool,
        }
        impl WRTLOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _XTALENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XTALENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EN32KW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EN32KW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EN1KW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EN1KW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AAMPENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AAMPENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONDEMANDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONDEMANDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTUPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTUPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRTLOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRTLOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 1 - Oscillator Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Crystal Oscillator Enable"]
            #[inline(always)]
            pub fn xtalen(&self) -> XTALENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                XTALENR { bits }
            }
            #[doc = "Bit 3 - 32kHz Output Enable"]
            #[inline(always)]
            pub fn en32k(&self) -> EN32KR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                EN32KR { bits }
            }
            #[doc = "Bit 4 - 1kHz Output Enable"]
            #[inline(always)]
            pub fn en1k(&self) -> EN1KR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                EN1KR { bits }
            }
            #[doc = "Bit 5 - Automatic Amplitude Control Enable"]
            #[inline(always)]
            pub fn aampen(&self) -> AAMPENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                AAMPENR { bits }
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 7 - On Demand Control"]
            #[inline(always)]
            pub fn ondemand(&self) -> ONDEMANDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ONDEMANDR { bits }
            }
            #[doc = "Bits 8:10 - Oscillator Start-Up Time"]
            #[inline(always)]
            pub fn startup(&self) -> STARTUPR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                STARTUPR { bits }
            }
            #[doc = "Bit 12 - Write Lock"]
            #[inline(always)]
            pub fn wrtlock(&self) -> WRTLOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                WRTLOCKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 128 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Oscillator Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Crystal Oscillator Enable"]
            #[inline(always)]
            pub fn xtalen(&mut self) -> _XTALENW {
                _XTALENW { w: self }
            }
            #[doc = "Bit 3 - 32kHz Output Enable"]
            #[inline(always)]
            pub fn en32k(&mut self) -> _EN32KW {
                _EN32KW { w: self }
            }
            #[doc = "Bit 4 - 1kHz Output Enable"]
            #[inline(always)]
            pub fn en1k(&mut self) -> _EN1KW {
                _EN1KW { w: self }
            }
            #[doc = "Bit 5 - Automatic Amplitude Control Enable"]
            #[inline(always)]
            pub fn aampen(&mut self) -> _AAMPENW {
                _AAMPENW { w: self }
            }
            #[doc = "Bit 6 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 7 - On Demand Control"]
            #[inline(always)]
            pub fn ondemand(&mut self) -> _ONDEMANDW {
                _ONDEMANDW { w: self }
            }
            #[doc = "Bits 8:10 - Oscillator Start-Up Time"]
            #[inline(always)]
            pub fn startup(&mut self) -> _STARTUPW {
                _STARTUPW { w: self }
            }
            #[doc = "Bit 12 - Write Lock"]
            #[inline(always)]
            pub fn wrtlock(&mut self) -> _WRTLOCKW {
                _WRTLOCKW { w: self }
            }
        }
    }
}
#[doc = "System Control"]
pub struct SYSCTRL {
    register_block: sysctrl::RegisterBlock,
}
impl Deref for SYSCTRL {
    type Target = sysctrl::RegisterBlock;
    fn deref(&self) -> &sysctrl::RegisterBlock {
        &self.register_block
    }
}

#[doc = "Timer Counter Control 0"]
pub const TCC0: Peripheral<TCC0> = unsafe { Peripheral::new(1107304448) };
#[doc = "Timer Counter Control 0"]
pub mod tcc0 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control A"]
        pub ctrla: CTRLA,
        #[doc = "0x04 - Control B Clear"]
        pub ctrlbclr: CTRLBCLR,
        #[doc = "0x05 - Control B Set"]
        pub ctrlbset: CTRLBSET,
        _reserved0: [u8; 2usize],
        #[doc = "0x08 - Synchronization Busy"]
        pub syncbusy: SYNCBUSY,
        #[doc = "0x0c - Recoverable FaultA Configuration"]
        pub fctrla: FCTRLA,
        #[doc = "0x10 - Recoverable FaultB Configuration"]
        pub fctrlb: FCTRLB,
        #[doc = "0x14 - Waveform Extension Configuration"]
        pub wexctrl: WEXCTRL,
        #[doc = "0x18 - Driver Configuration"]
        pub drvctrl: DRVCTRL,
        _reserved1: [u8; 2usize],
        #[doc = "0x1e - Debug Control"]
        pub dbgctrl: DBGCTRL,
        _reserved2: [u8; 1usize],
        #[doc = "0x20 - Event Control"]
        pub evctrl: EVCTRL,
        #[doc = "0x24 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x28 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x2c - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        #[doc = "0x30 - Status"]
        pub status: STATUS,
        #[doc = "0x34 - Count"]
        pub count: COUNT,
        #[doc = "0x38 - Pattern"]
        pub patt: PATT,
        _reserved3: [u8; 2usize],
        #[doc = "0x3c - Waveform Control"]
        pub wave: WAVE,
        #[doc = "0x40 - Period"]
        pub per: PER,
        #[doc = "0x44 - Compare and Capture"]
        pub cc0: CC,
        #[doc = "0x48 - Compare and Capture"]
        pub cc1: CC,
        #[doc = "0x4c - Compare and Capture"]
        pub cc2: CC,
        #[doc = "0x50 - Compare and Capture"]
        pub cc3: CC,
        _reserved4: [u8; 16usize],
        #[doc = "0x64 - Pattern Buffer"]
        pub pattb: PATTB,
        _reserved5: [u8; 2usize],
        #[doc = "0x68 - Waveform Control Buffer"]
        pub waveb: WAVEB,
        #[doc = "0x6c - Period Buffer"]
        pub perb: PERB,
        #[doc = "0x70 - Compare and Capture Buffer"]
        pub ccb0: CCB,
        #[doc = "0x74 - Compare and Capture Buffer"]
        pub ccb1: CCB,
        #[doc = "0x78 - Compare and Capture Buffer"]
        pub ccb2: CCB,
        #[doc = "0x7c - Compare and Capture Buffer"]
        pub ccb3: CCB,
    }
    #[doc = "Compare and Capture"]
    pub struct CC {
        register: VolatileCell<u32>,
    }
    #[doc = "Compare and Capture"]
    pub mod cc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CC {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR {
            bits: u32,
        }
        impl CCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 16777215;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Compare and Capture value"]
            #[inline(always)]
            pub fn cc(&self) -> CCR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Compare and Capture value"]
            #[inline(always)]
            pub fn cc(&mut self) -> _CCW {
                _CCW { w: self }
            }
        }
    }
    #[doc = "Compare and Capture Buffer"]
    pub struct CCB {
        register: VolatileCell<u32>,
    }
    #[doc = "Compare and Capture Buffer"]
    pub mod ccb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCB {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCBR {
            bits: u32,
        }
        impl CCBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 16777215;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Compare and Capture buffer value"]
            #[inline(always)]
            pub fn ccb(&self) -> CCBR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CCBR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Compare and Capture buffer value"]
            #[inline(always)]
            pub fn ccb(&mut self) -> _CCBW {
                _CCBW { w: self }
            }
        }
    }
    #[doc = "Count"]
    pub struct COUNT {
        register: VolatileCell<u32>,
    }
    #[doc = "Count"]
    pub mod count {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COUNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTR {
            bits: u32,
        }
        impl COUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _COUNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COUNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 16777215;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Count Value"]
            #[inline(always)]
            pub fn count(&self) -> COUNTR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                COUNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Count Value"]
            #[inline(always)]
            pub fn count(&mut self) -> _COUNTW {
                _COUNTW { w: self }
            }
        }
    }
    #[doc = "Control A"]
    pub struct CTRLA {
        register: VolatileCell<u32>,
    }
    #[doc = "Control A"]
    pub mod ctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `RESOLUTION`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESOLUTIONR {
            #[doc = "undocumented"]
            NONE,
            #[doc = "undocumented"]
            DITH4,
            #[doc = "undocumented"]
            DITH5,
            #[doc = "undocumented"]
            DITH6,
        }
        impl RESOLUTIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    RESOLUTIONR::NONE => 0,
                    RESOLUTIONR::DITH4 => 1,
                    RESOLUTIONR::DITH5 => 2,
                    RESOLUTIONR::DITH6 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> RESOLUTIONR {
                match value {
                    0 => RESOLUTIONR::NONE,
                    1 => RESOLUTIONR::DITH4,
                    2 => RESOLUTIONR::DITH5,
                    3 => RESOLUTIONR::DITH6,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == RESOLUTIONR::NONE
            }
            #[doc = "Checks if the value of the field is `DITH4`"]
            #[inline(always)]
            pub fn is_dith4(&self) -> bool {
                *self == RESOLUTIONR::DITH4
            }
            #[doc = "Checks if the value of the field is `DITH5`"]
            #[inline(always)]
            pub fn is_dith5(&self) -> bool {
                *self == RESOLUTIONR::DITH5
            }
            #[doc = "Checks if the value of the field is `DITH6`"]
            #[inline(always)]
            pub fn is_dith6(&self) -> bool {
                *self == RESOLUTIONR::DITH6
            }
        }
        #[doc = "Possible values of the field `PRESCALER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PRESCALERR {
            #[doc = "undocumented"]
            DIV1,
            #[doc = "undocumented"]
            DIV2,
            #[doc = "undocumented"]
            DIV4,
            #[doc = "undocumented"]
            DIV8,
            #[doc = "undocumented"]
            DIV16,
            #[doc = "undocumented"]
            DIV64,
            #[doc = "undocumented"]
            DIV256,
            #[doc = "undocumented"]
            DIV1024,
        }
        impl PRESCALERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    PRESCALERR::DIV1 => 0,
                    PRESCALERR::DIV2 => 1,
                    PRESCALERR::DIV4 => 2,
                    PRESCALERR::DIV8 => 3,
                    PRESCALERR::DIV16 => 4,
                    PRESCALERR::DIV64 => 5,
                    PRESCALERR::DIV256 => 6,
                    PRESCALERR::DIV1024 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> PRESCALERR {
                match value {
                    0 => PRESCALERR::DIV1,
                    1 => PRESCALERR::DIV2,
                    2 => PRESCALERR::DIV4,
                    3 => PRESCALERR::DIV8,
                    4 => PRESCALERR::DIV16,
                    5 => PRESCALERR::DIV64,
                    6 => PRESCALERR::DIV256,
                    7 => PRESCALERR::DIV1024,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == PRESCALERR::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == PRESCALERR::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == PRESCALERR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == PRESCALERR::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == PRESCALERR::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == PRESCALERR::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV256`"]
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == PRESCALERR::DIV256
            }
            #[doc = "Checks if the value of the field is `DIV1024`"]
            #[inline(always)]
            pub fn is_div1024(&self) -> bool {
                *self == PRESCALERR::DIV1024
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `PRESCSYNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PRESCSYNCR {
            #[doc = "undocumented"]
            GCLK,
            #[doc = "undocumented"]
            PRESC,
            #[doc = "undocumented"]
            RESYNC,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PRESCSYNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    PRESCSYNCR::GCLK => 0,
                    PRESCSYNCR::PRESC => 1,
                    PRESCSYNCR::RESYNC => 2,
                    PRESCSYNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> PRESCSYNCR {
                match value {
                    0 => PRESCSYNCR::GCLK,
                    1 => PRESCSYNCR::PRESC,
                    2 => PRESCSYNCR::RESYNC,
                    i => PRESCSYNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `GCLK`"]
            #[inline(always)]
            pub fn is_gclk(&self) -> bool {
                *self == PRESCSYNCR::GCLK
            }
            #[doc = "Checks if the value of the field is `PRESC`"]
            #[inline(always)]
            pub fn is_presc(&self) -> bool {
                *self == PRESCSYNCR::PRESC
            }
            #[doc = "Checks if the value of the field is `RESYNC`"]
            #[inline(always)]
            pub fn is_resync(&self) -> bool {
                *self == PRESCSYNCR::RESYNC
            }
        }
        #[doc = r" Value of the field"]
        pub struct ALOCKR {
            bits: bool,
        }
        impl ALOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSYNCR {
            bits: bool,
        }
        impl MSYNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CPTEN0R {
            bits: bool,
        }
        impl CPTEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CPTEN1R {
            bits: bool,
        }
        impl CPTEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CPTEN2R {
            bits: bool,
        }
        impl CPTEN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CPTEN3R {
            bits: bool,
        }
        impl CPTEN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RESOLUTION`"]
        pub enum RESOLUTIONW {
            #[doc = "`0`"]
            NONE,
            #[doc = "`1`"]
            DITH4,
            #[doc = "`10`"]
            DITH5,
            #[doc = "`11`"]
            DITH6,
        }
        impl RESOLUTIONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RESOLUTIONW::NONE => 0,
                    RESOLUTIONW::DITH4 => 1,
                    RESOLUTIONW::DITH5 => 2,
                    RESOLUTIONW::DITH6 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESOLUTIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESOLUTIONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RESOLUTIONW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(RESOLUTIONW::NONE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn dith4(self) -> &'a mut W {
                self.variant(RESOLUTIONW::DITH4)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn dith5(self) -> &'a mut W {
                self.variant(RESOLUTIONW::DITH5)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn dith6(self) -> &'a mut W {
                self.variant(RESOLUTIONW::DITH6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PRESCALER`"]
        pub enum PRESCALERW {
            #[doc = "`0`"]
            DIV1,
            #[doc = "`1`"]
            DIV2,
            #[doc = "`10`"]
            DIV4,
            #[doc = "`11`"]
            DIV8,
            #[doc = "`100`"]
            DIV16,
            #[doc = "`101`"]
            DIV64,
            #[doc = "`110`"]
            DIV256,
            #[doc = "`111`"]
            DIV1024,
        }
        impl PRESCALERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PRESCALERW::DIV1 => 0,
                    PRESCALERW::DIV2 => 1,
                    PRESCALERW::DIV4 => 2,
                    PRESCALERW::DIV8 => 3,
                    PRESCALERW::DIV16 => 4,
                    PRESCALERW::DIV64 => 5,
                    PRESCALERW::DIV256 => 6,
                    PRESCALERW::DIV1024 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRESCALERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRESCALERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PRESCALERW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV1)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV2)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV4)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV8)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV16)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV64)
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV256)
            }
            #[doc = "`111`"]
            #[inline(always)]
            pub fn div1024(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV1024)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PRESCSYNC`"]
        pub enum PRESCSYNCW {
            #[doc = "`0`"]
            GCLK,
            #[doc = "`1`"]
            PRESC,
            #[doc = "`10`"]
            RESYNC,
        }
        impl PRESCSYNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PRESCSYNCW::GCLK => 0,
                    PRESCSYNCW::PRESC => 1,
                    PRESCSYNCW::RESYNC => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRESCSYNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRESCSYNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PRESCSYNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn gclk(self) -> &'a mut W {
                self.variant(PRESCSYNCW::GCLK)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn presc(self) -> &'a mut W {
                self.variant(PRESCSYNCW::PRESC)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn resync(self) -> &'a mut W {
                self.variant(PRESCSYNCW::RESYNC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSYNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSYNCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPTEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPTEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPTEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPTEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPTEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPTEN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPTEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPTEN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWRSTR { bits }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bits 5:6 - Enhanced Resolution"]
            #[inline(always)]
            pub fn resolution(&self) -> RESOLUTIONR {
                RESOLUTIONR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:10 - Prescaler"]
            #[inline(always)]
            pub fn prescaler(&self) -> PRESCALERR {
                PRESCALERR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 11 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bits 12:13 - Prescaler and Counter Synchronization Selection"]
            #[inline(always)]
            pub fn prescsync(&self) -> PRESCSYNCR {
                PRESCSYNCR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 14 - Auto Lock"]
            #[inline(always)]
            pub fn alock(&self) -> ALOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ALOCKR { bits }
            }
            #[doc = "Bit 15 - Master Synchronization"]
            #[inline(always)]
            pub fn msync(&self) -> MSYNCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MSYNCR { bits }
            }
            #[doc = "Bit 24 - Capture Channel 0 Enable"]
            #[inline(always)]
            pub fn cpten0(&self) -> CPTEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CPTEN0R { bits }
            }
            #[doc = "Bit 25 - Capture Channel 1 Enable"]
            #[inline(always)]
            pub fn cpten1(&self) -> CPTEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CPTEN1R { bits }
            }
            #[doc = "Bit 26 - Capture Channel 2 Enable"]
            #[inline(always)]
            pub fn cpten2(&self) -> CPTEN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CPTEN2R { bits }
            }
            #[doc = "Bit 27 - Capture Channel 3 Enable"]
            #[inline(always)]
            pub fn cpten3(&self) -> CPTEN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CPTEN3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bits 5:6 - Enhanced Resolution"]
            #[inline(always)]
            pub fn resolution(&mut self) -> _RESOLUTIONW {
                _RESOLUTIONW { w: self }
            }
            #[doc = "Bits 8:10 - Prescaler"]
            #[inline(always)]
            pub fn prescaler(&mut self) -> _PRESCALERW {
                _PRESCALERW { w: self }
            }
            #[doc = "Bit 11 - Run in Standby"]
            #[inline(always)]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bits 12:13 - Prescaler and Counter Synchronization Selection"]
            #[inline(always)]
            pub fn prescsync(&mut self) -> _PRESCSYNCW {
                _PRESCSYNCW { w: self }
            }
            #[doc = "Bit 14 - Auto Lock"]
            #[inline(always)]
            pub fn alock(&mut self) -> _ALOCKW {
                _ALOCKW { w: self }
            }
            #[doc = "Bit 15 - Master Synchronization"]
            #[inline(always)]
            pub fn msync(&mut self) -> _MSYNCW {
                _MSYNCW { w: self }
            }
            #[doc = "Bit 24 - Capture Channel 0 Enable"]
            #[inline(always)]
            pub fn cpten0(&mut self) -> _CPTEN0W {
                _CPTEN0W { w: self }
            }
            #[doc = "Bit 25 - Capture Channel 1 Enable"]
            #[inline(always)]
            pub fn cpten1(&mut self) -> _CPTEN1W {
                _CPTEN1W { w: self }
            }
            #[doc = "Bit 26 - Capture Channel 2 Enable"]
            #[inline(always)]
            pub fn cpten2(&mut self) -> _CPTEN2W {
                _CPTEN2W { w: self }
            }
            #[doc = "Bit 27 - Capture Channel 3 Enable"]
            #[inline(always)]
            pub fn cpten3(&mut self) -> _CPTEN3W {
                _CPTEN3W { w: self }
            }
        }
    }
    #[doc = "Control B Clear"]
    pub struct CTRLBCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Control B Clear"]
    pub mod ctrlbclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLBCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRR {
            bits: bool,
        }
        impl DIRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LUPDR {
            bits: bool,
        }
        impl LUPDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONESHOTR {
            bits: bool,
        }
        impl ONESHOTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `IDXCMD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDXCMDR {
            #[doc = "undocumented"]
            DISABLE,
            #[doc = "undocumented"]
            SET,
            #[doc = "undocumented"]
            CLEAR,
            #[doc = "undocumented"]
            HOLD,
        }
        impl IDXCMDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    IDXCMDR::DISABLE => 0,
                    IDXCMDR::SET => 1,
                    IDXCMDR::CLEAR => 2,
                    IDXCMDR::HOLD => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> IDXCMDR {
                match value {
                    0 => IDXCMDR::DISABLE,
                    1 => IDXCMDR::SET,
                    2 => IDXCMDR::CLEAR,
                    3 => IDXCMDR::HOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == IDXCMDR::DISABLE
            }
            #[doc = "Checks if the value of the field is `SET`"]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == IDXCMDR::SET
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == IDXCMDR::CLEAR
            }
            #[doc = "Checks if the value of the field is `HOLD`"]
            #[inline(always)]
            pub fn is_hold(&self) -> bool {
                *self == IDXCMDR::HOLD
            }
        }
        #[doc = "Possible values of the field `CMD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMDR {
            #[doc = "undocumented"]
            NONE,
            #[doc = "undocumented"]
            RETRIGGER,
            #[doc = "undocumented"]
            STOP,
            #[doc = "undocumented"]
            UPDATE,
            #[doc = "undocumented"]
            READSYNC,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CMDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMDR::NONE => 0,
                    CMDR::RETRIGGER => 1,
                    CMDR::STOP => 2,
                    CMDR::UPDATE => 3,
                    CMDR::READSYNC => 4,
                    CMDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CMDR {
                match value {
                    0 => CMDR::NONE,
                    1 => CMDR::RETRIGGER,
                    2 => CMDR::STOP,
                    3 => CMDR::UPDATE,
                    4 => CMDR::READSYNC,
                    i => CMDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == CMDR::NONE
            }
            #[doc = "Checks if the value of the field is `RETRIGGER`"]
            #[inline(always)]
            pub fn is_retrigger(&self) -> bool {
                *self == CMDR::RETRIGGER
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == CMDR::STOP
            }
            #[doc = "Checks if the value of the field is `UPDATE`"]
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                *self == CMDR::UPDATE
            }
            #[doc = "Checks if the value of the field is `READSYNC`"]
            #[inline(always)]
            pub fn is_readsync(&self) -> bool {
                *self == CMDR::READSYNC
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LUPDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LUPDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONESHOTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONESHOTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IDXCMD`"]
        pub enum IDXCMDW {
            #[doc = "`0`"]
            DISABLE,
            #[doc = "`1`"]
            SET,
            #[doc = "`10`"]
            CLEAR,
            #[doc = "`11`"]
            HOLD,
        }
        impl IDXCMDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IDXCMDW::DISABLE => 0,
                    IDXCMDW::SET => 1,
                    IDXCMDW::CLEAR => 2,
                    IDXCMDW::HOLD => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDXCMDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDXCMDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IDXCMDW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(IDXCMDW::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(IDXCMDW::SET)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(IDXCMDW::CLEAR)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn hold(self) -> &'a mut W {
                self.variant(IDXCMDW::HOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CMD`"]
        pub enum CMDW {
            #[doc = "`0`"]
            NONE,
            #[doc = "`1`"]
            RETRIGGER,
            #[doc = "`10`"]
            STOP,
            #[doc = "`11`"]
            UPDATE,
            #[doc = "`100`"]
            READSYNC,
        }
        impl CMDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMDW::NONE => 0,
                    CMDW::RETRIGGER => 1,
                    CMDW::STOP => 2,
                    CMDW::UPDATE => 3,
                    CMDW::READSYNC => 4,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(CMDW::NONE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn retrigger(self) -> &'a mut W {
                self.variant(CMDW::RETRIGGER)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(CMDW::STOP)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(CMDW::UPDATE)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn readsync(self) -> &'a mut W {
                self.variant(CMDW::READSYNC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Counter Direction"]
            #[inline(always)]
            pub fn dir(&self) -> DIRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DIRR { bits }
            }
            #[doc = "Bit 1 - Lock Update"]
            #[inline(always)]
            pub fn lupd(&self) -> LUPDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                LUPDR { bits }
            }
            #[doc = "Bit 2 - One-Shot"]
            #[inline(always)]
            pub fn oneshot(&self) -> ONESHOTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ONESHOTR { bits }
            }
            #[doc = "Bits 3:4 - Ramp Index Command"]
            #[inline(always)]
            pub fn idxcmd(&self) -> IDXCMDR {
                IDXCMDR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bits 5:7 - TCC Command"]
            #[inline(always)]
            pub fn cmd(&self) -> CMDR {
                CMDR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Counter Direction"]
            #[inline(always)]
            pub fn dir(&mut self) -> _DIRW {
                _DIRW { w: self }
            }
            #[doc = "Bit 1 - Lock Update"]
            #[inline(always)]
            pub fn lupd(&mut self) -> _LUPDW {
                _LUPDW { w: self }
            }
            #[doc = "Bit 2 - One-Shot"]
            #[inline(always)]
            pub fn oneshot(&mut self) -> _ONESHOTW {
                _ONESHOTW { w: self }
            }
            #[doc = "Bits 3:4 - Ramp Index Command"]
            #[inline(always)]
            pub fn idxcmd(&mut self) -> _IDXCMDW {
                _IDXCMDW { w: self }
            }
            #[doc = "Bits 5:7 - TCC Command"]
            #[inline(always)]
            pub fn cmd(&mut self) -> _CMDW {
                _CMDW { w: self }
            }
        }
    }
    #[doc = "Control B Set"]
    pub struct CTRLBSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Control B Set"]
    pub mod ctrlbset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLBSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRR {
            bits: bool,
        }
        impl DIRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LUPDR {
            bits: bool,
        }
        impl LUPDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONESHOTR {
            bits: bool,
        }
        impl ONESHOTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `IDXCMD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDXCMDR {
            #[doc = "undocumented"]
            DISABLE,
            #[doc = "undocumented"]
            SET,
            #[doc = "undocumented"]
            CLEAR,
            #[doc = "undocumented"]
            HOLD,
        }
        impl IDXCMDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    IDXCMDR::DISABLE => 0,
                    IDXCMDR::SET => 1,
                    IDXCMDR::CLEAR => 2,
                    IDXCMDR::HOLD => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> IDXCMDR {
                match value {
                    0 => IDXCMDR::DISABLE,
                    1 => IDXCMDR::SET,
                    2 => IDXCMDR::CLEAR,
                    3 => IDXCMDR::HOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == IDXCMDR::DISABLE
            }
            #[doc = "Checks if the value of the field is `SET`"]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == IDXCMDR::SET
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == IDXCMDR::CLEAR
            }
            #[doc = "Checks if the value of the field is `HOLD`"]
            #[inline(always)]
            pub fn is_hold(&self) -> bool {
                *self == IDXCMDR::HOLD
            }
        }
        #[doc = "Possible values of the field `CMD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMDR {
            #[doc = "undocumented"]
            NONE,
            #[doc = "undocumented"]
            RETRIGGER,
            #[doc = "undocumented"]
            STOP,
            #[doc = "undocumented"]
            UPDATE,
            #[doc = "undocumented"]
            READSYNC,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CMDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMDR::NONE => 0,
                    CMDR::RETRIGGER => 1,
                    CMDR::STOP => 2,
                    CMDR::UPDATE => 3,
                    CMDR::READSYNC => 4,
                    CMDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CMDR {
                match value {
                    0 => CMDR::NONE,
                    1 => CMDR::RETRIGGER,
                    2 => CMDR::STOP,
                    3 => CMDR::UPDATE,
                    4 => CMDR::READSYNC,
                    i => CMDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == CMDR::NONE
            }
            #[doc = "Checks if the value of the field is `RETRIGGER`"]
            #[inline(always)]
            pub fn is_retrigger(&self) -> bool {
                *self == CMDR::RETRIGGER
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == CMDR::STOP
            }
            #[doc = "Checks if the value of the field is `UPDATE`"]
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                *self == CMDR::UPDATE
            }
            #[doc = "Checks if the value of the field is `READSYNC`"]
            #[inline(always)]
            pub fn is_readsync(&self) -> bool {
                *self == CMDR::READSYNC
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LUPDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LUPDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONESHOTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONESHOTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IDXCMD`"]
        pub enum IDXCMDW {
            #[doc = "`0`"]
            DISABLE,
            #[doc = "`1`"]
            SET,
            #[doc = "`10`"]
            CLEAR,
            #[doc = "`11`"]
            HOLD,
        }
        impl IDXCMDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IDXCMDW::DISABLE => 0,
                    IDXCMDW::SET => 1,
                    IDXCMDW::CLEAR => 2,
                    IDXCMDW::HOLD => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDXCMDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDXCMDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IDXCMDW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(IDXCMDW::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(IDXCMDW::SET)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(IDXCMDW::CLEAR)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn hold(self) -> &'a mut W {
                self.variant(IDXCMDW::HOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CMD`"]
        pub enum CMDW {
            #[doc = "`0`"]
            NONE,
            #[doc = "`1`"]
            RETRIGGER,
            #[doc = "`10`"]
            STOP,
            #[doc = "`11`"]
            UPDATE,
            #[doc = "`100`"]
            READSYNC,
        }
        impl CMDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMDW::NONE => 0,
                    CMDW::RETRIGGER => 1,
                    CMDW::STOP => 2,
                    CMDW::UPDATE => 3,
                    CMDW::READSYNC => 4,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(CMDW::NONE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn retrigger(self) -> &'a mut W {
                self.variant(CMDW::RETRIGGER)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(CMDW::STOP)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(CMDW::UPDATE)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn readsync(self) -> &'a mut W {
                self.variant(CMDW::READSYNC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Counter Direction"]
            #[inline(always)]
            pub fn dir(&self) -> DIRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DIRR { bits }
            }
            #[doc = "Bit 1 - Lock update"]
            #[inline(always)]
            pub fn lupd(&self) -> LUPDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                LUPDR { bits }
            }
            #[doc = "Bit 2 - One-Shot"]
            #[inline(always)]
            pub fn oneshot(&self) -> ONESHOTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ONESHOTR { bits }
            }
            #[doc = "Bits 3:4 - Ramp Index Command"]
            #[inline(always)]
            pub fn idxcmd(&self) -> IDXCMDR {
                IDXCMDR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bits 5:7 - TCC Command"]
            #[inline(always)]
            pub fn cmd(&self) -> CMDR {
                CMDR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Counter Direction"]
            #[inline(always)]
            pub fn dir(&mut self) -> _DIRW {
                _DIRW { w: self }
            }
            #[doc = "Bit 1 - Lock update"]
            #[inline(always)]
            pub fn lupd(&mut self) -> _LUPDW {
                _LUPDW { w: self }
            }
            #[doc = "Bit 2 - One-Shot"]
            #[inline(always)]
            pub fn oneshot(&mut self) -> _ONESHOTW {
                _ONESHOTW { w: self }
            }
            #[doc = "Bits 3:4 - Ramp Index Command"]
            #[inline(always)]
            pub fn idxcmd(&mut self) -> _IDXCMDW {
                _IDXCMDW { w: self }
            }
            #[doc = "Bits 5:7 - TCC Command"]
            #[inline(always)]
            pub fn cmd(&mut self) -> _CMDW {
                _CMDW { w: self }
            }
        }
    }
    #[doc = "Debug Control"]
    pub struct DBGCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Debug Control"]
    pub mod dbgctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::DBGCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBGRUNR {
            bits: bool,
        }
        impl DBGRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FDDBDR {
            bits: bool,
        }
        impl FDDBDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBGRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBGRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FDDBDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FDDBDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Debug Running Mode"]
            #[inline(always)]
            pub fn dbgrun(&self) -> DBGRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DBGRUNR { bits }
            }
            #[doc = "Bit 2 - Fault Detection on Debug Break Detection"]
            #[inline(always)]
            pub fn fddbd(&self) -> FDDBDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                FDDBDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Debug Running Mode"]
            #[inline(always)]
            pub fn dbgrun(&mut self) -> _DBGRUNW {
                _DBGRUNW { w: self }
            }
            #[doc = "Bit 2 - Fault Detection on Debug Break Detection"]
            #[inline(always)]
            pub fn fddbd(&mut self) -> _FDDBDW {
                _FDDBDW { w: self }
            }
        }
    }
    #[doc = "Driver Configuration"]
    pub struct DRVCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Driver Configuration"]
    pub mod drvctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DRVCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRE0R {
            bits: bool,
        }
        impl NRE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRE1R {
            bits: bool,
        }
        impl NRE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRE2R {
            bits: bool,
        }
        impl NRE2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRE3R {
            bits: bool,
        }
        impl NRE3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRE4R {
            bits: bool,
        }
        impl NRE4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRE5R {
            bits: bool,
        }
        impl NRE5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRE6R {
            bits: bool,
        }
        impl NRE6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRE7R {
            bits: bool,
        }
        impl NRE7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRV0R {
            bits: bool,
        }
        impl NRV0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRV1R {
            bits: bool,
        }
        impl NRV1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRV2R {
            bits: bool,
        }
        impl NRV2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRV3R {
            bits: bool,
        }
        impl NRV3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRV4R {
            bits: bool,
        }
        impl NRV4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRV5R {
            bits: bool,
        }
        impl NRV5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRV6R {
            bits: bool,
        }
        impl NRV6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRV7R {
            bits: bool,
        }
        impl NRV7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INVEN0R {
            bits: bool,
        }
        impl INVEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INVEN1R {
            bits: bool,
        }
        impl INVEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INVEN2R {
            bits: bool,
        }
        impl INVEN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INVEN3R {
            bits: bool,
        }
        impl INVEN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INVEN4R {
            bits: bool,
        }
        impl INVEN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INVEN5R {
            bits: bool,
        }
        impl INVEN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INVEN6R {
            bits: bool,
        }
        impl INVEN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INVEN7R {
            bits: bool,
        }
        impl INVEN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTERVAL0R {
            bits: u8,
        }
        impl FILTERVAL0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTERVAL1R {
            bits: u8,
        }
        impl FILTERVAL1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRE0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRE1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRE2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRE3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRE4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRE4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRE5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRE5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRE6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRE6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRE7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRE7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRV0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRV0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRV1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRV1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRV2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRV2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRV3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRV3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRV4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRV4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRV5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRV5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRV6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRV6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRV7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRV7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVEN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVEN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVEN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVEN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVEN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVEN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVEN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVEN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVEN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVEN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTERVAL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTERVAL0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTERVAL1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTERVAL1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Non-Recoverable State 0 Output Enable"]
            #[inline(always)]
            pub fn nre0(&self) -> NRE0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRE0R { bits }
            }
            #[doc = "Bit 1 - Non-Recoverable State 1 Output Enable"]
            #[inline(always)]
            pub fn nre1(&self) -> NRE1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRE1R { bits }
            }
            #[doc = "Bit 2 - Non-Recoverable State 2 Output Enable"]
            #[inline(always)]
            pub fn nre2(&self) -> NRE2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRE2R { bits }
            }
            #[doc = "Bit 3 - Non-Recoverable State 3 Output Enable"]
            #[inline(always)]
            pub fn nre3(&self) -> NRE3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRE3R { bits }
            }
            #[doc = "Bit 4 - Non-Recoverable State 4 Output Enable"]
            #[inline(always)]
            pub fn nre4(&self) -> NRE4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRE4R { bits }
            }
            #[doc = "Bit 5 - Non-Recoverable State 5 Output Enable"]
            #[inline(always)]
            pub fn nre5(&self) -> NRE5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRE5R { bits }
            }
            #[doc = "Bit 6 - Non-Recoverable State 6 Output Enable"]
            #[inline(always)]
            pub fn nre6(&self) -> NRE6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRE6R { bits }
            }
            #[doc = "Bit 7 - Non-Recoverable State 7 Output Enable"]
            #[inline(always)]
            pub fn nre7(&self) -> NRE7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRE7R { bits }
            }
            #[doc = "Bit 8 - Non-Recoverable State 0 Output Value"]
            #[inline(always)]
            pub fn nrv0(&self) -> NRV0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRV0R { bits }
            }
            #[doc = "Bit 9 - Non-Recoverable State 1 Output Value"]
            #[inline(always)]
            pub fn nrv1(&self) -> NRV1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRV1R { bits }
            }
            #[doc = "Bit 10 - Non-Recoverable State 2 Output Value"]
            #[inline(always)]
            pub fn nrv2(&self) -> NRV2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRV2R { bits }
            }
            #[doc = "Bit 11 - Non-Recoverable State 3 Output Value"]
            #[inline(always)]
            pub fn nrv3(&self) -> NRV3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRV3R { bits }
            }
            #[doc = "Bit 12 - Non-Recoverable State 4 Output Value"]
            #[inline(always)]
            pub fn nrv4(&self) -> NRV4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRV4R { bits }
            }
            #[doc = "Bit 13 - Non-Recoverable State 5 Output Value"]
            #[inline(always)]
            pub fn nrv5(&self) -> NRV5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRV5R { bits }
            }
            #[doc = "Bit 14 - Non-Recoverable State 6 Output Value"]
            #[inline(always)]
            pub fn nrv6(&self) -> NRV6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRV6R { bits }
            }
            #[doc = "Bit 15 - Non-Recoverable State 7 Output Value"]
            #[inline(always)]
            pub fn nrv7(&self) -> NRV7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRV7R { bits }
            }
            #[doc = "Bit 16 - Output Waveform 0 Inversion"]
            #[inline(always)]
            pub fn inven0(&self) -> INVEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INVEN0R { bits }
            }
            #[doc = "Bit 17 - Output Waveform 1 Inversion"]
            #[inline(always)]
            pub fn inven1(&self) -> INVEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INVEN1R { bits }
            }
            #[doc = "Bit 18 - Output Waveform 2 Inversion"]
            #[inline(always)]
            pub fn inven2(&self) -> INVEN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INVEN2R { bits }
            }
            #[doc = "Bit 19 - Output Waveform 3 Inversion"]
            #[inline(always)]
            pub fn inven3(&self) -> INVEN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INVEN3R { bits }
            }
            #[doc = "Bit 20 - Output Waveform 4 Inversion"]
            #[inline(always)]
            pub fn inven4(&self) -> INVEN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INVEN4R { bits }
            }
            #[doc = "Bit 21 - Output Waveform 5 Inversion"]
            #[inline(always)]
            pub fn inven5(&self) -> INVEN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INVEN5R { bits }
            }
            #[doc = "Bit 22 - Output Waveform 6 Inversion"]
            #[inline(always)]
            pub fn inven6(&self) -> INVEN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INVEN6R { bits }
            }
            #[doc = "Bit 23 - Output Waveform 7 Inversion"]
            #[inline(always)]
            pub fn inven7(&self) -> INVEN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INVEN7R { bits }
            }
            #[doc = "Bits 24:27 - Non-Recoverable Fault Input 0 Filter Value"]
            #[inline(always)]
            pub fn filterval0(&self) -> FILTERVAL0R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FILTERVAL0R { bits }
            }
            #[doc = "Bits 28:31 - Non-Recoverable Fault Input 1 Filter Value"]
            #[inline(always)]
            pub fn filterval1(&self) -> FILTERVAL1R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FILTERVAL1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Non-Recoverable State 0 Output Enable"]
            #[inline(always)]
            pub fn nre0(&mut self) -> _NRE0W {
                _NRE0W { w: self }
            }
            #[doc = "Bit 1 - Non-Recoverable State 1 Output Enable"]
            #[inline(always)]
            pub fn nre1(&mut self) -> _NRE1W {
                _NRE1W { w: self }
            }
            #[doc = "Bit 2 - Non-Recoverable State 2 Output Enable"]
            #[inline(always)]
            pub fn nre2(&mut self) -> _NRE2W {
                _NRE2W { w: self }
            }
            #[doc = "Bit 3 - Non-Recoverable State 3 Output Enable"]
            #[inline(always)]
            pub fn nre3(&mut self) -> _NRE3W {
                _NRE3W { w: self }
            }
            #[doc = "Bit 4 - Non-Recoverable State 4 Output Enable"]
            #[inline(always)]
            pub fn nre4(&mut self) -> _NRE4W {
                _NRE4W { w: self }
            }
            #[doc = "Bit 5 - Non-Recoverable State 5 Output Enable"]
            #[inline(always)]
            pub fn nre5(&mut self) -> _NRE5W {
                _NRE5W { w: self }
            }
            #[doc = "Bit 6 - Non-Recoverable State 6 Output Enable"]
            #[inline(always)]
            pub fn nre6(&mut self) -> _NRE6W {
                _NRE6W { w: self }
            }
            #[doc = "Bit 7 - Non-Recoverable State 7 Output Enable"]
            #[inline(always)]
            pub fn nre7(&mut self) -> _NRE7W {
                _NRE7W { w: self }
            }
            #[doc = "Bit 8 - Non-Recoverable State 0 Output Value"]
            #[inline(always)]
            pub fn nrv0(&mut self) -> _NRV0W {
                _NRV0W { w: self }
            }
            #[doc = "Bit 9 - Non-Recoverable State 1 Output Value"]
            #[inline(always)]
            pub fn nrv1(&mut self) -> _NRV1W {
                _NRV1W { w: self }
            }
            #[doc = "Bit 10 - Non-Recoverable State 2 Output Value"]
            #[inline(always)]
            pub fn nrv2(&mut self) -> _NRV2W {
                _NRV2W { w: self }
            }
            #[doc = "Bit 11 - Non-Recoverable State 3 Output Value"]
            #[inline(always)]
            pub fn nrv3(&mut self) -> _NRV3W {
                _NRV3W { w: self }
            }
            #[doc = "Bit 12 - Non-Recoverable State 4 Output Value"]
            #[inline(always)]
            pub fn nrv4(&mut self) -> _NRV4W {
                _NRV4W { w: self }
            }
            #[doc = "Bit 13 - Non-Recoverable State 5 Output Value"]
            #[inline(always)]
            pub fn nrv5(&mut self) -> _NRV5W {
                _NRV5W { w: self }
            }
            #[doc = "Bit 14 - Non-Recoverable State 6 Output Value"]
            #[inline(always)]
            pub fn nrv6(&mut self) -> _NRV6W {
                _NRV6W { w: self }
            }
            #[doc = "Bit 15 - Non-Recoverable State 7 Output Value"]
            #[inline(always)]
            pub fn nrv7(&mut self) -> _NRV7W {
                _NRV7W { w: self }
            }
            #[doc = "Bit 16 - Output Waveform 0 Inversion"]
            #[inline(always)]
            pub fn inven0(&mut self) -> _INVEN0W {
                _INVEN0W { w: self }
            }
            #[doc = "Bit 17 - Output Waveform 1 Inversion"]
            #[inline(always)]
            pub fn inven1(&mut self) -> _INVEN1W {
                _INVEN1W { w: self }
            }
            #[doc = "Bit 18 - Output Waveform 2 Inversion"]
            #[inline(always)]
            pub fn inven2(&mut self) -> _INVEN2W {
                _INVEN2W { w: self }
            }
            #[doc = "Bit 19 - Output Waveform 3 Inversion"]
            #[inline(always)]
            pub fn inven3(&mut self) -> _INVEN3W {
                _INVEN3W { w: self }
            }
            #[doc = "Bit 20 - Output Waveform 4 Inversion"]
            #[inline(always)]
            pub fn inven4(&mut self) -> _INVEN4W {
                _INVEN4W { w: self }
            }
            #[doc = "Bit 21 - Output Waveform 5 Inversion"]
            #[inline(always)]
            pub fn inven5(&mut self) -> _INVEN5W {
                _INVEN5W { w: self }
            }
            #[doc = "Bit 22 - Output Waveform 6 Inversion"]
            #[inline(always)]
            pub fn inven6(&mut self) -> _INVEN6W {
                _INVEN6W { w: self }
            }
            #[doc = "Bit 23 - Output Waveform 7 Inversion"]
            #[inline(always)]
            pub fn inven7(&mut self) -> _INVEN7W {
                _INVEN7W { w: self }
            }
            #[doc = "Bits 24:27 - Non-Recoverable Fault Input 0 Filter Value"]
            #[inline(always)]
            pub fn filterval0(&mut self) -> _FILTERVAL0W {
                _FILTERVAL0W { w: self }
            }
            #[doc = "Bits 28:31 - Non-Recoverable Fault Input 1 Filter Value"]
            #[inline(always)]
            pub fn filterval1(&mut self) -> _FILTERVAL1W {
                _FILTERVAL1W { w: self }
            }
        }
    }
    #[doc = "Event Control"]
    pub struct EVCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Event Control"]
    pub mod evctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `EVACT0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EVACT0R {
            #[doc = "undocumented"]
            OFF,
            #[doc = "undocumented"]
            RETRIGGER,
            #[doc = "undocumented"]
            COUNTEV,
            #[doc = "undocumented"]
            START,
            #[doc = "undocumented"]
            INC,
            #[doc = "undocumented"]
            COUNT,
            #[doc = "undocumented"]
            FAULT,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl EVACT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    EVACT0R::OFF => 0,
                    EVACT0R::RETRIGGER => 1,
                    EVACT0R::COUNTEV => 2,
                    EVACT0R::START => 3,
                    EVACT0R::INC => 4,
                    EVACT0R::COUNT => 5,
                    EVACT0R::FAULT => 7,
                    EVACT0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> EVACT0R {
                match value {
                    0 => EVACT0R::OFF,
                    1 => EVACT0R::RETRIGGER,
                    2 => EVACT0R::COUNTEV,
                    3 => EVACT0R::START,
                    4 => EVACT0R::INC,
                    5 => EVACT0R::COUNT,
                    7 => EVACT0R::FAULT,
                    i => EVACT0R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == EVACT0R::OFF
            }
            #[doc = "Checks if the value of the field is `RETRIGGER`"]
            #[inline(always)]
            pub fn is_retrigger(&self) -> bool {
                *self == EVACT0R::RETRIGGER
            }
            #[doc = "Checks if the value of the field is `COUNTEV`"]
            #[inline(always)]
            pub fn is_countev(&self) -> bool {
                *self == EVACT0R::COUNTEV
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == EVACT0R::START
            }
            #[doc = "Checks if the value of the field is `INC`"]
            #[inline(always)]
            pub fn is_inc(&self) -> bool {
                *self == EVACT0R::INC
            }
            #[doc = "Checks if the value of the field is `COUNT`"]
            #[inline(always)]
            pub fn is_count(&self) -> bool {
                *self == EVACT0R::COUNT
            }
            #[doc = "Checks if the value of the field is `FAULT`"]
            #[inline(always)]
            pub fn is_fault(&self) -> bool {
                *self == EVACT0R::FAULT
            }
        }
        #[doc = "Possible values of the field `EVACT1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EVACT1R {
            #[doc = "undocumented"]
            OFF,
            #[doc = "undocumented"]
            RETRIGGER,
            #[doc = "undocumented"]
            DIR,
            #[doc = "undocumented"]
            STOP,
            #[doc = "undocumented"]
            DEC,
            #[doc = "undocumented"]
            PPW,
            #[doc = "undocumented"]
            PWP,
            #[doc = "undocumented"]
            FAULT,
        }
        impl EVACT1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    EVACT1R::OFF => 0,
                    EVACT1R::RETRIGGER => 1,
                    EVACT1R::DIR => 2,
                    EVACT1R::STOP => 3,
                    EVACT1R::DEC => 4,
                    EVACT1R::PPW => 5,
                    EVACT1R::PWP => 6,
                    EVACT1R::FAULT => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> EVACT1R {
                match value {
                    0 => EVACT1R::OFF,
                    1 => EVACT1R::RETRIGGER,
                    2 => EVACT1R::DIR,
                    3 => EVACT1R::STOP,
                    4 => EVACT1R::DEC,
                    5 => EVACT1R::PPW,
                    6 => EVACT1R::PWP,
                    7 => EVACT1R::FAULT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == EVACT1R::OFF
            }
            #[doc = "Checks if the value of the field is `RETRIGGER`"]
            #[inline(always)]
            pub fn is_retrigger(&self) -> bool {
                *self == EVACT1R::RETRIGGER
            }
            #[doc = "Checks if the value of the field is `DIR`"]
            #[inline(always)]
            pub fn is_dir(&self) -> bool {
                *self == EVACT1R::DIR
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == EVACT1R::STOP
            }
            #[doc = "Checks if the value of the field is `DEC`"]
            #[inline(always)]
            pub fn is_dec(&self) -> bool {
                *self == EVACT1R::DEC
            }
            #[doc = "Checks if the value of the field is `PPW`"]
            #[inline(always)]
            pub fn is_ppw(&self) -> bool {
                *self == EVACT1R::PPW
            }
            #[doc = "Checks if the value of the field is `PWP`"]
            #[inline(always)]
            pub fn is_pwp(&self) -> bool {
                *self == EVACT1R::PWP
            }
            #[doc = "Checks if the value of the field is `FAULT`"]
            #[inline(always)]
            pub fn is_fault(&self) -> bool {
                *self == EVACT1R::FAULT
            }
        }
        #[doc = "Possible values of the field `CNTSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CNTSELR {
            #[doc = "undocumented"]
            START,
            #[doc = "undocumented"]
            END,
            #[doc = "undocumented"]
            BETWEEN,
            #[doc = "undocumented"]
            BOUNDARY,
        }
        impl CNTSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CNTSELR::START => 0,
                    CNTSELR::END => 1,
                    CNTSELR::BETWEEN => 2,
                    CNTSELR::BOUNDARY => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CNTSELR {
                match value {
                    0 => CNTSELR::START,
                    1 => CNTSELR::END,
                    2 => CNTSELR::BETWEEN,
                    3 => CNTSELR::BOUNDARY,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == CNTSELR::START
            }
            #[doc = "Checks if the value of the field is `END`"]
            #[inline(always)]
            pub fn is_end(&self) -> bool {
                *self == CNTSELR::END
            }
            #[doc = "Checks if the value of the field is `BETWEEN`"]
            #[inline(always)]
            pub fn is_between(&self) -> bool {
                *self == CNTSELR::BETWEEN
            }
            #[doc = "Checks if the value of the field is `BOUNDARY`"]
            #[inline(always)]
            pub fn is_boundary(&self) -> bool {
                *self == CNTSELR::BOUNDARY
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVFEOR {
            bits: bool,
        }
        impl OVFEOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRGEOR {
            bits: bool,
        }
        impl TRGEOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNTEOR {
            bits: bool,
        }
        impl CNTEOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCINV0R {
            bits: bool,
        }
        impl TCINV0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCINV1R {
            bits: bool,
        }
        impl TCINV1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCEI0R {
            bits: bool,
        }
        impl TCEI0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCEI1R {
            bits: bool,
        }
        impl TCEI1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCEI0R {
            bits: bool,
        }
        impl MCEI0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCEI1R {
            bits: bool,
        }
        impl MCEI1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCEI2R {
            bits: bool,
        }
        impl MCEI2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCEI3R {
            bits: bool,
        }
        impl MCEI3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCEO0R {
            bits: bool,
        }
        impl MCEO0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCEO1R {
            bits: bool,
        }
        impl MCEO1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCEO2R {
            bits: bool,
        }
        impl MCEO2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCEO3R {
            bits: bool,
        }
        impl MCEO3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `EVACT0`"]
        pub enum EVACT0W {
            #[doc = "`0`"]
            OFF,
            #[doc = "`1`"]
            RETRIGGER,
            #[doc = "`10`"]
            COUNTEV,
            #[doc = "`11`"]
            START,
            #[doc = "`100`"]
            INC,
            #[doc = "`101`"]
            COUNT,
            #[doc = "`111`"]
            FAULT,
        }
        impl EVACT0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EVACT0W::OFF => 0,
                    EVACT0W::RETRIGGER => 1,
                    EVACT0W::COUNTEV => 2,
                    EVACT0W::START => 3,
                    EVACT0W::INC => 4,
                    EVACT0W::COUNT => 5,
                    EVACT0W::FAULT => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVACT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVACT0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EVACT0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(EVACT0W::OFF)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn retrigger(self) -> &'a mut W {
                self.variant(EVACT0W::RETRIGGER)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn countev(self) -> &'a mut W {
                self.variant(EVACT0W::COUNTEV)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(EVACT0W::START)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn inc(self) -> &'a mut W {
                self.variant(EVACT0W::INC)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn count(self) -> &'a mut W {
                self.variant(EVACT0W::COUNT)
            }
            #[doc = "`111`"]
            #[inline(always)]
            pub fn fault(self) -> &'a mut W {
                self.variant(EVACT0W::FAULT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EVACT1`"]
        pub enum EVACT1W {
            #[doc = "`0`"]
            OFF,
            #[doc = "`1`"]
            RETRIGGER,
            #[doc = "`10`"]
            DIR,
            #[doc = "`11`"]
            STOP,
            #[doc = "`100`"]
            DEC,
            #[doc = "`101`"]
            PPW,
            #[doc = "`110`"]
            PWP,
            #[doc = "`111`"]
            FAULT,
        }
        impl EVACT1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EVACT1W::OFF => 0,
                    EVACT1W::RETRIGGER => 1,
                    EVACT1W::DIR => 2,
                    EVACT1W::STOP => 3,
                    EVACT1W::DEC => 4,
                    EVACT1W::PPW => 5,
                    EVACT1W::PWP => 6,
                    EVACT1W::FAULT => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVACT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVACT1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EVACT1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(EVACT1W::OFF)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn retrigger(self) -> &'a mut W {
                self.variant(EVACT1W::RETRIGGER)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn dir(self) -> &'a mut W {
                self.variant(EVACT1W::DIR)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(EVACT1W::STOP)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn dec(self) -> &'a mut W {
                self.variant(EVACT1W::DEC)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn ppw(self) -> &'a mut W {
                self.variant(EVACT1W::PPW)
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn pwp(self) -> &'a mut W {
                self.variant(EVACT1W::PWP)
            }
            #[doc = "`111`"]
            #[inline(always)]
            pub fn fault(self) -> &'a mut W {
                self.variant(EVACT1W::FAULT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CNTSEL`"]
        pub enum CNTSELW {
            #[doc = "`0`"]
            START,
            #[doc = "`1`"]
            END,
            #[doc = "`10`"]
            BETWEEN,
            #[doc = "`11`"]
            BOUNDARY,
        }
        impl CNTSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CNTSELW::START => 0,
                    CNTSELW::END => 1,
                    CNTSELW::BETWEEN => 2,
                    CNTSELW::BOUNDARY => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNTSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(CNTSELW::START)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn end(self) -> &'a mut W {
                self.variant(CNTSELW::END)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn between(self) -> &'a mut W {
                self.variant(CNTSELW::BETWEEN)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn boundary(self) -> &'a mut W {
                self.variant(CNTSELW::BOUNDARY)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVFEOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVFEOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRGEOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRGEOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTEOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTEOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCINV0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCINV0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCINV1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCINV1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCEI0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCEI0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCEI1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCEI1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCEI0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCEI0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCEI1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCEI1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCEI2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCEI2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCEI3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCEI3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCEO0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCEO0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCEO1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCEO1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCEO2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCEO2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCEO3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCEO3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Timer/counter Input Event0 Action"]
            #[inline(always)]
            pub fn evact0(&self) -> EVACT0R {
                EVACT0R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:5 - Timer/counter Input Event1 Action"]
            #[inline(always)]
            pub fn evact1(&self) -> EVACT1R {
                EVACT1R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 6:7 - Timer/counter Output Event Mode"]
            #[inline(always)]
            pub fn cntsel(&self) -> CNTSELR {
                CNTSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 8 - Overflow/Underflow Output Event Enable"]
            #[inline(always)]
            pub fn ovfeo(&self) -> OVFEOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVFEOR { bits }
            }
            #[doc = "Bit 9 - Retrigger Output Event Enable"]
            #[inline(always)]
            pub fn trgeo(&self) -> TRGEOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TRGEOR { bits }
            }
            #[doc = "Bit 10 - Timer/counter Output Event Enable"]
            #[inline(always)]
            pub fn cnteo(&self) -> CNTEOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CNTEOR { bits }
            }
            #[doc = "Bit 12 - Inverted Event 0 Input Enable"]
            #[inline(always)]
            pub fn tcinv0(&self) -> TCINV0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TCINV0R { bits }
            }
            #[doc = "Bit 13 - Inverted Event 1 Input Enable"]
            #[inline(always)]
            pub fn tcinv1(&self) -> TCINV1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TCINV1R { bits }
            }
            #[doc = "Bit 14 - Timer/counter Event 0 Input Enable"]
            #[inline(always)]
            pub fn tcei0(&self) -> TCEI0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TCEI0R { bits }
            }
            #[doc = "Bit 15 - Timer/counter Event 1 Input Enable"]
            #[inline(always)]
            pub fn tcei1(&self) -> TCEI1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TCEI1R { bits }
            }
            #[doc = "Bit 16 - Match or Capture Channel 0 Event Input Enable"]
            #[inline(always)]
            pub fn mcei0(&self) -> MCEI0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MCEI0R { bits }
            }
            #[doc = "Bit 17 - Match or Capture Channel 1 Event Input Enable"]
            #[inline(always)]
            pub fn mcei1(&self) -> MCEI1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MCEI1R { bits }
            }
            #[doc = "Bit 18 - Match or Capture Channel 2 Event Input Enable"]
            #[inline(always)]
            pub fn mcei2(&self) -> MCEI2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MCEI2R { bits }
            }
            #[doc = "Bit 19 - Match or Capture Channel 3 Event Input Enable"]
            #[inline(always)]
            pub fn mcei3(&self) -> MCEI3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MCEI3R { bits }
            }
            #[doc = "Bit 24 - Match or Capture Channel 0 Event Output Enable"]
            #[inline(always)]
            pub fn mceo0(&self) -> MCEO0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MCEO0R { bits }
            }
            #[doc = "Bit 25 - Match or Capture Channel 1 Event Output Enable"]
            #[inline(always)]
            pub fn mceo1(&self) -> MCEO1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MCEO1R { bits }
            }
            #[doc = "Bit 26 - Match or Capture Channel 2 Event Output Enable"]
            #[inline(always)]
            pub fn mceo2(&self) -> MCEO2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MCEO2R { bits }
            }
            #[doc = "Bit 27 - Match or Capture Channel 3 Event Output Enable"]
            #[inline(always)]
            pub fn mceo3(&self) -> MCEO3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MCEO3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Timer/counter Input Event0 Action"]
            #[inline(always)]
            pub fn evact0(&mut self) -> _EVACT0W {
                _EVACT0W { w: self }
            }
            #[doc = "Bits 3:5 - Timer/counter Input Event1 Action"]
            #[inline(always)]
            pub fn evact1(&mut self) -> _EVACT1W {
                _EVACT1W { w: self }
            }
            #[doc = "Bits 6:7 - Timer/counter Output Event Mode"]
            #[inline(always)]
            pub fn cntsel(&mut self) -> _CNTSELW {
                _CNTSELW { w: self }
            }
            #[doc = "Bit 8 - Overflow/Underflow Output Event Enable"]
            #[inline(always)]
            pub fn ovfeo(&mut self) -> _OVFEOW {
                _OVFEOW { w: self }
            }
            #[doc = "Bit 9 - Retrigger Output Event Enable"]
            #[inline(always)]
            pub fn trgeo(&mut self) -> _TRGEOW {
                _TRGEOW { w: self }
            }
            #[doc = "Bit 10 - Timer/counter Output Event Enable"]
            #[inline(always)]
            pub fn cnteo(&mut self) -> _CNTEOW {
                _CNTEOW { w: self }
            }
            #[doc = "Bit 12 - Inverted Event 0 Input Enable"]
            #[inline(always)]
            pub fn tcinv0(&mut self) -> _TCINV0W {
                _TCINV0W { w: self }
            }
            #[doc = "Bit 13 - Inverted Event 1 Input Enable"]
            #[inline(always)]
            pub fn tcinv1(&mut self) -> _TCINV1W {
                _TCINV1W { w: self }
            }
            #[doc = "Bit 14 - Timer/counter Event 0 Input Enable"]
            #[inline(always)]
            pub fn tcei0(&mut self) -> _TCEI0W {
                _TCEI0W { w: self }
            }
            #[doc = "Bit 15 - Timer/counter Event 1 Input Enable"]
            #[inline(always)]
            pub fn tcei1(&mut self) -> _TCEI1W {
                _TCEI1W { w: self }
            }
            #[doc = "Bit 16 - Match or Capture Channel 0 Event Input Enable"]
            #[inline(always)]
            pub fn mcei0(&mut self) -> _MCEI0W {
                _MCEI0W { w: self }
            }
            #[doc = "Bit 17 - Match or Capture Channel 1 Event Input Enable"]
            #[inline(always)]
            pub fn mcei1(&mut self) -> _MCEI1W {
                _MCEI1W { w: self }
            }
            #[doc = "Bit 18 - Match or Capture Channel 2 Event Input Enable"]
            #[inline(always)]
            pub fn mcei2(&mut self) -> _MCEI2W {
                _MCEI2W { w: self }
            }
            #[doc = "Bit 19 - Match or Capture Channel 3 Event Input Enable"]
            #[inline(always)]
            pub fn mcei3(&mut self) -> _MCEI3W {
                _MCEI3W { w: self }
            }
            #[doc = "Bit 24 - Match or Capture Channel 0 Event Output Enable"]
            #[inline(always)]
            pub fn mceo0(&mut self) -> _MCEO0W {
                _MCEO0W { w: self }
            }
            #[doc = "Bit 25 - Match or Capture Channel 1 Event Output Enable"]
            #[inline(always)]
            pub fn mceo1(&mut self) -> _MCEO1W {
                _MCEO1W { w: self }
            }
            #[doc = "Bit 26 - Match or Capture Channel 2 Event Output Enable"]
            #[inline(always)]
            pub fn mceo2(&mut self) -> _MCEO2W {
                _MCEO2W { w: self }
            }
            #[doc = "Bit 27 - Match or Capture Channel 3 Event Output Enable"]
            #[inline(always)]
            pub fn mceo3(&mut self) -> _MCEO3W {
                _MCEO3W { w: self }
            }
        }
    }
    #[doc = "Recoverable FaultA Configuration"]
    pub struct FCTRLA {
        register: VolatileCell<u32>,
    }
    #[doc = "Recoverable FaultA Configuration"]
    pub mod fctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FCTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SRC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRCR {
            #[doc = "undocumented"]
            DISABLE,
            #[doc = "undocumented"]
            ENABLE,
            #[doc = "undocumented"]
            INVERT,
            #[doc = "undocumented"]
            ALTFAULT,
        }
        impl SRCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRCR::DISABLE => 0,
                    SRCR::ENABLE => 1,
                    SRCR::INVERT => 2,
                    SRCR::ALTFAULT => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SRCR {
                match value {
                    0 => SRCR::DISABLE,
                    1 => SRCR::ENABLE,
                    2 => SRCR::INVERT,
                    3 => SRCR::ALTFAULT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == SRCR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == SRCR::ENABLE
            }
            #[doc = "Checks if the value of the field is `INVERT`"]
            #[inline(always)]
            pub fn is_invert(&self) -> bool {
                *self == SRCR::INVERT
            }
            #[doc = "Checks if the value of the field is `ALTFAULT`"]
            #[inline(always)]
            pub fn is_altfault(&self) -> bool {
                *self == SRCR::ALTFAULT
            }
        }
        #[doc = r" Value of the field"]
        pub struct KEEPR {
            bits: bool,
        }
        impl KEEPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct QUALR {
            bits: bool,
        }
        impl QUALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `BLANK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BLANKR {
            #[doc = "undocumented"]
            DISABLE,
            #[doc = "undocumented"]
            RISE,
            #[doc = "undocumented"]
            FALL,
            #[doc = "undocumented"]
            BOTH,
        }
        impl BLANKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    BLANKR::DISABLE => 0,
                    BLANKR::RISE => 1,
                    BLANKR::FALL => 2,
                    BLANKR::BOTH => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> BLANKR {
                match value {
                    0 => BLANKR::DISABLE,
                    1 => BLANKR::RISE,
                    2 => BLANKR::FALL,
                    3 => BLANKR::BOTH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == BLANKR::DISABLE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == BLANKR::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == BLANKR::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == BLANKR::BOTH
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESTARTR {
            bits: bool,
        }
        impl RESTARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `HALT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HALTR {
            #[doc = "undocumented"]
            DISABLE,
            #[doc = "undocumented"]
            HW,
            #[doc = "undocumented"]
            SW,
            #[doc = "undocumented"]
            NR,
        }
        impl HALTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    HALTR::DISABLE => 0,
                    HALTR::HW => 1,
                    HALTR::SW => 2,
                    HALTR::NR => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> HALTR {
                match value {
                    0 => HALTR::DISABLE,
                    1 => HALTR::HW,
                    2 => HALTR::SW,
                    3 => HALTR::NR,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == HALTR::DISABLE
            }
            #[doc = "Checks if the value of the field is `HW`"]
            #[inline(always)]
            pub fn is_hw(&self) -> bool {
                *self == HALTR::HW
            }
            #[doc = "Checks if the value of the field is `SW`"]
            #[inline(always)]
            pub fn is_sw(&self) -> bool {
                *self == HALTR::SW
            }
            #[doc = "Checks if the value of the field is `NR`"]
            #[inline(always)]
            pub fn is_nr(&self) -> bool {
                *self == HALTR::NR
            }
        }
        #[doc = "Possible values of the field `CHSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CHSELR {
            #[doc = "undocumented"]
            CC0,
            #[doc = "undocumented"]
            CC1,
            #[doc = "undocumented"]
            CC2,
            #[doc = "undocumented"]
            CC3,
        }
        impl CHSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CHSELR::CC0 => 0,
                    CHSELR::CC1 => 1,
                    CHSELR::CC2 => 2,
                    CHSELR::CC3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CHSELR {
                match value {
                    0 => CHSELR::CC0,
                    1 => CHSELR::CC1,
                    2 => CHSELR::CC2,
                    3 => CHSELR::CC3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CC0`"]
            #[inline(always)]
            pub fn is_cc0(&self) -> bool {
                *self == CHSELR::CC0
            }
            #[doc = "Checks if the value of the field is `CC1`"]
            #[inline(always)]
            pub fn is_cc1(&self) -> bool {
                *self == CHSELR::CC1
            }
            #[doc = "Checks if the value of the field is `CC2`"]
            #[inline(always)]
            pub fn is_cc2(&self) -> bool {
                *self == CHSELR::CC2
            }
            #[doc = "Checks if the value of the field is `CC3`"]
            #[inline(always)]
            pub fn is_cc3(&self) -> bool {
                *self == CHSELR::CC3
            }
        }
        #[doc = "Possible values of the field `CAPTURE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPTURER {
            #[doc = "undocumented"]
            DISABLE,
            #[doc = "undocumented"]
            CAPT,
            #[doc = "undocumented"]
            CAPTMIN,
            #[doc = "undocumented"]
            CAPTMAX,
            #[doc = "undocumented"]
            LOCMIN,
            #[doc = "undocumented"]
            LOCMAX,
            #[doc = "undocumented"]
            DERIV0,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CAPTURER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CAPTURER::DISABLE => 0,
                    CAPTURER::CAPT => 1,
                    CAPTURER::CAPTMIN => 2,
                    CAPTURER::CAPTMAX => 3,
                    CAPTURER::LOCMIN => 4,
                    CAPTURER::LOCMAX => 5,
                    CAPTURER::DERIV0 => 6,
                    CAPTURER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CAPTURER {
                match value {
                    0 => CAPTURER::DISABLE,
                    1 => CAPTURER::CAPT,
                    2 => CAPTURER::CAPTMIN,
                    3 => CAPTURER::CAPTMAX,
                    4 => CAPTURER::LOCMIN,
                    5 => CAPTURER::LOCMAX,
                    6 => CAPTURER::DERIV0,
                    i => CAPTURER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == CAPTURER::DISABLE
            }
            #[doc = "Checks if the value of the field is `CAPT`"]
            #[inline(always)]
            pub fn is_capt(&self) -> bool {
                *self == CAPTURER::CAPT
            }
            #[doc = "Checks if the value of the field is `CAPTMIN`"]
            #[inline(always)]
            pub fn is_captmin(&self) -> bool {
                *self == CAPTURER::CAPTMIN
            }
            #[doc = "Checks if the value of the field is `CAPTMAX`"]
            #[inline(always)]
            pub fn is_captmax(&self) -> bool {
                *self == CAPTURER::CAPTMAX
            }
            #[doc = "Checks if the value of the field is `LOCMIN`"]
            #[inline(always)]
            pub fn is_locmin(&self) -> bool {
                *self == CAPTURER::LOCMIN
            }
            #[doc = "Checks if the value of the field is `LOCMAX`"]
            #[inline(always)]
            pub fn is_locmax(&self) -> bool {
                *self == CAPTURER::LOCMAX
            }
            #[doc = "Checks if the value of the field is `DERIV0`"]
            #[inline(always)]
            pub fn is_deriv0(&self) -> bool {
                *self == CAPTURER::DERIV0
            }
        }
        #[doc = r" Value of the field"]
        pub struct BLANKVALR {
            bits: u8,
        }
        impl BLANKVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTERVALR {
            bits: u8,
        }
        impl FILTERVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `SRC`"]
        pub enum SRCW {
            #[doc = "`0`"]
            DISABLE,
            #[doc = "`1`"]
            ENABLE,
            #[doc = "`10`"]
            INVERT,
            #[doc = "`11`"]
            ALTFAULT,
        }
        impl SRCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRCW::DISABLE => 0,
                    SRCW::ENABLE => 1,
                    SRCW::INVERT => 2,
                    SRCW::ALTFAULT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SRCW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(SRCW::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(SRCW::ENABLE)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn invert(self) -> &'a mut W {
                self.variant(SRCW::INVERT)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn altfault(self) -> &'a mut W {
                self.variant(SRCW::ALTFAULT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _KEEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _KEEPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _QUALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _QUALW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BLANK`"]
        pub enum BLANKW {
            #[doc = "`0`"]
            DISABLE,
            #[doc = "`1`"]
            RISE,
            #[doc = "`10`"]
            FALL,
            #[doc = "`11`"]
            BOTH,
        }
        impl BLANKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BLANKW::DISABLE => 0,
                    BLANKW::RISE => 1,
                    BLANKW::FALL => 2,
                    BLANKW::BOTH => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BLANKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BLANKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BLANKW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(BLANKW::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(BLANKW::RISE)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(BLANKW::FALL)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn both(self) -> &'a mut W {
                self.variant(BLANKW::BOTH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESTARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESTARTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HALT`"]
        pub enum HALTW {
            #[doc = "`0`"]
            DISABLE,
            #[doc = "`1`"]
            HW,
            #[doc = "`10`"]
            SW,
            #[doc = "`11`"]
            NR,
        }
        impl HALTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    HALTW::DISABLE => 0,
                    HALTW::HW => 1,
                    HALTW::SW => 2,
                    HALTW::NR => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HALTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HALTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HALTW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(HALTW::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn hw(self) -> &'a mut W {
                self.variant(HALTW::HW)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn sw(self) -> &'a mut W {
                self.variant(HALTW::SW)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn nr(self) -> &'a mut W {
                self.variant(HALTW::NR)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CHSEL`"]
        pub enum CHSELW {
            #[doc = "`0`"]
            CC0,
            #[doc = "`1`"]
            CC1,
            #[doc = "`10`"]
            CC2,
            #[doc = "`11`"]
            CC3,
        }
        impl CHSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CHSELW::CC0 => 0,
                    CHSELW::CC1 => 1,
                    CHSELW::CC2 => 2,
                    CHSELW::CC3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn cc0(self) -> &'a mut W {
                self.variant(CHSELW::CC0)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn cc1(self) -> &'a mut W {
                self.variant(CHSELW::CC1)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn cc2(self) -> &'a mut W {
                self.variant(CHSELW::CC2)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn cc3(self) -> &'a mut W {
                self.variant(CHSELW::CC3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAPTURE`"]
        pub enum CAPTUREW {
            #[doc = "`0`"]
            DISABLE,
            #[doc = "`1`"]
            CAPT,
            #[doc = "`10`"]
            CAPTMIN,
            #[doc = "`11`"]
            CAPTMAX,
            #[doc = "`100`"]
            LOCMIN,
            #[doc = "`101`"]
            LOCMAX,
            #[doc = "`110`"]
            DERIV0,
        }
        impl CAPTUREW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CAPTUREW::DISABLE => 0,
                    CAPTUREW::CAPT => 1,
                    CAPTUREW::CAPTMIN => 2,
                    CAPTUREW::CAPTMAX => 3,
                    CAPTUREW::LOCMIN => 4,
                    CAPTUREW::LOCMAX => 5,
                    CAPTUREW::DERIV0 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPTUREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPTUREW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPTUREW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(CAPTUREW::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn capt(self) -> &'a mut W {
                self.variant(CAPTUREW::CAPT)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn captmin(self) -> &'a mut W {
                self.variant(CAPTUREW::CAPTMIN)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn captmax(self) -> &'a mut W {
                self.variant(CAPTUREW::CAPTMAX)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn locmin(self) -> &'a mut W {
                self.variant(CAPTUREW::LOCMIN)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn locmax(self) -> &'a mut W {
                self.variant(CAPTUREW::LOCMAX)
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn deriv0(self) -> &'a mut W {
                self.variant(CAPTUREW::DERIV0)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BLANKVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BLANKVALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTERVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTERVALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - FaultA Source"]
            #[inline(always)]
            pub fn src(&self) -> SRCR {
                SRCR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 3 - FaultA Keeper"]
            #[inline(always)]
            pub fn keep(&self) -> KEEPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                KEEPR { bits }
            }
            #[doc = "Bit 4 - FaultA Qualification"]
            #[inline(always)]
            pub fn qual(&self) -> QUALR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                QUALR { bits }
            }
            #[doc = "Bits 5:6 - FaultA Blanking Mode"]
            #[inline(always)]
            pub fn blank(&self) -> BLANKR {
                BLANKR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 7 - FaultA Restart"]
            #[inline(always)]
            pub fn restart(&self) -> RESTARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RESTARTR { bits }
            }
            #[doc = "Bits 8:9 - FaultA Halt Mode"]
            #[inline(always)]
            pub fn halt(&self) -> HALTR {
                HALTR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 10:11 - FaultA Capture Channel"]
            #[inline(always)]
            pub fn chsel(&self) -> CHSELR {
                CHSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:14 - FaultA Capture Action"]
            #[inline(always)]
            pub fn capture(&self) -> CAPTURER {
                CAPTURER::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 16:23 - FaultA Blanking Time"]
            #[inline(always)]
            pub fn blankval(&self) -> BLANKVALR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BLANKVALR { bits }
            }
            #[doc = "Bits 24:27 - FaultA Filter Value"]
            #[inline(always)]
            pub fn filterval(&self) -> FILTERVALR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FILTERVALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - FaultA Source"]
            #[inline(always)]
            pub fn src(&mut self) -> _SRCW {
                _SRCW { w: self }
            }
            #[doc = "Bit 3 - FaultA Keeper"]
            #[inline(always)]
            pub fn keep(&mut self) -> _KEEPW {
                _KEEPW { w: self }
            }
            #[doc = "Bit 4 - FaultA Qualification"]
            #[inline(always)]
            pub fn qual(&mut self) -> _QUALW {
                _QUALW { w: self }
            }
            #[doc = "Bits 5:6 - FaultA Blanking Mode"]
            #[inline(always)]
            pub fn blank(&mut self) -> _BLANKW {
                _BLANKW { w: self }
            }
            #[doc = "Bit 7 - FaultA Restart"]
            #[inline(always)]
            pub fn restart(&mut self) -> _RESTARTW {
                _RESTARTW { w: self }
            }
            #[doc = "Bits 8:9 - FaultA Halt Mode"]
            #[inline(always)]
            pub fn halt(&mut self) -> _HALTW {
                _HALTW { w: self }
            }
            #[doc = "Bits 10:11 - FaultA Capture Channel"]
            #[inline(always)]
            pub fn chsel(&mut self) -> _CHSELW {
                _CHSELW { w: self }
            }
            #[doc = "Bits 12:14 - FaultA Capture Action"]
            #[inline(always)]
            pub fn capture(&mut self) -> _CAPTUREW {
                _CAPTUREW { w: self }
            }
            #[doc = "Bits 16:23 - FaultA Blanking Time"]
            #[inline(always)]
            pub fn blankval(&mut self) -> _BLANKVALW {
                _BLANKVALW { w: self }
            }
            #[doc = "Bits 24:27 - FaultA Filter Value"]
            #[inline(always)]
            pub fn filterval(&mut self) -> _FILTERVALW {
                _FILTERVALW { w: self }
            }
        }
    }
    #[doc = "Recoverable FaultB Configuration"]
    pub struct FCTRLB {
        register: VolatileCell<u32>,
    }
    #[doc = "Recoverable FaultB Configuration"]
    pub mod fctrlb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FCTRLB {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SRC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRCR {
            #[doc = "undocumented"]
            DISABLE,
            #[doc = "undocumented"]
            ENABLE,
            #[doc = "undocumented"]
            INVERT,
            #[doc = "undocumented"]
            ALTFAULT,
        }
        impl SRCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRCR::DISABLE => 0,
                    SRCR::ENABLE => 1,
                    SRCR::INVERT => 2,
                    SRCR::ALTFAULT => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SRCR {
                match value {
                    0 => SRCR::DISABLE,
                    1 => SRCR::ENABLE,
                    2 => SRCR::INVERT,
                    3 => SRCR::ALTFAULT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == SRCR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == SRCR::ENABLE
            }
            #[doc = "Checks if the value of the field is `INVERT`"]
            #[inline(always)]
            pub fn is_invert(&self) -> bool {
                *self == SRCR::INVERT
            }
            #[doc = "Checks if the value of the field is `ALTFAULT`"]
            #[inline(always)]
            pub fn is_altfault(&self) -> bool {
                *self == SRCR::ALTFAULT
            }
        }
        #[doc = r" Value of the field"]
        pub struct KEEPR {
            bits: bool,
        }
        impl KEEPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct QUALR {
            bits: bool,
        }
        impl QUALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `BLANK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BLANKR {
            #[doc = "undocumented"]
            DISABLE,
            #[doc = "undocumented"]
            RISE,
            #[doc = "undocumented"]
            FALL,
            #[doc = "undocumented"]
            BOTH,
        }
        impl BLANKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    BLANKR::DISABLE => 0,
                    BLANKR::RISE => 1,
                    BLANKR::FALL => 2,
                    BLANKR::BOTH => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> BLANKR {
                match value {
                    0 => BLANKR::DISABLE,
                    1 => BLANKR::RISE,
                    2 => BLANKR::FALL,
                    3 => BLANKR::BOTH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == BLANKR::DISABLE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == BLANKR::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == BLANKR::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == BLANKR::BOTH
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESTARTR {
            bits: bool,
        }
        impl RESTARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `HALT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HALTR {
            #[doc = "undocumented"]
            DISABLE,
            #[doc = "undocumented"]
            HW,
            #[doc = "undocumented"]
            SW,
            #[doc = "undocumented"]
            NR,
        }
        impl HALTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    HALTR::DISABLE => 0,
                    HALTR::HW => 1,
                    HALTR::SW => 2,
                    HALTR::NR => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> HALTR {
                match value {
                    0 => HALTR::DISABLE,
                    1 => HALTR::HW,
                    2 => HALTR::SW,
                    3 => HALTR::NR,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == HALTR::DISABLE
            }
            #[doc = "Checks if the value of the field is `HW`"]
            #[inline(always)]
            pub fn is_hw(&self) -> bool {
                *self == HALTR::HW
            }
            #[doc = "Checks if the value of the field is `SW`"]
            #[inline(always)]
            pub fn is_sw(&self) -> bool {
                *self == HALTR::SW
            }
            #[doc = "Checks if the value of the field is `NR`"]
            #[inline(always)]
            pub fn is_nr(&self) -> bool {
                *self == HALTR::NR
            }
        }
        #[doc = "Possible values of the field `CHSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CHSELR {
            #[doc = "undocumented"]
            CC0,
            #[doc = "undocumented"]
            CC1,
            #[doc = "undocumented"]
            CC2,
            #[doc = "undocumented"]
            CC3,
        }
        impl CHSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CHSELR::CC0 => 0,
                    CHSELR::CC1 => 1,
                    CHSELR::CC2 => 2,
                    CHSELR::CC3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CHSELR {
                match value {
                    0 => CHSELR::CC0,
                    1 => CHSELR::CC1,
                    2 => CHSELR::CC2,
                    3 => CHSELR::CC3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CC0`"]
            #[inline(always)]
            pub fn is_cc0(&self) -> bool {
                *self == CHSELR::CC0
            }
            #[doc = "Checks if the value of the field is `CC1`"]
            #[inline(always)]
            pub fn is_cc1(&self) -> bool {
                *self == CHSELR::CC1
            }
            #[doc = "Checks if the value of the field is `CC2`"]
            #[inline(always)]
            pub fn is_cc2(&self) -> bool {
                *self == CHSELR::CC2
            }
            #[doc = "Checks if the value of the field is `CC3`"]
            #[inline(always)]
            pub fn is_cc3(&self) -> bool {
                *self == CHSELR::CC3
            }
        }
        #[doc = "Possible values of the field `CAPTURE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPTURER {
            #[doc = "undocumented"]
            DISABLE,
            #[doc = "undocumented"]
            CAPT,
            #[doc = "undocumented"]
            CAPTMIN,
            #[doc = "undocumented"]
            CAPTMAX,
            #[doc = "undocumented"]
            LOCMIN,
            #[doc = "undocumented"]
            LOCMAX,
            #[doc = "undocumented"]
            DERIV0,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CAPTURER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CAPTURER::DISABLE => 0,
                    CAPTURER::CAPT => 1,
                    CAPTURER::CAPTMIN => 2,
                    CAPTURER::CAPTMAX => 3,
                    CAPTURER::LOCMIN => 4,
                    CAPTURER::LOCMAX => 5,
                    CAPTURER::DERIV0 => 6,
                    CAPTURER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CAPTURER {
                match value {
                    0 => CAPTURER::DISABLE,
                    1 => CAPTURER::CAPT,
                    2 => CAPTURER::CAPTMIN,
                    3 => CAPTURER::CAPTMAX,
                    4 => CAPTURER::LOCMIN,
                    5 => CAPTURER::LOCMAX,
                    6 => CAPTURER::DERIV0,
                    i => CAPTURER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == CAPTURER::DISABLE
            }
            #[doc = "Checks if the value of the field is `CAPT`"]
            #[inline(always)]
            pub fn is_capt(&self) -> bool {
                *self == CAPTURER::CAPT
            }
            #[doc = "Checks if the value of the field is `CAPTMIN`"]
            #[inline(always)]
            pub fn is_captmin(&self) -> bool {
                *self == CAPTURER::CAPTMIN
            }
            #[doc = "Checks if the value of the field is `CAPTMAX`"]
            #[inline(always)]
            pub fn is_captmax(&self) -> bool {
                *self == CAPTURER::CAPTMAX
            }
            #[doc = "Checks if the value of the field is `LOCMIN`"]
            #[inline(always)]
            pub fn is_locmin(&self) -> bool {
                *self == CAPTURER::LOCMIN
            }
            #[doc = "Checks if the value of the field is `LOCMAX`"]
            #[inline(always)]
            pub fn is_locmax(&self) -> bool {
                *self == CAPTURER::LOCMAX
            }
            #[doc = "Checks if the value of the field is `DERIV0`"]
            #[inline(always)]
            pub fn is_deriv0(&self) -> bool {
                *self == CAPTURER::DERIV0
            }
        }
        #[doc = r" Value of the field"]
        pub struct BLANKVALR {
            bits: u8,
        }
        impl BLANKVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTERVALR {
            bits: u8,
        }
        impl FILTERVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `SRC`"]
        pub enum SRCW {
            #[doc = "`0`"]
            DISABLE,
            #[doc = "`1`"]
            ENABLE,
            #[doc = "`10`"]
            INVERT,
            #[doc = "`11`"]
            ALTFAULT,
        }
        impl SRCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRCW::DISABLE => 0,
                    SRCW::ENABLE => 1,
                    SRCW::INVERT => 2,
                    SRCW::ALTFAULT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SRCW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(SRCW::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(SRCW::ENABLE)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn invert(self) -> &'a mut W {
                self.variant(SRCW::INVERT)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn altfault(self) -> &'a mut W {
                self.variant(SRCW::ALTFAULT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _KEEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _KEEPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _QUALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _QUALW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BLANK`"]
        pub enum BLANKW {
            #[doc = "`0`"]
            DISABLE,
            #[doc = "`1`"]
            RISE,
            #[doc = "`10`"]
            FALL,
            #[doc = "`11`"]
            BOTH,
        }
        impl BLANKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BLANKW::DISABLE => 0,
                    BLANKW::RISE => 1,
                    BLANKW::FALL => 2,
                    BLANKW::BOTH => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BLANKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BLANKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BLANKW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(BLANKW::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(BLANKW::RISE)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(BLANKW::FALL)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn both(self) -> &'a mut W {
                self.variant(BLANKW::BOTH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESTARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESTARTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HALT`"]
        pub enum HALTW {
            #[doc = "`0`"]
            DISABLE,
            #[doc = "`1`"]
            HW,
            #[doc = "`10`"]
            SW,
            #[doc = "`11`"]
            NR,
        }
        impl HALTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    HALTW::DISABLE => 0,
                    HALTW::HW => 1,
                    HALTW::SW => 2,
                    HALTW::NR => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HALTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HALTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HALTW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(HALTW::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn hw(self) -> &'a mut W {
                self.variant(HALTW::HW)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn sw(self) -> &'a mut W {
                self.variant(HALTW::SW)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn nr(self) -> &'a mut W {
                self.variant(HALTW::NR)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CHSEL`"]
        pub enum CHSELW {
            #[doc = "`0`"]
            CC0,
            #[doc = "`1`"]
            CC1,
            #[doc = "`10`"]
            CC2,
            #[doc = "`11`"]
            CC3,
        }
        impl CHSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CHSELW::CC0 => 0,
                    CHSELW::CC1 => 1,
                    CHSELW::CC2 => 2,
                    CHSELW::CC3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn cc0(self) -> &'a mut W {
                self.variant(CHSELW::CC0)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn cc1(self) -> &'a mut W {
                self.variant(CHSELW::CC1)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn cc2(self) -> &'a mut W {
                self.variant(CHSELW::CC2)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn cc3(self) -> &'a mut W {
                self.variant(CHSELW::CC3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAPTURE`"]
        pub enum CAPTUREW {
            #[doc = "`0`"]
            DISABLE,
            #[doc = "`1`"]
            CAPT,
            #[doc = "`10`"]
            CAPTMIN,
            #[doc = "`11`"]
            CAPTMAX,
            #[doc = "`100`"]
            LOCMIN,
            #[doc = "`101`"]
            LOCMAX,
            #[doc = "`110`"]
            DERIV0,
        }
        impl CAPTUREW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CAPTUREW::DISABLE => 0,
                    CAPTUREW::CAPT => 1,
                    CAPTUREW::CAPTMIN => 2,
                    CAPTUREW::CAPTMAX => 3,
                    CAPTUREW::LOCMIN => 4,
                    CAPTUREW::LOCMAX => 5,
                    CAPTUREW::DERIV0 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPTUREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPTUREW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPTUREW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(CAPTUREW::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn capt(self) -> &'a mut W {
                self.variant(CAPTUREW::CAPT)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn captmin(self) -> &'a mut W {
                self.variant(CAPTUREW::CAPTMIN)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn captmax(self) -> &'a mut W {
                self.variant(CAPTUREW::CAPTMAX)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn locmin(self) -> &'a mut W {
                self.variant(CAPTUREW::LOCMIN)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn locmax(self) -> &'a mut W {
                self.variant(CAPTUREW::LOCMAX)
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn deriv0(self) -> &'a mut W {
                self.variant(CAPTUREW::DERIV0)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BLANKVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BLANKVALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTERVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTERVALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - FaultB Source"]
            #[inline(always)]
            pub fn src(&self) -> SRCR {
                SRCR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 3 - FaultB Keeper"]
            #[inline(always)]
            pub fn keep(&self) -> KEEPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                KEEPR { bits }
            }
            #[doc = "Bit 4 - FaultB Qualification"]
            #[inline(always)]
            pub fn qual(&self) -> QUALR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                QUALR { bits }
            }
            #[doc = "Bits 5:6 - FaultB Blanking Mode"]
            #[inline(always)]
            pub fn blank(&self) -> BLANKR {
                BLANKR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 7 - FaultB Restart"]
            #[inline(always)]
            pub fn restart(&self) -> RESTARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RESTARTR { bits }
            }
            #[doc = "Bits 8:9 - FaultB Halt Mode"]
            #[inline(always)]
            pub fn halt(&self) -> HALTR {
                HALTR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 10:11 - FaultB Capture Channel"]
            #[inline(always)]
            pub fn chsel(&self) -> CHSELR {
                CHSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:14 - FaultB Capture Action"]
            #[inline(always)]
            pub fn capture(&self) -> CAPTURER {
                CAPTURER::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 16:23 - FaultB Blanking Time"]
            #[inline(always)]
            pub fn blankval(&self) -> BLANKVALR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BLANKVALR { bits }
            }
            #[doc = "Bits 24:27 - FaultB Filter Value"]
            #[inline(always)]
            pub fn filterval(&self) -> FILTERVALR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FILTERVALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - FaultB Source"]
            #[inline(always)]
            pub fn src(&mut self) -> _SRCW {
                _SRCW { w: self }
            }
            #[doc = "Bit 3 - FaultB Keeper"]
            #[inline(always)]
            pub fn keep(&mut self) -> _KEEPW {
                _KEEPW { w: self }
            }
            #[doc = "Bit 4 - FaultB Qualification"]
            #[inline(always)]
            pub fn qual(&mut self) -> _QUALW {
                _QUALW { w: self }
            }
            #[doc = "Bits 5:6 - FaultB Blanking Mode"]
            #[inline(always)]
            pub fn blank(&mut self) -> _BLANKW {
                _BLANKW { w: self }
            }
            #[doc = "Bit 7 - FaultB Restart"]
            #[inline(always)]
            pub fn restart(&mut self) -> _RESTARTW {
                _RESTARTW { w: self }
            }
            #[doc = "Bits 8:9 - FaultB Halt Mode"]
            #[inline(always)]
            pub fn halt(&mut self) -> _HALTW {
                _HALTW { w: self }
            }
            #[doc = "Bits 10:11 - FaultB Capture Channel"]
            #[inline(always)]
            pub fn chsel(&mut self) -> _CHSELW {
                _CHSELW { w: self }
            }
            #[doc = "Bits 12:14 - FaultB Capture Action"]
            #[inline(always)]
            pub fn capture(&mut self) -> _CAPTUREW {
                _CAPTUREW { w: self }
            }
            #[doc = "Bits 16:23 - FaultB Blanking Time"]
            #[inline(always)]
            pub fn blankval(&mut self) -> _BLANKVALW {
                _BLANKVALW { w: self }
            }
            #[doc = "Bits 24:27 - FaultB Filter Value"]
            #[inline(always)]
            pub fn filterval(&mut self) -> _FILTERVALW {
                _FILTERVALW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVFR {
            bits: bool,
        }
        impl OVFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRGR {
            bits: bool,
        }
        impl TRGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNTR {
            bits: bool,
        }
        impl CNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRR {
            bits: bool,
        }
        impl ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFSR {
            bits: bool,
        }
        impl DFSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULTAR {
            bits: bool,
        }
        impl FAULTAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULTBR {
            bits: bool,
        }
        impl FAULTBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULT0R {
            bits: bool,
        }
        impl FAULT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULT1R {
            bits: bool,
        }
        impl FAULT1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC0R {
            bits: bool,
        }
        impl MC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC1R {
            bits: bool,
        }
        impl MC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC2R {
            bits: bool,
        }
        impl MC2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC3R {
            bits: bool,
        }
        impl MC3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULTAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULTAW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULTBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULTBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULT0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULT1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Overflow Interrupt Enable"]
            #[inline(always)]
            pub fn ovf(&self) -> OVFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVFR { bits }
            }
            #[doc = "Bit 1 - Retrigger Interrupt Enable"]
            #[inline(always)]
            pub fn trg(&self) -> TRGR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TRGR { bits }
            }
            #[doc = "Bit 2 - Counter Interrupt Enable"]
            #[inline(always)]
            pub fn cnt(&self) -> CNTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CNTR { bits }
            }
            #[doc = "Bit 3 - Error Interrupt Enable"]
            #[inline(always)]
            pub fn err(&self) -> ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERRR { bits }
            }
            #[doc = "Bit 11 - Non-recoverable Debug Fault Interrupt Enable"]
            #[inline(always)]
            pub fn dfs(&self) -> DFSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFSR { bits }
            }
            #[doc = "Bit 12 - Recoverable FaultA Interrupt Enable"]
            #[inline(always)]
            pub fn faulta(&self) -> FAULTAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULTAR { bits }
            }
            #[doc = "Bit 13 - Recoverable FaultB Interrupt Enable"]
            #[inline(always)]
            pub fn faultb(&self) -> FAULTBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULTBR { bits }
            }
            #[doc = "Bit 14 - Non-Recoverable Fault 0 Interrupt Enable"]
            #[inline(always)]
            pub fn fault0(&self) -> FAULT0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULT0R { bits }
            }
            #[doc = "Bit 15 - Non-Recoverable Fault 1 Interrupt Enable"]
            #[inline(always)]
            pub fn fault1(&self) -> FAULT1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULT1R { bits }
            }
            #[doc = "Bit 16 - Match or Capture Channel 0 Interrupt Enable"]
            #[inline(always)]
            pub fn mc0(&self) -> MC0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MC0R { bits }
            }
            #[doc = "Bit 17 - Match or Capture Channel 1 Interrupt Enable"]
            #[inline(always)]
            pub fn mc1(&self) -> MC1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MC1R { bits }
            }
            #[doc = "Bit 18 - Match or Capture Channel 2 Interrupt Enable"]
            #[inline(always)]
            pub fn mc2(&self) -> MC2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MC2R { bits }
            }
            #[doc = "Bit 19 - Match or Capture Channel 3 Interrupt Enable"]
            #[inline(always)]
            pub fn mc3(&self) -> MC3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MC3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Overflow Interrupt Enable"]
            #[inline(always)]
            pub fn ovf(&mut self) -> _OVFW {
                _OVFW { w: self }
            }
            #[doc = "Bit 1 - Retrigger Interrupt Enable"]
            #[inline(always)]
            pub fn trg(&mut self) -> _TRGW {
                _TRGW { w: self }
            }
            #[doc = "Bit 2 - Counter Interrupt Enable"]
            #[inline(always)]
            pub fn cnt(&mut self) -> _CNTW {
                _CNTW { w: self }
            }
            #[doc = "Bit 3 - Error Interrupt Enable"]
            #[inline(always)]
            pub fn err(&mut self) -> _ERRW {
                _ERRW { w: self }
            }
            #[doc = "Bit 11 - Non-recoverable Debug Fault Interrupt Enable"]
            #[inline(always)]
            pub fn dfs(&mut self) -> _DFSW {
                _DFSW { w: self }
            }
            #[doc = "Bit 12 - Recoverable FaultA Interrupt Enable"]
            #[inline(always)]
            pub fn faulta(&mut self) -> _FAULTAW {
                _FAULTAW { w: self }
            }
            #[doc = "Bit 13 - Recoverable FaultB Interrupt Enable"]
            #[inline(always)]
            pub fn faultb(&mut self) -> _FAULTBW {
                _FAULTBW { w: self }
            }
            #[doc = "Bit 14 - Non-Recoverable Fault 0 Interrupt Enable"]
            #[inline(always)]
            pub fn fault0(&mut self) -> _FAULT0W {
                _FAULT0W { w: self }
            }
            #[doc = "Bit 15 - Non-Recoverable Fault 1 Interrupt Enable"]
            #[inline(always)]
            pub fn fault1(&mut self) -> _FAULT1W {
                _FAULT1W { w: self }
            }
            #[doc = "Bit 16 - Match or Capture Channel 0 Interrupt Enable"]
            #[inline(always)]
            pub fn mc0(&mut self) -> _MC0W {
                _MC0W { w: self }
            }
            #[doc = "Bit 17 - Match or Capture Channel 1 Interrupt Enable"]
            #[inline(always)]
            pub fn mc1(&mut self) -> _MC1W {
                _MC1W { w: self }
            }
            #[doc = "Bit 18 - Match or Capture Channel 2 Interrupt Enable"]
            #[inline(always)]
            pub fn mc2(&mut self) -> _MC2W {
                _MC2W { w: self }
            }
            #[doc = "Bit 19 - Match or Capture Channel 3 Interrupt Enable"]
            #[inline(always)]
            pub fn mc3(&mut self) -> _MC3W {
                _MC3W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVFR {
            bits: bool,
        }
        impl OVFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRGR {
            bits: bool,
        }
        impl TRGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNTR {
            bits: bool,
        }
        impl CNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRR {
            bits: bool,
        }
        impl ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFSR {
            bits: bool,
        }
        impl DFSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULTAR {
            bits: bool,
        }
        impl FAULTAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULTBR {
            bits: bool,
        }
        impl FAULTBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULT0R {
            bits: bool,
        }
        impl FAULT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULT1R {
            bits: bool,
        }
        impl FAULT1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC0R {
            bits: bool,
        }
        impl MC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC1R {
            bits: bool,
        }
        impl MC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC2R {
            bits: bool,
        }
        impl MC2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC3R {
            bits: bool,
        }
        impl MC3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULTAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULTAW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULTBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULTBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULT0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULT1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Overflow Interrupt Enable"]
            #[inline(always)]
            pub fn ovf(&self) -> OVFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVFR { bits }
            }
            #[doc = "Bit 1 - Retrigger Interrupt Enable"]
            #[inline(always)]
            pub fn trg(&self) -> TRGR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TRGR { bits }
            }
            #[doc = "Bit 2 - Counter Interrupt Enable"]
            #[inline(always)]
            pub fn cnt(&self) -> CNTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CNTR { bits }
            }
            #[doc = "Bit 3 - Error Interrupt Enable"]
            #[inline(always)]
            pub fn err(&self) -> ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERRR { bits }
            }
            #[doc = "Bit 11 - Non-Recoverable Debug Fault Interrupt Enable"]
            #[inline(always)]
            pub fn dfs(&self) -> DFSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFSR { bits }
            }
            #[doc = "Bit 12 - Recoverable FaultA Interrupt Enable"]
            #[inline(always)]
            pub fn faulta(&self) -> FAULTAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULTAR { bits }
            }
            #[doc = "Bit 13 - Recoverable FaultB Interrupt Enable"]
            #[inline(always)]
            pub fn faultb(&self) -> FAULTBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULTBR { bits }
            }
            #[doc = "Bit 14 - Non-Recoverable Fault 0 Interrupt Enable"]
            #[inline(always)]
            pub fn fault0(&self) -> FAULT0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULT0R { bits }
            }
            #[doc = "Bit 15 - Non-Recoverable Fault 1 Interrupt Enabl"]
            #[inline(always)]
            pub fn fault1(&self) -> FAULT1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULT1R { bits }
            }
            #[doc = "Bit 16 - Match or Capture Channel 0 Interrupt Enable"]
            #[inline(always)]
            pub fn mc0(&self) -> MC0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MC0R { bits }
            }
            #[doc = "Bit 17 - Match or Capture Channel 1 Interrupt Enable"]
            #[inline(always)]
            pub fn mc1(&self) -> MC1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MC1R { bits }
            }
            #[doc = "Bit 18 - Match or Capture Channel 2 Interrupt Enable"]
            #[inline(always)]
            pub fn mc2(&self) -> MC2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MC2R { bits }
            }
            #[doc = "Bit 19 - Match or Capture Channel 3 Interrupt Enable"]
            #[inline(always)]
            pub fn mc3(&self) -> MC3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MC3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Overflow Interrupt Enable"]
            #[inline(always)]
            pub fn ovf(&mut self) -> _OVFW {
                _OVFW { w: self }
            }
            #[doc = "Bit 1 - Retrigger Interrupt Enable"]
            #[inline(always)]
            pub fn trg(&mut self) -> _TRGW {
                _TRGW { w: self }
            }
            #[doc = "Bit 2 - Counter Interrupt Enable"]
            #[inline(always)]
            pub fn cnt(&mut self) -> _CNTW {
                _CNTW { w: self }
            }
            #[doc = "Bit 3 - Error Interrupt Enable"]
            #[inline(always)]
            pub fn err(&mut self) -> _ERRW {
                _ERRW { w: self }
            }
            #[doc = "Bit 11 - Non-Recoverable Debug Fault Interrupt Enable"]
            #[inline(always)]
            pub fn dfs(&mut self) -> _DFSW {
                _DFSW { w: self }
            }
            #[doc = "Bit 12 - Recoverable FaultA Interrupt Enable"]
            #[inline(always)]
            pub fn faulta(&mut self) -> _FAULTAW {
                _FAULTAW { w: self }
            }
            #[doc = "Bit 13 - Recoverable FaultB Interrupt Enable"]
            #[inline(always)]
            pub fn faultb(&mut self) -> _FAULTBW {
                _FAULTBW { w: self }
            }
            #[doc = "Bit 14 - Non-Recoverable Fault 0 Interrupt Enable"]
            #[inline(always)]
            pub fn fault0(&mut self) -> _FAULT0W {
                _FAULT0W { w: self }
            }
            #[doc = "Bit 15 - Non-Recoverable Fault 1 Interrupt Enabl"]
            #[inline(always)]
            pub fn fault1(&mut self) -> _FAULT1W {
                _FAULT1W { w: self }
            }
            #[doc = "Bit 16 - Match or Capture Channel 0 Interrupt Enable"]
            #[inline(always)]
            pub fn mc0(&mut self) -> _MC0W {
                _MC0W { w: self }
            }
            #[doc = "Bit 17 - Match or Capture Channel 1 Interrupt Enable"]
            #[inline(always)]
            pub fn mc1(&mut self) -> _MC1W {
                _MC1W { w: self }
            }
            #[doc = "Bit 18 - Match or Capture Channel 2 Interrupt Enable"]
            #[inline(always)]
            pub fn mc2(&mut self) -> _MC2W {
                _MC2W { w: self }
            }
            #[doc = "Bit 19 - Match or Capture Channel 3 Interrupt Enable"]
            #[inline(always)]
            pub fn mc3(&mut self) -> _MC3W {
                _MC3W { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVFR {
            bits: bool,
        }
        impl OVFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRGR {
            bits: bool,
        }
        impl TRGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNTR {
            bits: bool,
        }
        impl CNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRR {
            bits: bool,
        }
        impl ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFSR {
            bits: bool,
        }
        impl DFSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULTAR {
            bits: bool,
        }
        impl FAULTAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULTBR {
            bits: bool,
        }
        impl FAULTBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULT0R {
            bits: bool,
        }
        impl FAULT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULT1R {
            bits: bool,
        }
        impl FAULT1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC0R {
            bits: bool,
        }
        impl MC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC1R {
            bits: bool,
        }
        impl MC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC2R {
            bits: bool,
        }
        impl MC2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC3R {
            bits: bool,
        }
        impl MC3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULTAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULTAW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULTBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULTBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULT0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULT1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Overflow"]
            #[inline(always)]
            pub fn ovf(&self) -> OVFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVFR { bits }
            }
            #[doc = "Bit 1 - Retrigger"]
            #[inline(always)]
            pub fn trg(&self) -> TRGR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TRGR { bits }
            }
            #[doc = "Bit 2 - Counter"]
            #[inline(always)]
            pub fn cnt(&self) -> CNTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CNTR { bits }
            }
            #[doc = "Bit 3 - Error"]
            #[inline(always)]
            pub fn err(&self) -> ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERRR { bits }
            }
            #[doc = "Bit 11 - Non-Recoverable Debug Fault"]
            #[inline(always)]
            pub fn dfs(&self) -> DFSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFSR { bits }
            }
            #[doc = "Bit 12 - Recoverable FaultA"]
            #[inline(always)]
            pub fn faulta(&self) -> FAULTAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULTAR { bits }
            }
            #[doc = "Bit 13 - Recoverable FaultB"]
            #[inline(always)]
            pub fn faultb(&self) -> FAULTBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULTBR { bits }
            }
            #[doc = "Bit 14 - Non-Recoverable Fault 0"]
            #[inline(always)]
            pub fn fault0(&self) -> FAULT0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULT0R { bits }
            }
            #[doc = "Bit 15 - Non-Recoverable Fault 1"]
            #[inline(always)]
            pub fn fault1(&self) -> FAULT1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULT1R { bits }
            }
            #[doc = "Bit 16 - Match or Capture 0"]
            #[inline(always)]
            pub fn mc0(&self) -> MC0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MC0R { bits }
            }
            #[doc = "Bit 17 - Match or Capture 1"]
            #[inline(always)]
            pub fn mc1(&self) -> MC1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MC1R { bits }
            }
            #[doc = "Bit 18 - Match or Capture 2"]
            #[inline(always)]
            pub fn mc2(&self) -> MC2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MC2R { bits }
            }
            #[doc = "Bit 19 - Match or Capture 3"]
            #[inline(always)]
            pub fn mc3(&self) -> MC3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MC3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Overflow"]
            #[inline(always)]
            pub fn ovf(&mut self) -> _OVFW {
                _OVFW { w: self }
            }
            #[doc = "Bit 1 - Retrigger"]
            #[inline(always)]
            pub fn trg(&mut self) -> _TRGW {
                _TRGW { w: self }
            }
            #[doc = "Bit 2 - Counter"]
            #[inline(always)]
            pub fn cnt(&mut self) -> _CNTW {
                _CNTW { w: self }
            }
            #[doc = "Bit 3 - Error"]
            #[inline(always)]
            pub fn err(&mut self) -> _ERRW {
                _ERRW { w: self }
            }
            #[doc = "Bit 11 - Non-Recoverable Debug Fault"]
            #[inline(always)]
            pub fn dfs(&mut self) -> _DFSW {
                _DFSW { w: self }
            }
            #[doc = "Bit 12 - Recoverable FaultA"]
            #[inline(always)]
            pub fn faulta(&mut self) -> _FAULTAW {
                _FAULTAW { w: self }
            }
            #[doc = "Bit 13 - Recoverable FaultB"]
            #[inline(always)]
            pub fn faultb(&mut self) -> _FAULTBW {
                _FAULTBW { w: self }
            }
            #[doc = "Bit 14 - Non-Recoverable Fault 0"]
            #[inline(always)]
            pub fn fault0(&mut self) -> _FAULT0W {
                _FAULT0W { w: self }
            }
            #[doc = "Bit 15 - Non-Recoverable Fault 1"]
            #[inline(always)]
            pub fn fault1(&mut self) -> _FAULT1W {
                _FAULT1W { w: self }
            }
            #[doc = "Bit 16 - Match or Capture 0"]
            #[inline(always)]
            pub fn mc0(&mut self) -> _MC0W {
                _MC0W { w: self }
            }
            #[doc = "Bit 17 - Match or Capture 1"]
            #[inline(always)]
            pub fn mc1(&mut self) -> _MC1W {
                _MC1W { w: self }
            }
            #[doc = "Bit 18 - Match or Capture 2"]
            #[inline(always)]
            pub fn mc2(&mut self) -> _MC2W {
                _MC2W { w: self }
            }
            #[doc = "Bit 19 - Match or Capture 3"]
            #[inline(always)]
            pub fn mc3(&mut self) -> _MC3W {
                _MC3W { w: self }
            }
        }
    }
    #[doc = "Pattern"]
    pub struct PATT {
        register: VolatileCell<u16>,
    }
    #[doc = "Pattern"]
    pub mod patt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::PATT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGE0R {
            bits: bool,
        }
        impl PGE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGE1R {
            bits: bool,
        }
        impl PGE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGE2R {
            bits: bool,
        }
        impl PGE2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGE3R {
            bits: bool,
        }
        impl PGE3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGE4R {
            bits: bool,
        }
        impl PGE4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGE5R {
            bits: bool,
        }
        impl PGE5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGE6R {
            bits: bool,
        }
        impl PGE6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGE7R {
            bits: bool,
        }
        impl PGE7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGV0R {
            bits: bool,
        }
        impl PGV0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGV1R {
            bits: bool,
        }
        impl PGV1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGV2R {
            bits: bool,
        }
        impl PGV2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGV3R {
            bits: bool,
        }
        impl PGV3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGV4R {
            bits: bool,
        }
        impl PGV4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGV5R {
            bits: bool,
        }
        impl PGV5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGV6R {
            bits: bool,
        }
        impl PGV6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGV7R {
            bits: bool,
        }
        impl PGV7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGE0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGE1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGE2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGE3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGE4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGE4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGE5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGE5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGE6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGE6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGE7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGE7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGV0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGV0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGV1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGV1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGV2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGV2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGV3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGV3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGV4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGV4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGV5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGV5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGV6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGV6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGV7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGV7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Pattern Generator 0 Output Enable"]
            #[inline(always)]
            pub fn pge0(&self) -> PGE0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGE0R { bits }
            }
            #[doc = "Bit 1 - Pattern Generator 1 Output Enable"]
            #[inline(always)]
            pub fn pge1(&self) -> PGE1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGE1R { bits }
            }
            #[doc = "Bit 2 - Pattern Generator 2 Output Enable"]
            #[inline(always)]
            pub fn pge2(&self) -> PGE2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGE2R { bits }
            }
            #[doc = "Bit 3 - Pattern Generator 3 Output Enable"]
            #[inline(always)]
            pub fn pge3(&self) -> PGE3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGE3R { bits }
            }
            #[doc = "Bit 4 - Pattern Generator 4 Output Enable"]
            #[inline(always)]
            pub fn pge4(&self) -> PGE4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGE4R { bits }
            }
            #[doc = "Bit 5 - Pattern Generator 5 Output Enable"]
            #[inline(always)]
            pub fn pge5(&self) -> PGE5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGE5R { bits }
            }
            #[doc = "Bit 6 - Pattern Generator 6 Output Enable"]
            #[inline(always)]
            pub fn pge6(&self) -> PGE6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGE6R { bits }
            }
            #[doc = "Bit 7 - Pattern Generator 7 Output Enable"]
            #[inline(always)]
            pub fn pge7(&self) -> PGE7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGE7R { bits }
            }
            #[doc = "Bit 8 - Pattern Generator 0 Output Value"]
            #[inline(always)]
            pub fn pgv0(&self) -> PGV0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGV0R { bits }
            }
            #[doc = "Bit 9 - Pattern Generator 1 Output Value"]
            #[inline(always)]
            pub fn pgv1(&self) -> PGV1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGV1R { bits }
            }
            #[doc = "Bit 10 - Pattern Generator 2 Output Value"]
            #[inline(always)]
            pub fn pgv2(&self) -> PGV2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGV2R { bits }
            }
            #[doc = "Bit 11 - Pattern Generator 3 Output Value"]
            #[inline(always)]
            pub fn pgv3(&self) -> PGV3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGV3R { bits }
            }
            #[doc = "Bit 12 - Pattern Generator 4 Output Value"]
            #[inline(always)]
            pub fn pgv4(&self) -> PGV4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGV4R { bits }
            }
            #[doc = "Bit 13 - Pattern Generator 5 Output Value"]
            #[inline(always)]
            pub fn pgv5(&self) -> PGV5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGV5R { bits }
            }
            #[doc = "Bit 14 - Pattern Generator 6 Output Value"]
            #[inline(always)]
            pub fn pgv6(&self) -> PGV6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGV6R { bits }
            }
            #[doc = "Bit 15 - Pattern Generator 7 Output Value"]
            #[inline(always)]
            pub fn pgv7(&self) -> PGV7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGV7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Pattern Generator 0 Output Enable"]
            #[inline(always)]
            pub fn pge0(&mut self) -> _PGE0W {
                _PGE0W { w: self }
            }
            #[doc = "Bit 1 - Pattern Generator 1 Output Enable"]
            #[inline(always)]
            pub fn pge1(&mut self) -> _PGE1W {
                _PGE1W { w: self }
            }
            #[doc = "Bit 2 - Pattern Generator 2 Output Enable"]
            #[inline(always)]
            pub fn pge2(&mut self) -> _PGE2W {
                _PGE2W { w: self }
            }
            #[doc = "Bit 3 - Pattern Generator 3 Output Enable"]
            #[inline(always)]
            pub fn pge3(&mut self) -> _PGE3W {
                _PGE3W { w: self }
            }
            #[doc = "Bit 4 - Pattern Generator 4 Output Enable"]
            #[inline(always)]
            pub fn pge4(&mut self) -> _PGE4W {
                _PGE4W { w: self }
            }
            #[doc = "Bit 5 - Pattern Generator 5 Output Enable"]
            #[inline(always)]
            pub fn pge5(&mut self) -> _PGE5W {
                _PGE5W { w: self }
            }
            #[doc = "Bit 6 - Pattern Generator 6 Output Enable"]
            #[inline(always)]
            pub fn pge6(&mut self) -> _PGE6W {
                _PGE6W { w: self }
            }
            #[doc = "Bit 7 - Pattern Generator 7 Output Enable"]
            #[inline(always)]
            pub fn pge7(&mut self) -> _PGE7W {
                _PGE7W { w: self }
            }
            #[doc = "Bit 8 - Pattern Generator 0 Output Value"]
            #[inline(always)]
            pub fn pgv0(&mut self) -> _PGV0W {
                _PGV0W { w: self }
            }
            #[doc = "Bit 9 - Pattern Generator 1 Output Value"]
            #[inline(always)]
            pub fn pgv1(&mut self) -> _PGV1W {
                _PGV1W { w: self }
            }
            #[doc = "Bit 10 - Pattern Generator 2 Output Value"]
            #[inline(always)]
            pub fn pgv2(&mut self) -> _PGV2W {
                _PGV2W { w: self }
            }
            #[doc = "Bit 11 - Pattern Generator 3 Output Value"]
            #[inline(always)]
            pub fn pgv3(&mut self) -> _PGV3W {
                _PGV3W { w: self }
            }
            #[doc = "Bit 12 - Pattern Generator 4 Output Value"]
            #[inline(always)]
            pub fn pgv4(&mut self) -> _PGV4W {
                _PGV4W { w: self }
            }
            #[doc = "Bit 13 - Pattern Generator 5 Output Value"]
            #[inline(always)]
            pub fn pgv5(&mut self) -> _PGV5W {
                _PGV5W { w: self }
            }
            #[doc = "Bit 14 - Pattern Generator 6 Output Value"]
            #[inline(always)]
            pub fn pgv6(&mut self) -> _PGV6W {
                _PGV6W { w: self }
            }
            #[doc = "Bit 15 - Pattern Generator 7 Output Value"]
            #[inline(always)]
            pub fn pgv7(&mut self) -> _PGV7W {
                _PGV7W { w: self }
            }
        }
    }
    #[doc = "Pattern Buffer"]
    pub struct PATTB {
        register: VolatileCell<u16>,
    }
    #[doc = "Pattern Buffer"]
    pub mod pattb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::PATTB {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGEB0R {
            bits: bool,
        }
        impl PGEB0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGEB1R {
            bits: bool,
        }
        impl PGEB1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGEB2R {
            bits: bool,
        }
        impl PGEB2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGEB3R {
            bits: bool,
        }
        impl PGEB3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGEB4R {
            bits: bool,
        }
        impl PGEB4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGEB5R {
            bits: bool,
        }
        impl PGEB5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGEB6R {
            bits: bool,
        }
        impl PGEB6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGEB7R {
            bits: bool,
        }
        impl PGEB7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGVB0R {
            bits: bool,
        }
        impl PGVB0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGVB1R {
            bits: bool,
        }
        impl PGVB1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGVB2R {
            bits: bool,
        }
        impl PGVB2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGVB3R {
            bits: bool,
        }
        impl PGVB3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGVB4R {
            bits: bool,
        }
        impl PGVB4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGVB5R {
            bits: bool,
        }
        impl PGVB5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGVB6R {
            bits: bool,
        }
        impl PGVB6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGVB7R {
            bits: bool,
        }
        impl PGVB7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGEB0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGEB0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGEB1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGEB1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGEB2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGEB2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGEB3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGEB3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGEB4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGEB4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGEB5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGEB5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGEB6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGEB6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGEB7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGEB7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGVB0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGVB0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGVB1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGVB1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGVB2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGVB2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGVB3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGVB3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGVB4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGVB4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGVB5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGVB5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGVB6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGVB6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGVB7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGVB7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Pattern Generator 0 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb0(&self) -> PGEB0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGEB0R { bits }
            }
            #[doc = "Bit 1 - Pattern Generator 1 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb1(&self) -> PGEB1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGEB1R { bits }
            }
            #[doc = "Bit 2 - Pattern Generator 2 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb2(&self) -> PGEB2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGEB2R { bits }
            }
            #[doc = "Bit 3 - Pattern Generator 3 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb3(&self) -> PGEB3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGEB3R { bits }
            }
            #[doc = "Bit 4 - Pattern Generator 4 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb4(&self) -> PGEB4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGEB4R { bits }
            }
            #[doc = "Bit 5 - Pattern Generator 5 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb5(&self) -> PGEB5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGEB5R { bits }
            }
            #[doc = "Bit 6 - Pattern Generator 6 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb6(&self) -> PGEB6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGEB6R { bits }
            }
            #[doc = "Bit 7 - Pattern Generator 7 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb7(&self) -> PGEB7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGEB7R { bits }
            }
            #[doc = "Bit 8 - Pattern Generator 0 Output Enable"]
            #[inline(always)]
            pub fn pgvb0(&self) -> PGVB0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGVB0R { bits }
            }
            #[doc = "Bit 9 - Pattern Generator 1 Output Enable"]
            #[inline(always)]
            pub fn pgvb1(&self) -> PGVB1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGVB1R { bits }
            }
            #[doc = "Bit 10 - Pattern Generator 2 Output Enable"]
            #[inline(always)]
            pub fn pgvb2(&self) -> PGVB2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGVB2R { bits }
            }
            #[doc = "Bit 11 - Pattern Generator 3 Output Enable"]
            #[inline(always)]
            pub fn pgvb3(&self) -> PGVB3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGVB3R { bits }
            }
            #[doc = "Bit 12 - Pattern Generator 4 Output Enable"]
            #[inline(always)]
            pub fn pgvb4(&self) -> PGVB4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGVB4R { bits }
            }
            #[doc = "Bit 13 - Pattern Generator 5 Output Enable"]
            #[inline(always)]
            pub fn pgvb5(&self) -> PGVB5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGVB5R { bits }
            }
            #[doc = "Bit 14 - Pattern Generator 6 Output Enable"]
            #[inline(always)]
            pub fn pgvb6(&self) -> PGVB6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGVB6R { bits }
            }
            #[doc = "Bit 15 - Pattern Generator 7 Output Enable"]
            #[inline(always)]
            pub fn pgvb7(&self) -> PGVB7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PGVB7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Pattern Generator 0 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb0(&mut self) -> _PGEB0W {
                _PGEB0W { w: self }
            }
            #[doc = "Bit 1 - Pattern Generator 1 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb1(&mut self) -> _PGEB1W {
                _PGEB1W { w: self }
            }
            #[doc = "Bit 2 - Pattern Generator 2 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb2(&mut self) -> _PGEB2W {
                _PGEB2W { w: self }
            }
            #[doc = "Bit 3 - Pattern Generator 3 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb3(&mut self) -> _PGEB3W {
                _PGEB3W { w: self }
            }
            #[doc = "Bit 4 - Pattern Generator 4 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb4(&mut self) -> _PGEB4W {
                _PGEB4W { w: self }
            }
            #[doc = "Bit 5 - Pattern Generator 5 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb5(&mut self) -> _PGEB5W {
                _PGEB5W { w: self }
            }
            #[doc = "Bit 6 - Pattern Generator 6 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb6(&mut self) -> _PGEB6W {
                _PGEB6W { w: self }
            }
            #[doc = "Bit 7 - Pattern Generator 7 Output Enable Buffer"]
            #[inline(always)]
            pub fn pgeb7(&mut self) -> _PGEB7W {
                _PGEB7W { w: self }
            }
            #[doc = "Bit 8 - Pattern Generator 0 Output Enable"]
            #[inline(always)]
            pub fn pgvb0(&mut self) -> _PGVB0W {
                _PGVB0W { w: self }
            }
            #[doc = "Bit 9 - Pattern Generator 1 Output Enable"]
            #[inline(always)]
            pub fn pgvb1(&mut self) -> _PGVB1W {
                _PGVB1W { w: self }
            }
            #[doc = "Bit 10 - Pattern Generator 2 Output Enable"]
            #[inline(always)]
            pub fn pgvb2(&mut self) -> _PGVB2W {
                _PGVB2W { w: self }
            }
            #[doc = "Bit 11 - Pattern Generator 3 Output Enable"]
            #[inline(always)]
            pub fn pgvb3(&mut self) -> _PGVB3W {
                _PGVB3W { w: self }
            }
            #[doc = "Bit 12 - Pattern Generator 4 Output Enable"]
            #[inline(always)]
            pub fn pgvb4(&mut self) -> _PGVB4W {
                _PGVB4W { w: self }
            }
            #[doc = "Bit 13 - Pattern Generator 5 Output Enable"]
            #[inline(always)]
            pub fn pgvb5(&mut self) -> _PGVB5W {
                _PGVB5W { w: self }
            }
            #[doc = "Bit 14 - Pattern Generator 6 Output Enable"]
            #[inline(always)]
            pub fn pgvb6(&mut self) -> _PGVB6W {
                _PGVB6W { w: self }
            }
            #[doc = "Bit 15 - Pattern Generator 7 Output Enable"]
            #[inline(always)]
            pub fn pgvb7(&mut self) -> _PGVB7W {
                _PGVB7W { w: self }
            }
        }
    }
    #[doc = "Period"]
    pub struct PER {
        register: VolatileCell<u32>,
    }
    #[doc = "Period"]
    pub mod per {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PER {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PERR {
            bits: u32,
        }
        impl PERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PERW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 16777215;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Period Value"]
            #[inline(always)]
            pub fn per(&self) -> PERR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PERR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Period Value"]
            #[inline(always)]
            pub fn per(&mut self) -> _PERW {
                _PERW { w: self }
            }
        }
    }
    #[doc = "Period Buffer"]
    pub struct PERB {
        register: VolatileCell<u32>,
    }
    #[doc = "Period Buffer"]
    pub mod perb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PERB {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PERBR {
            bits: u32,
        }
        impl PERBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PERBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PERBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 16777215;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Period Value"]
            #[inline(always)]
            pub fn perb(&self) -> PERBR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PERBR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Period Value"]
            #[inline(always)]
            pub fn perb(&mut self) -> _PERBW {
                _PERBW { w: self }
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u32>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STATUS {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPR {
            bits: bool,
        }
        impl STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDXR {
            bits: bool,
        }
        impl IDXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFSR {
            bits: bool,
        }
        impl DFSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PATTBVR {
            bits: bool,
        }
        impl PATTBVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAVEBVR {
            bits: bool,
        }
        impl WAVEBVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PERBVR {
            bits: bool,
        }
        impl PERBVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULTAINR {
            bits: bool,
        }
        impl FAULTAINR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULTBINR {
            bits: bool,
        }
        impl FAULTBINR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULT0INR {
            bits: bool,
        }
        impl FAULT0INR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULT1INR {
            bits: bool,
        }
        impl FAULT1INR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULTAR {
            bits: bool,
        }
        impl FAULTAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULTBR {
            bits: bool,
        }
        impl FAULTBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULT0R {
            bits: bool,
        }
        impl FAULT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAULT1R {
            bits: bool,
        }
        impl FAULT1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCBV0R {
            bits: bool,
        }
        impl CCBV0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCBV1R {
            bits: bool,
        }
        impl CCBV1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCBV2R {
            bits: bool,
        }
        impl CCBV2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCBV3R {
            bits: bool,
        }
        impl CCBV3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMP0R {
            bits: bool,
        }
        impl CMP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMP1R {
            bits: bool,
        }
        impl CMP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMP2R {
            bits: bool,
        }
        impl CMP2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMP3R {
            bits: bool,
        }
        impl CMP3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PATTBVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PATTBVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAVEBVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAVEBVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PERBVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PERBVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULTAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULTAW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULTBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULTBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULT0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAULT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAULT1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCBV0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCBV0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCBV1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCBV1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCBV2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCBV2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCBV3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCBV3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Stop"]
            #[inline(always)]
            pub fn stop(&self) -> STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STOPR { bits }
            }
            #[doc = "Bit 1 - Ramp"]
            #[inline(always)]
            pub fn idx(&self) -> IDXR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IDXR { bits }
            }
            #[doc = "Bit 3 - Non-Recoverable Debug Fault State"]
            #[inline(always)]
            pub fn dfs(&self) -> DFSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFSR { bits }
            }
            #[doc = "Bit 5 - Pattern Buffer Valid"]
            #[inline(always)]
            pub fn pattbv(&self) -> PATTBVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PATTBVR { bits }
            }
            #[doc = "Bit 6 - Wave Buffer Valid"]
            #[inline(always)]
            pub fn wavebv(&self) -> WAVEBVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAVEBVR { bits }
            }
            #[doc = "Bit 7 - Period Buffer Valid"]
            #[inline(always)]
            pub fn perbv(&self) -> PERBVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PERBVR { bits }
            }
            #[doc = "Bit 8 - Recoverable FaultA Input"]
            #[inline(always)]
            pub fn faultain(&self) -> FAULTAINR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULTAINR { bits }
            }
            #[doc = "Bit 9 - Recoverable FaultB Input"]
            #[inline(always)]
            pub fn faultbin(&self) -> FAULTBINR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULTBINR { bits }
            }
            #[doc = "Bit 10 - Non-Recoverable Fault0 Input"]
            #[inline(always)]
            pub fn fault0in(&self) -> FAULT0INR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULT0INR { bits }
            }
            #[doc = "Bit 11 - Non-Recoverable Fault1 Input"]
            #[inline(always)]
            pub fn fault1in(&self) -> FAULT1INR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULT1INR { bits }
            }
            #[doc = "Bit 12 - Recoverable FaultA State"]
            #[inline(always)]
            pub fn faulta(&self) -> FAULTAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULTAR { bits }
            }
            #[doc = "Bit 13 - Recoverable FaultB State"]
            #[inline(always)]
            pub fn faultb(&self) -> FAULTBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULTBR { bits }
            }
            #[doc = "Bit 14 - Non-Recoverable Fault 0 State"]
            #[inline(always)]
            pub fn fault0(&self) -> FAULT0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULT0R { bits }
            }
            #[doc = "Bit 15 - Non-Recoverable Fault 1 State"]
            #[inline(always)]
            pub fn fault1(&self) -> FAULT1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FAULT1R { bits }
            }
            #[doc = "Bit 16 - Compare Channel 0 Buffer Valid"]
            #[inline(always)]
            pub fn ccbv0(&self) -> CCBV0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCBV0R { bits }
            }
            #[doc = "Bit 17 - Compare Channel 1 Buffer Valid"]
            #[inline(always)]
            pub fn ccbv1(&self) -> CCBV1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCBV1R { bits }
            }
            #[doc = "Bit 18 - Compare Channel 2 Buffer Valid"]
            #[inline(always)]
            pub fn ccbv2(&self) -> CCBV2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCBV2R { bits }
            }
            #[doc = "Bit 19 - Compare Channel 3 Buffer Valid"]
            #[inline(always)]
            pub fn ccbv3(&self) -> CCBV3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCBV3R { bits }
            }
            #[doc = "Bit 24 - Compare Channel 0 Value"]
            #[inline(always)]
            pub fn cmp0(&self) -> CMP0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CMP0R { bits }
            }
            #[doc = "Bit 25 - Compare Channel 1 Value"]
            #[inline(always)]
            pub fn cmp1(&self) -> CMP1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CMP1R { bits }
            }
            #[doc = "Bit 26 - Compare Channel 2 Value"]
            #[inline(always)]
            pub fn cmp2(&self) -> CMP2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CMP2R { bits }
            }
            #[doc = "Bit 27 - Compare Channel 3 Value"]
            #[inline(always)]
            pub fn cmp3(&self) -> CMP3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CMP3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 1 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 3 - Non-Recoverable Debug Fault State"]
            #[inline(always)]
            pub fn dfs(&mut self) -> _DFSW {
                _DFSW { w: self }
            }
            #[doc = "Bit 5 - Pattern Buffer Valid"]
            #[inline(always)]
            pub fn pattbv(&mut self) -> _PATTBVW {
                _PATTBVW { w: self }
            }
            #[doc = "Bit 6 - Wave Buffer Valid"]
            #[inline(always)]
            pub fn wavebv(&mut self) -> _WAVEBVW {
                _WAVEBVW { w: self }
            }
            #[doc = "Bit 7 - Period Buffer Valid"]
            #[inline(always)]
            pub fn perbv(&mut self) -> _PERBVW {
                _PERBVW { w: self }
            }
            #[doc = "Bit 12 - Recoverable FaultA State"]
            #[inline(always)]
            pub fn faulta(&mut self) -> _FAULTAW {
                _FAULTAW { w: self }
            }
            #[doc = "Bit 13 - Recoverable FaultB State"]
            #[inline(always)]
            pub fn faultb(&mut self) -> _FAULTBW {
                _FAULTBW { w: self }
            }
            #[doc = "Bit 14 - Non-Recoverable Fault 0 State"]
            #[inline(always)]
            pub fn fault0(&mut self) -> _FAULT0W {
                _FAULT0W { w: self }
            }
            #[doc = "Bit 15 - Non-Recoverable Fault 1 State"]
            #[inline(always)]
            pub fn fault1(&mut self) -> _FAULT1W {
                _FAULT1W { w: self }
            }
            #[doc = "Bit 16 - Compare Channel 0 Buffer Valid"]
            #[inline(always)]
            pub fn ccbv0(&mut self) -> _CCBV0W {
                _CCBV0W { w: self }
            }
            #[doc = "Bit 17 - Compare Channel 1 Buffer Valid"]
            #[inline(always)]
            pub fn ccbv1(&mut self) -> _CCBV1W {
                _CCBV1W { w: self }
            }
            #[doc = "Bit 18 - Compare Channel 2 Buffer Valid"]
            #[inline(always)]
            pub fn ccbv2(&mut self) -> _CCBV2W {
                _CCBV2W { w: self }
            }
            #[doc = "Bit 19 - Compare Channel 3 Buffer Valid"]
            #[inline(always)]
            pub fn ccbv3(&mut self) -> _CCBV3W {
                _CCBV3W { w: self }
            }
        }
    }
    #[doc = "Synchronization Busy"]
    pub struct SYNCBUSY {
        register: VolatileCell<u32>,
    }
    #[doc = "Synchronization Busy"]
    pub mod syncbusy {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::SYNCBUSY {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTRLBR {
            bits: bool,
        }
        impl CTRLBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATUSR {
            bits: bool,
        }
        impl STATUSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTR {
            bits: bool,
        }
        impl COUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PATTR {
            bits: bool,
        }
        impl PATTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAVER {
            bits: bool,
        }
        impl WAVER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PERR {
            bits: bool,
        }
        impl PERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC0R {
            bits: bool,
        }
        impl CC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1R {
            bits: bool,
        }
        impl CC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2R {
            bits: bool,
        }
        impl CC2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3R {
            bits: bool,
        }
        impl CC3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PATTBR {
            bits: bool,
        }
        impl PATTBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAVEBR {
            bits: bool,
        }
        impl WAVEBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PERBR {
            bits: bool,
        }
        impl PERBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCB0R {
            bits: bool,
        }
        impl CCB0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCB1R {
            bits: bool,
        }
        impl CCB1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCB2R {
            bits: bool,
        }
        impl CCB2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCB3R {
            bits: bool,
        }
        impl CCB3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Swrst Busy"]
            #[inline(always)]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWRSTR { bits }
            }
            #[doc = "Bit 1 - Enable Busy"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Ctrlb Busy"]
            #[inline(always)]
            pub fn ctrlb(&self) -> CTRLBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CTRLBR { bits }
            }
            #[doc = "Bit 3 - Status Busy"]
            #[inline(always)]
            pub fn status(&self) -> STATUSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STATUSR { bits }
            }
            #[doc = "Bit 4 - Count Busy"]
            #[inline(always)]
            pub fn count(&self) -> COUNTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                COUNTR { bits }
            }
            #[doc = "Bit 5 - Pattern Busy"]
            #[inline(always)]
            pub fn patt(&self) -> PATTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PATTR { bits }
            }
            #[doc = "Bit 6 - Wave Busy"]
            #[inline(always)]
            pub fn wave(&self) -> WAVER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAVER { bits }
            }
            #[doc = "Bit 7 - Period busy"]
            #[inline(always)]
            pub fn per(&self) -> PERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PERR { bits }
            }
            #[doc = "Bit 8 - Compare Channel Buffer 0 Busy"]
            #[inline(always)]
            pub fn cc0(&self) -> CC0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC0R { bits }
            }
            #[doc = "Bit 9 - Compare Channel Buffer 1 Busy"]
            #[inline(always)]
            pub fn cc1(&self) -> CC1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1R { bits }
            }
            #[doc = "Bit 10 - Compare Channel Buffer 2 Busy"]
            #[inline(always)]
            pub fn cc2(&self) -> CC2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2R { bits }
            }
            #[doc = "Bit 11 - Compare Channel Buffer 3 Busy"]
            #[inline(always)]
            pub fn cc3(&self) -> CC3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC3R { bits }
            }
            #[doc = "Bit 16 - Pattern Buffer Busy"]
            #[inline(always)]
            pub fn pattb(&self) -> PATTBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PATTBR { bits }
            }
            #[doc = "Bit 17 - Wave Buffer Busy"]
            #[inline(always)]
            pub fn waveb(&self) -> WAVEBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAVEBR { bits }
            }
            #[doc = "Bit 18 - Period Buffer Busy"]
            #[inline(always)]
            pub fn perb(&self) -> PERBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PERBR { bits }
            }
            #[doc = "Bit 19 - Compare Channel Buffer 0 Busy"]
            #[inline(always)]
            pub fn ccb0(&self) -> CCB0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCB0R { bits }
            }
            #[doc = "Bit 20 - Compare Channel Buffer 1 Busy"]
            #[inline(always)]
            pub fn ccb1(&self) -> CCB1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCB1R { bits }
            }
            #[doc = "Bit 21 - Compare Channel Buffer 2 Busy"]
            #[inline(always)]
            pub fn ccb2(&self) -> CCB2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCB2R { bits }
            }
            #[doc = "Bit 22 - Compare Channel Buffer 3 Busy"]
            #[inline(always)]
            pub fn ccb3(&self) -> CCB3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCB3R { bits }
            }
        }
    }
    #[doc = "Waveform Control"]
    pub struct WAVE {
        register: VolatileCell<u32>,
    }
    #[doc = "Waveform Control"]
    pub mod wave {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WAVE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WAVEGEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAVEGENR {
            #[doc = "undocumented"]
            NFRQ,
            #[doc = "undocumented"]
            MFRQ,
            #[doc = "undocumented"]
            NPWM,
            #[doc = "undocumented"]
            DSCRITICAL,
            #[doc = "undocumented"]
            DSBOTTOM,
            #[doc = "undocumented"]
            DSBOTH,
            #[doc = "undocumented"]
            DSTOP,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl WAVEGENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    WAVEGENR::NFRQ => 0,
                    WAVEGENR::MFRQ => 1,
                    WAVEGENR::NPWM => 2,
                    WAVEGENR::DSCRITICAL => 4,
                    WAVEGENR::DSBOTTOM => 5,
                    WAVEGENR::DSBOTH => 6,
                    WAVEGENR::DSTOP => 7,
                    WAVEGENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> WAVEGENR {
                match value {
                    0 => WAVEGENR::NFRQ,
                    1 => WAVEGENR::MFRQ,
                    2 => WAVEGENR::NPWM,
                    4 => WAVEGENR::DSCRITICAL,
                    5 => WAVEGENR::DSBOTTOM,
                    6 => WAVEGENR::DSBOTH,
                    7 => WAVEGENR::DSTOP,
                    i => WAVEGENR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NFRQ`"]
            #[inline(always)]
            pub fn is_nfrq(&self) -> bool {
                *self == WAVEGENR::NFRQ
            }
            #[doc = "Checks if the value of the field is `MFRQ`"]
            #[inline(always)]
            pub fn is_mfrq(&self) -> bool {
                *self == WAVEGENR::MFRQ
            }
            #[doc = "Checks if the value of the field is `NPWM`"]
            #[inline(always)]
            pub fn is_npwm(&self) -> bool {
                *self == WAVEGENR::NPWM
            }
            #[doc = "Checks if the value of the field is `DSCRITICAL`"]
            #[inline(always)]
            pub fn is_dscritical(&self) -> bool {
                *self == WAVEGENR::DSCRITICAL
            }
            #[doc = "Checks if the value of the field is `DSBOTTOM`"]
            #[inline(always)]
            pub fn is_dsbottom(&self) -> bool {
                *self == WAVEGENR::DSBOTTOM
            }
            #[doc = "Checks if the value of the field is `DSBOTH`"]
            #[inline(always)]
            pub fn is_dsboth(&self) -> bool {
                *self == WAVEGENR::DSBOTH
            }
            #[doc = "Checks if the value of the field is `DSTOP`"]
            #[inline(always)]
            pub fn is_dstop(&self) -> bool {
                *self == WAVEGENR::DSTOP
            }
        }
        #[doc = "Possible values of the field `RAMP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RAMPR {
            #[doc = "undocumented"]
            RAMP1,
            #[doc = "undocumented"]
            RAMP2A,
            #[doc = "undocumented"]
            RAMP2,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl RAMPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    RAMPR::RAMP1 => 0,
                    RAMPR::RAMP2A => 1,
                    RAMPR::RAMP2 => 2,
                    RAMPR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> RAMPR {
                match value {
                    0 => RAMPR::RAMP1,
                    1 => RAMPR::RAMP2A,
                    2 => RAMPR::RAMP2,
                    i => RAMPR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RAMP1`"]
            #[inline(always)]
            pub fn is_ramp1(&self) -> bool {
                *self == RAMPR::RAMP1
            }
            #[doc = "Checks if the value of the field is `RAMP2A`"]
            #[inline(always)]
            pub fn is_ramp2a(&self) -> bool {
                *self == RAMPR::RAMP2A
            }
            #[doc = "Checks if the value of the field is `RAMP2`"]
            #[inline(always)]
            pub fn is_ramp2(&self) -> bool {
                *self == RAMPR::RAMP2
            }
        }
        #[doc = r" Value of the field"]
        pub struct CIPERENR {
            bits: bool,
        }
        impl CIPERENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CICCEN0R {
            bits: bool,
        }
        impl CICCEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CICCEN1R {
            bits: bool,
        }
        impl CICCEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CICCEN2R {
            bits: bool,
        }
        impl CICCEN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CICCEN3R {
            bits: bool,
        }
        impl CICCEN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POL0R {
            bits: bool,
        }
        impl POL0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POL1R {
            bits: bool,
        }
        impl POL1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POL2R {
            bits: bool,
        }
        impl POL2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POL3R {
            bits: bool,
        }
        impl POL3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWAP0R {
            bits: bool,
        }
        impl SWAP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWAP1R {
            bits: bool,
        }
        impl SWAP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWAP2R {
            bits: bool,
        }
        impl SWAP2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWAP3R {
            bits: bool,
        }
        impl SWAP3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `WAVEGEN`"]
        pub enum WAVEGENW {
            #[doc = "`0`"]
            NFRQ,
            #[doc = "`1`"]
            MFRQ,
            #[doc = "`10`"]
            NPWM,
            #[doc = "`100`"]
            DSCRITICAL,
            #[doc = "`101`"]
            DSBOTTOM,
            #[doc = "`110`"]
            DSBOTH,
            #[doc = "`111`"]
            DSTOP,
        }
        impl WAVEGENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WAVEGENW::NFRQ => 0,
                    WAVEGENW::MFRQ => 1,
                    WAVEGENW::NPWM => 2,
                    WAVEGENW::DSCRITICAL => 4,
                    WAVEGENW::DSBOTTOM => 5,
                    WAVEGENW::DSBOTH => 6,
                    WAVEGENW::DSTOP => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAVEGENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAVEGENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAVEGENW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn nfrq(self) -> &'a mut W {
                self.variant(WAVEGENW::NFRQ)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn mfrq(self) -> &'a mut W {
                self.variant(WAVEGENW::MFRQ)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn npwm(self) -> &'a mut W {
                self.variant(WAVEGENW::NPWM)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn dscritical(self) -> &'a mut W {
                self.variant(WAVEGENW::DSCRITICAL)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn dsbottom(self) -> &'a mut W {
                self.variant(WAVEGENW::DSBOTTOM)
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn dsboth(self) -> &'a mut W {
                self.variant(WAVEGENW::DSBOTH)
            }
            #[doc = "`111`"]
            #[inline(always)]
            pub fn dstop(self) -> &'a mut W {
                self.variant(WAVEGENW::DSTOP)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RAMP`"]
        pub enum RAMPW {
            #[doc = "`0`"]
            RAMP1,
            #[doc = "`1`"]
            RAMP2A,
            #[doc = "`10`"]
            RAMP2,
        }
        impl RAMPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RAMPW::RAMP1 => 0,
                    RAMPW::RAMP2A => 1,
                    RAMPW::RAMP2 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RAMPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RAMPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RAMPW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn ramp1(self) -> &'a mut W {
                self.variant(RAMPW::RAMP1)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn ramp2a(self) -> &'a mut W {
                self.variant(RAMPW::RAMP2A)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn ramp2(self) -> &'a mut W {
                self.variant(RAMPW::RAMP2)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CIPERENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CIPERENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CICCEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CICCEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CICCEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CICCEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CICCEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CICCEN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CICCEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CICCEN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POL0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POL1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POL1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POL2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POL2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POL3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POL3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWAP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWAP0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWAP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWAP1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWAP2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWAP2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWAP3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWAP3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Waveform Generation"]
            #[inline(always)]
            pub fn wavegen(&self) -> WAVEGENR {
                WAVEGENR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:5 - Ramp Mode"]
            #[inline(always)]
            pub fn ramp(&self) -> RAMPR {
                RAMPR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 7 - Circular period Enable"]
            #[inline(always)]
            pub fn ciperen(&self) -> CIPERENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CIPERENR { bits }
            }
            #[doc = "Bit 8 - Circular Channel 0 Enable"]
            #[inline(always)]
            pub fn ciccen0(&self) -> CICCEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CICCEN0R { bits }
            }
            #[doc = "Bit 9 - Circular Channel 1 Enable"]
            #[inline(always)]
            pub fn ciccen1(&self) -> CICCEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CICCEN1R { bits }
            }
            #[doc = "Bit 10 - Circular Channel 2 Enable"]
            #[inline(always)]
            pub fn ciccen2(&self) -> CICCEN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CICCEN2R { bits }
            }
            #[doc = "Bit 11 - Circular Channel 3 Enable"]
            #[inline(always)]
            pub fn ciccen3(&self) -> CICCEN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CICCEN3R { bits }
            }
            #[doc = "Bit 16 - Channel 0 Polarity"]
            #[inline(always)]
            pub fn pol0(&self) -> POL0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POL0R { bits }
            }
            #[doc = "Bit 17 - Channel 1 Polarity"]
            #[inline(always)]
            pub fn pol1(&self) -> POL1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POL1R { bits }
            }
            #[doc = "Bit 18 - Channel 2 Polarity"]
            #[inline(always)]
            pub fn pol2(&self) -> POL2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POL2R { bits }
            }
            #[doc = "Bit 19 - Channel 3 Polarity"]
            #[inline(always)]
            pub fn pol3(&self) -> POL3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POL3R { bits }
            }
            #[doc = "Bit 24 - Swap DTI Output Pair 0"]
            #[inline(always)]
            pub fn swap0(&self) -> SWAP0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWAP0R { bits }
            }
            #[doc = "Bit 25 - Swap DTI Output Pair 1"]
            #[inline(always)]
            pub fn swap1(&self) -> SWAP1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWAP1R { bits }
            }
            #[doc = "Bit 26 - Swap DTI Output Pair 2"]
            #[inline(always)]
            pub fn swap2(&self) -> SWAP2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWAP2R { bits }
            }
            #[doc = "Bit 27 - Swap DTI Output Pair 3"]
            #[inline(always)]
            pub fn swap3(&self) -> SWAP3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWAP3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Waveform Generation"]
            #[inline(always)]
            pub fn wavegen(&mut self) -> _WAVEGENW {
                _WAVEGENW { w: self }
            }
            #[doc = "Bits 4:5 - Ramp Mode"]
            #[inline(always)]
            pub fn ramp(&mut self) -> _RAMPW {
                _RAMPW { w: self }
            }
            #[doc = "Bit 7 - Circular period Enable"]
            #[inline(always)]
            pub fn ciperen(&mut self) -> _CIPERENW {
                _CIPERENW { w: self }
            }
            #[doc = "Bit 8 - Circular Channel 0 Enable"]
            #[inline(always)]
            pub fn ciccen0(&mut self) -> _CICCEN0W {
                _CICCEN0W { w: self }
            }
            #[doc = "Bit 9 - Circular Channel 1 Enable"]
            #[inline(always)]
            pub fn ciccen1(&mut self) -> _CICCEN1W {
                _CICCEN1W { w: self }
            }
            #[doc = "Bit 10 - Circular Channel 2 Enable"]
            #[inline(always)]
            pub fn ciccen2(&mut self) -> _CICCEN2W {
                _CICCEN2W { w: self }
            }
            #[doc = "Bit 11 - Circular Channel 3 Enable"]
            #[inline(always)]
            pub fn ciccen3(&mut self) -> _CICCEN3W {
                _CICCEN3W { w: self }
            }
            #[doc = "Bit 16 - Channel 0 Polarity"]
            #[inline(always)]
            pub fn pol0(&mut self) -> _POL0W {
                _POL0W { w: self }
            }
            #[doc = "Bit 17 - Channel 1 Polarity"]
            #[inline(always)]
            pub fn pol1(&mut self) -> _POL1W {
                _POL1W { w: self }
            }
            #[doc = "Bit 18 - Channel 2 Polarity"]
            #[inline(always)]
            pub fn pol2(&mut self) -> _POL2W {
                _POL2W { w: self }
            }
            #[doc = "Bit 19 - Channel 3 Polarity"]
            #[inline(always)]
            pub fn pol3(&mut self) -> _POL3W {
                _POL3W { w: self }
            }
            #[doc = "Bit 24 - Swap DTI Output Pair 0"]
            #[inline(always)]
            pub fn swap0(&mut self) -> _SWAP0W {
                _SWAP0W { w: self }
            }
            #[doc = "Bit 25 - Swap DTI Output Pair 1"]
            #[inline(always)]
            pub fn swap1(&mut self) -> _SWAP1W {
                _SWAP1W { w: self }
            }
            #[doc = "Bit 26 - Swap DTI Output Pair 2"]
            #[inline(always)]
            pub fn swap2(&mut self) -> _SWAP2W {
                _SWAP2W { w: self }
            }
            #[doc = "Bit 27 - Swap DTI Output Pair 3"]
            #[inline(always)]
            pub fn swap3(&mut self) -> _SWAP3W {
                _SWAP3W { w: self }
            }
        }
    }
    #[doc = "Waveform Control Buffer"]
    pub struct WAVEB {
        register: VolatileCell<u32>,
    }
    #[doc = "Waveform Control Buffer"]
    pub mod waveb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WAVEB {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WAVEGENB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAVEGENBR {
            #[doc = "undocumented"]
            NFRQ,
            #[doc = "undocumented"]
            MFRQ,
            #[doc = "undocumented"]
            NPWM,
            #[doc = "undocumented"]
            DSCRITICAL,
            #[doc = "undocumented"]
            DSBOTTOM,
            #[doc = "undocumented"]
            DSBOTH,
            #[doc = "undocumented"]
            DSTOP,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl WAVEGENBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    WAVEGENBR::NFRQ => 0,
                    WAVEGENBR::MFRQ => 1,
                    WAVEGENBR::NPWM => 2,
                    WAVEGENBR::DSCRITICAL => 4,
                    WAVEGENBR::DSBOTTOM => 5,
                    WAVEGENBR::DSBOTH => 6,
                    WAVEGENBR::DSTOP => 7,
                    WAVEGENBR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> WAVEGENBR {
                match value {
                    0 => WAVEGENBR::NFRQ,
                    1 => WAVEGENBR::MFRQ,
                    2 => WAVEGENBR::NPWM,
                    4 => WAVEGENBR::DSCRITICAL,
                    5 => WAVEGENBR::DSBOTTOM,
                    6 => WAVEGENBR::DSBOTH,
                    7 => WAVEGENBR::DSTOP,
                    i => WAVEGENBR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NFRQ`"]
            #[inline(always)]
            pub fn is_nfrq(&self) -> bool {
                *self == WAVEGENBR::NFRQ
            }
            #[doc = "Checks if the value of the field is `MFRQ`"]
            #[inline(always)]
            pub fn is_mfrq(&self) -> bool {
                *self == WAVEGENBR::MFRQ
            }
            #[doc = "Checks if the value of the field is `NPWM`"]
            #[inline(always)]
            pub fn is_npwm(&self) -> bool {
                *self == WAVEGENBR::NPWM
            }
            #[doc = "Checks if the value of the field is `DSCRITICAL`"]
            #[inline(always)]
            pub fn is_dscritical(&self) -> bool {
                *self == WAVEGENBR::DSCRITICAL
            }
            #[doc = "Checks if the value of the field is `DSBOTTOM`"]
            #[inline(always)]
            pub fn is_dsbottom(&self) -> bool {
                *self == WAVEGENBR::DSBOTTOM
            }
            #[doc = "Checks if the value of the field is `DSBOTH`"]
            #[inline(always)]
            pub fn is_dsboth(&self) -> bool {
                *self == WAVEGENBR::DSBOTH
            }
            #[doc = "Checks if the value of the field is `DSTOP`"]
            #[inline(always)]
            pub fn is_dstop(&self) -> bool {
                *self == WAVEGENBR::DSTOP
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAMPBR {
            bits: u8,
        }
        impl RAMPBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CIPERENBR {
            bits: bool,
        }
        impl CIPERENBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CICCENB0R {
            bits: bool,
        }
        impl CICCENB0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CICCENB1R {
            bits: bool,
        }
        impl CICCENB1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CICCENB2R {
            bits: bool,
        }
        impl CICCENB2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CICCENB3R {
            bits: bool,
        }
        impl CICCENB3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POLB0R {
            bits: bool,
        }
        impl POLB0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POLB1R {
            bits: bool,
        }
        impl POLB1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POLB2R {
            bits: bool,
        }
        impl POLB2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POLB3R {
            bits: bool,
        }
        impl POLB3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWAPB0R {
            bits: bool,
        }
        impl SWAPB0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWAPB1R {
            bits: bool,
        }
        impl SWAPB1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWAPB2R {
            bits: bool,
        }
        impl SWAPB2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWAPB3R {
            bits: bool,
        }
        impl SWAPB3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `WAVEGENB`"]
        pub enum WAVEGENBW {
            #[doc = "`0`"]
            NFRQ,
            #[doc = "`1`"]
            MFRQ,
            #[doc = "`10`"]
            NPWM,
            #[doc = "`100`"]
            DSCRITICAL,
            #[doc = "`101`"]
            DSBOTTOM,
            #[doc = "`110`"]
            DSBOTH,
            #[doc = "`111`"]
            DSTOP,
        }
        impl WAVEGENBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WAVEGENBW::NFRQ => 0,
                    WAVEGENBW::MFRQ => 1,
                    WAVEGENBW::NPWM => 2,
                    WAVEGENBW::DSCRITICAL => 4,
                    WAVEGENBW::DSBOTTOM => 5,
                    WAVEGENBW::DSBOTH => 6,
                    WAVEGENBW::DSTOP => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAVEGENBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAVEGENBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAVEGENBW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn nfrq(self) -> &'a mut W {
                self.variant(WAVEGENBW::NFRQ)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn mfrq(self) -> &'a mut W {
                self.variant(WAVEGENBW::MFRQ)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn npwm(self) -> &'a mut W {
                self.variant(WAVEGENBW::NPWM)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn dscritical(self) -> &'a mut W {
                self.variant(WAVEGENBW::DSCRITICAL)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn dsbottom(self) -> &'a mut W {
                self.variant(WAVEGENBW::DSBOTTOM)
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn dsboth(self) -> &'a mut W {
                self.variant(WAVEGENBW::DSBOTH)
            }
            #[doc = "`111`"]
            #[inline(always)]
            pub fn dstop(self) -> &'a mut W {
                self.variant(WAVEGENBW::DSTOP)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RAMPBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RAMPBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CIPERENBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CIPERENBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CICCENB0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CICCENB0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CICCENB1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CICCENB1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CICCENB2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CICCENB2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CICCENB3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CICCENB3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POLB0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POLB0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POLB1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POLB1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POLB2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POLB2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POLB3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POLB3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWAPB0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWAPB0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWAPB1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWAPB1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWAPB2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWAPB2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWAPB3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWAPB3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Waveform Generation Buffer"]
            #[inline(always)]
            pub fn wavegenb(&self) -> WAVEGENBR {
                WAVEGENBR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:5 - Ramp Mode Buffer"]
            #[inline(always)]
            pub fn rampb(&self) -> RAMPBR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RAMPBR { bits }
            }
            #[doc = "Bit 7 - Circular Period Enable Buffer"]
            #[inline(always)]
            pub fn ciperenb(&self) -> CIPERENBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CIPERENBR { bits }
            }
            #[doc = "Bit 8 - Circular Channel 0 Enable Buffer"]
            #[inline(always)]
            pub fn ciccenb0(&self) -> CICCENB0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CICCENB0R { bits }
            }
            #[doc = "Bit 9 - Circular Channel 1 Enable Buffer"]
            #[inline(always)]
            pub fn ciccenb1(&self) -> CICCENB1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CICCENB1R { bits }
            }
            #[doc = "Bit 10 - Circular Channel 2 Enable Buffer"]
            #[inline(always)]
            pub fn ciccenb2(&self) -> CICCENB2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CICCENB2R { bits }
            }
            #[doc = "Bit 11 - Circular Channel 3 Enable Buffer"]
            #[inline(always)]
            pub fn ciccenb3(&self) -> CICCENB3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CICCENB3R { bits }
            }
            #[doc = "Bit 16 - Channel 0 Polarity Buffer"]
            #[inline(always)]
            pub fn polb0(&self) -> POLB0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POLB0R { bits }
            }
            #[doc = "Bit 17 - Channel 1 Polarity Buffer"]
            #[inline(always)]
            pub fn polb1(&self) -> POLB1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POLB1R { bits }
            }
            #[doc = "Bit 18 - Channel 2 Polarity Buffer"]
            #[inline(always)]
            pub fn polb2(&self) -> POLB2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POLB2R { bits }
            }
            #[doc = "Bit 19 - Channel 3 Polarity Buffer"]
            #[inline(always)]
            pub fn polb3(&self) -> POLB3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POLB3R { bits }
            }
            #[doc = "Bit 24 - Swap DTI Output Pair 0 Buffer"]
            #[inline(always)]
            pub fn swapb0(&self) -> SWAPB0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWAPB0R { bits }
            }
            #[doc = "Bit 25 - Swap DTI Output Pair 1 Buffer"]
            #[inline(always)]
            pub fn swapb1(&self) -> SWAPB1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWAPB1R { bits }
            }
            #[doc = "Bit 26 - Swap DTI Output Pair 2 Buffer"]
            #[inline(always)]
            pub fn swapb2(&self) -> SWAPB2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWAPB2R { bits }
            }
            #[doc = "Bit 27 - Swap DTI Output Pair 3 Buffer"]
            #[inline(always)]
            pub fn swapb3(&self) -> SWAPB3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWAPB3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Waveform Generation Buffer"]
            #[inline(always)]
            pub fn wavegenb(&mut self) -> _WAVEGENBW {
                _WAVEGENBW { w: self }
            }
            #[doc = "Bits 4:5 - Ramp Mode Buffer"]
            #[inline(always)]
            pub fn rampb(&mut self) -> _RAMPBW {
                _RAMPBW { w: self }
            }
            #[doc = "Bit 7 - Circular Period Enable Buffer"]
            #[inline(always)]
            pub fn ciperenb(&mut self) -> _CIPERENBW {
                _CIPERENBW { w: self }
            }
            #[doc = "Bit 8 - Circular Channel 0 Enable Buffer"]
            #[inline(always)]
            pub fn ciccenb0(&mut self) -> _CICCENB0W {
                _CICCENB0W { w: self }
            }
            #[doc = "Bit 9 - Circular Channel 1 Enable Buffer"]
            #[inline(always)]
            pub fn ciccenb1(&mut self) -> _CICCENB1W {
                _CICCENB1W { w: self }
            }
            #[doc = "Bit 10 - Circular Channel 2 Enable Buffer"]
            #[inline(always)]
            pub fn ciccenb2(&mut self) -> _CICCENB2W {
                _CICCENB2W { w: self }
            }
            #[doc = "Bit 11 - Circular Channel 3 Enable Buffer"]
            #[inline(always)]
            pub fn ciccenb3(&mut self) -> _CICCENB3W {
                _CICCENB3W { w: self }
            }
            #[doc = "Bit 16 - Channel 0 Polarity Buffer"]
            #[inline(always)]
            pub fn polb0(&mut self) -> _POLB0W {
                _POLB0W { w: self }
            }
            #[doc = "Bit 17 - Channel 1 Polarity Buffer"]
            #[inline(always)]
            pub fn polb1(&mut self) -> _POLB1W {
                _POLB1W { w: self }
            }
            #[doc = "Bit 18 - Channel 2 Polarity Buffer"]
            #[inline(always)]
            pub fn polb2(&mut self) -> _POLB2W {
                _POLB2W { w: self }
            }
            #[doc = "Bit 19 - Channel 3 Polarity Buffer"]
            #[inline(always)]
            pub fn polb3(&mut self) -> _POLB3W {
                _POLB3W { w: self }
            }
            #[doc = "Bit 24 - Swap DTI Output Pair 0 Buffer"]
            #[inline(always)]
            pub fn swapb0(&mut self) -> _SWAPB0W {
                _SWAPB0W { w: self }
            }
            #[doc = "Bit 25 - Swap DTI Output Pair 1 Buffer"]
            #[inline(always)]
            pub fn swapb1(&mut self) -> _SWAPB1W {
                _SWAPB1W { w: self }
            }
            #[doc = "Bit 26 - Swap DTI Output Pair 2 Buffer"]
            #[inline(always)]
            pub fn swapb2(&mut self) -> _SWAPB2W {
                _SWAPB2W { w: self }
            }
            #[doc = "Bit 27 - Swap DTI Output Pair 3 Buffer"]
            #[inline(always)]
            pub fn swapb3(&mut self) -> _SWAPB3W {
                _SWAPB3W { w: self }
            }
        }
    }
    #[doc = "Waveform Extension Configuration"]
    pub struct WEXCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Waveform Extension Configuration"]
    pub mod wexctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WEXCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OTMXR {
            bits: u8,
        }
        impl OTMXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DTIEN0R {
            bits: bool,
        }
        impl DTIEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DTIEN1R {
            bits: bool,
        }
        impl DTIEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DTIEN2R {
            bits: bool,
        }
        impl DTIEN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DTIEN3R {
            bits: bool,
        }
        impl DTIEN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DTLSR {
            bits: u8,
        }
        impl DTLSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DTHSR {
            bits: u8,
        }
        impl DTHSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OTMXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OTMXW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DTIEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DTIEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DTIEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DTIEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DTIEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DTIEN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DTIEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DTIEN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DTLSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DTLSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DTHSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DTHSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Output Matrix"]
            #[inline(always)]
            pub fn otmx(&self) -> OTMXR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OTMXR { bits }
            }
            #[doc = "Bit 8 - Dead-time Insertion Generator 0 Enable"]
            #[inline(always)]
            pub fn dtien0(&self) -> DTIEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DTIEN0R { bits }
            }
            #[doc = "Bit 9 - Dead-time Insertion Generator 1 Enable"]
            #[inline(always)]
            pub fn dtien1(&self) -> DTIEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DTIEN1R { bits }
            }
            #[doc = "Bit 10 - Dead-time Insertion Generator 2 Enable"]
            #[inline(always)]
            pub fn dtien2(&self) -> DTIEN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DTIEN2R { bits }
            }
            #[doc = "Bit 11 - Dead-time Insertion Generator 3 Enable"]
            #[inline(always)]
            pub fn dtien3(&self) -> DTIEN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DTIEN3R { bits }
            }
            #[doc = "Bits 16:23 - Dead-time Low Side Outputs Value"]
            #[inline(always)]
            pub fn dtls(&self) -> DTLSR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DTLSR { bits }
            }
            #[doc = "Bits 24:31 - Dead-time High Side Outputs Value"]
            #[inline(always)]
            pub fn dths(&self) -> DTHSR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DTHSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Output Matrix"]
            #[inline(always)]
            pub fn otmx(&mut self) -> _OTMXW {
                _OTMXW { w: self }
            }
            #[doc = "Bit 8 - Dead-time Insertion Generator 0 Enable"]
            #[inline(always)]
            pub fn dtien0(&mut self) -> _DTIEN0W {
                _DTIEN0W { w: self }
            }
            #[doc = "Bit 9 - Dead-time Insertion Generator 1 Enable"]
            #[inline(always)]
            pub fn dtien1(&mut self) -> _DTIEN1W {
                _DTIEN1W { w: self }
            }
            #[doc = "Bit 10 - Dead-time Insertion Generator 2 Enable"]
            #[inline(always)]
            pub fn dtien2(&mut self) -> _DTIEN2W {
                _DTIEN2W { w: self }
            }
            #[doc = "Bit 11 - Dead-time Insertion Generator 3 Enable"]
            #[inline(always)]
            pub fn dtien3(&mut self) -> _DTIEN3W {
                _DTIEN3W { w: self }
            }
            #[doc = "Bits 16:23 - Dead-time Low Side Outputs Value"]
            #[inline(always)]
            pub fn dtls(&mut self) -> _DTLSW {
                _DTLSW { w: self }
            }
            #[doc = "Bits 24:31 - Dead-time High Side Outputs Value"]
            #[inline(always)]
            pub fn dths(&mut self) -> _DTHSW {
                _DTHSW { w: self }
            }
        }
    }
}
#[doc = "Timer Counter Control 0"]
pub struct TCC0 {
    register_block: tcc0::RegisterBlock,
}
impl Deref for TCC0 {
    type Target = tcc0::RegisterBlock;
    fn deref(&self) -> &tcc0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Timer Counter Control 1"]
pub const TCC1: Peripheral<TCC1> = unsafe { Peripheral::new(1107305472) };
#[doc = r" Register block"]
pub struct TCC1 {
    register_block: tcc0::RegisterBlock,
}
impl Deref for TCC1 {
    type Target = tcc0::RegisterBlock;
    fn deref(&self) -> &tcc0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Timer Counter Control 2"]
pub const TCC2: Peripheral<TCC2> = unsafe { Peripheral::new(1107306496) };
#[doc = r" Register block"]
pub struct TCC2 {
    register_block: tcc0::RegisterBlock,
}
impl Deref for TCC2 {
    type Target = tcc0::RegisterBlock;
    fn deref(&self) -> &tcc0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Watchdog Timer"]
pub const WDT: Peripheral<WDT> = unsafe { Peripheral::new(1073745920) };
#[doc = "Watchdog Timer"]
pub mod wdt {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctrl: CTRL,
        #[doc = "0x01 - Configuration"]
        pub config: CONFIG,
        #[doc = "0x02 - Early Warning Interrupt Control"]
        pub ewctrl: EWCTRL,
        _reserved0: [u8; 1usize],
        #[doc = "0x04 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x05 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x06 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        #[doc = "0x07 - Status"]
        pub status: STATUS,
        #[doc = "0x08 - Clear"]
        pub clear: CLEAR,
    }
    #[doc = "Clear"]
    pub struct CLEAR {
        register: VolatileCell<u8>,
    }
    #[doc = "Clear"]
    pub mod clear {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CLEAR {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `CLEAR`"]
        pub enum CLEARW {
            #[doc = "Clear Key"]
            KEY,
        }
        impl CLEARW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLEARW::KEY => 165,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLEARW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLEARW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLEARW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Clear Key"]
            #[inline(always)]
            pub fn key(self) -> &'a mut W {
                self.variant(CLEARW::KEY)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Watchdog Clear"]
            #[inline(always)]
            pub fn clear(&mut self) -> _CLEARW {
                _CLEARW { w: self }
            }
        }
    }
    #[doc = "Configuration"]
    pub struct CONFIG {
        register: VolatileCell<u8>,
    }
    #[doc = "Configuration"]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PERR {
            #[doc = "8 clock cycles"]
            _0X0,
            #[doc = "16 clock cycles"]
            _0X1,
            #[doc = "32 clock cycles"]
            _0X2,
            #[doc = "64 clock cycles"]
            _0X3,
            #[doc = "128 clock cycles"]
            _0X4,
            #[doc = "256 clock cycles"]
            _0X5,
            #[doc = "512 clock cycles"]
            _0X6,
            #[doc = "1024 clock cycles"]
            _0X7,
            #[doc = "2048 clock cycles"]
            _0X8,
            #[doc = "4096 clock cycles"]
            _0X9,
            #[doc = "8192 clock cycles"]
            _0XA,
            #[doc = "16384 clock cycles"]
            _0XB,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    PERR::_0X0 => 0,
                    PERR::_0X1 => 1,
                    PERR::_0X2 => 2,
                    PERR::_0X3 => 3,
                    PERR::_0X4 => 4,
                    PERR::_0X5 => 5,
                    PERR::_0X6 => 6,
                    PERR::_0X7 => 7,
                    PERR::_0X8 => 8,
                    PERR::_0X9 => 9,
                    PERR::_0XA => 10,
                    PERR::_0XB => 11,
                    PERR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> PERR {
                match value {
                    0 => PERR::_0X0,
                    1 => PERR::_0X1,
                    2 => PERR::_0X2,
                    3 => PERR::_0X3,
                    4 => PERR::_0X4,
                    5 => PERR::_0X5,
                    6 => PERR::_0X6,
                    7 => PERR::_0X7,
                    8 => PERR::_0X8,
                    9 => PERR::_0X9,
                    10 => PERR::_0XA,
                    11 => PERR::_0XB,
                    i => PERR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_0X0`"]
            #[inline(always)]
            pub fn is_0x0(&self) -> bool {
                *self == PERR::_0X0
            }
            #[doc = "Checks if the value of the field is `_0X1`"]
            #[inline(always)]
            pub fn is_0x1(&self) -> bool {
                *self == PERR::_0X1
            }
            #[doc = "Checks if the value of the field is `_0X2`"]
            #[inline(always)]
            pub fn is_0x2(&self) -> bool {
                *self == PERR::_0X2
            }
            #[doc = "Checks if the value of the field is `_0X3`"]
            #[inline(always)]
            pub fn is_0x3(&self) -> bool {
                *self == PERR::_0X3
            }
            #[doc = "Checks if the value of the field is `_0X4`"]
            #[inline(always)]
            pub fn is_0x4(&self) -> bool {
                *self == PERR::_0X4
            }
            #[doc = "Checks if the value of the field is `_0X5`"]
            #[inline(always)]
            pub fn is_0x5(&self) -> bool {
                *self == PERR::_0X5
            }
            #[doc = "Checks if the value of the field is `_0X6`"]
            #[inline(always)]
            pub fn is_0x6(&self) -> bool {
                *self == PERR::_0X6
            }
            #[doc = "Checks if the value of the field is `_0X7`"]
            #[inline(always)]
            pub fn is_0x7(&self) -> bool {
                *self == PERR::_0X7
            }
            #[doc = "Checks if the value of the field is `_0X8`"]
            #[inline(always)]
            pub fn is_0x8(&self) -> bool {
                *self == PERR::_0X8
            }
            #[doc = "Checks if the value of the field is `_0X9`"]
            #[inline(always)]
            pub fn is_0x9(&self) -> bool {
                *self == PERR::_0X9
            }
            #[doc = "Checks if the value of the field is `_0XA`"]
            #[inline(always)]
            pub fn is_0x_a(&self) -> bool {
                *self == PERR::_0XA
            }
            #[doc = "Checks if the value of the field is `_0XB`"]
            #[inline(always)]
            pub fn is_0x_b(&self) -> bool {
                *self == PERR::_0XB
            }
        }
        #[doc = "Possible values of the field `WINDOW`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WINDOWR {
            #[doc = "8 clock cycles"]
            _0X0,
            #[doc = "16 clock cycles"]
            _0X1,
            #[doc = "32 clock cycles"]
            _0X2,
            #[doc = "64 clock cycles"]
            _0X3,
            #[doc = "128 clock cycles"]
            _0X4,
            #[doc = "256 clock cycles"]
            _0X5,
            #[doc = "512 clock cycles"]
            _0X6,
            #[doc = "1024 clock cycles"]
            _0X7,
            #[doc = "2048 clock cycles"]
            _0X8,
            #[doc = "4096 clock cycles"]
            _0X9,
            #[doc = "8192 clock cycles"]
            _0XA,
            #[doc = "16384 clock cycles"]
            _0XB,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl WINDOWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    WINDOWR::_0X0 => 0,
                    WINDOWR::_0X1 => 1,
                    WINDOWR::_0X2 => 2,
                    WINDOWR::_0X3 => 3,
                    WINDOWR::_0X4 => 4,
                    WINDOWR::_0X5 => 5,
                    WINDOWR::_0X6 => 6,
                    WINDOWR::_0X7 => 7,
                    WINDOWR::_0X8 => 8,
                    WINDOWR::_0X9 => 9,
                    WINDOWR::_0XA => 10,
                    WINDOWR::_0XB => 11,
                    WINDOWR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> WINDOWR {
                match value {
                    0 => WINDOWR::_0X0,
                    1 => WINDOWR::_0X1,
                    2 => WINDOWR::_0X2,
                    3 => WINDOWR::_0X3,
                    4 => WINDOWR::_0X4,
                    5 => WINDOWR::_0X5,
                    6 => WINDOWR::_0X6,
                    7 => WINDOWR::_0X7,
                    8 => WINDOWR::_0X8,
                    9 => WINDOWR::_0X9,
                    10 => WINDOWR::_0XA,
                    11 => WINDOWR::_0XB,
                    i => WINDOWR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_0X0`"]
            #[inline(always)]
            pub fn is_0x0(&self) -> bool {
                *self == WINDOWR::_0X0
            }
            #[doc = "Checks if the value of the field is `_0X1`"]
            #[inline(always)]
            pub fn is_0x1(&self) -> bool {
                *self == WINDOWR::_0X1
            }
            #[doc = "Checks if the value of the field is `_0X2`"]
            #[inline(always)]
            pub fn is_0x2(&self) -> bool {
                *self == WINDOWR::_0X2
            }
            #[doc = "Checks if the value of the field is `_0X3`"]
            #[inline(always)]
            pub fn is_0x3(&self) -> bool {
                *self == WINDOWR::_0X3
            }
            #[doc = "Checks if the value of the field is `_0X4`"]
            #[inline(always)]
            pub fn is_0x4(&self) -> bool {
                *self == WINDOWR::_0X4
            }
            #[doc = "Checks if the value of the field is `_0X5`"]
            #[inline(always)]
            pub fn is_0x5(&self) -> bool {
                *self == WINDOWR::_0X5
            }
            #[doc = "Checks if the value of the field is `_0X6`"]
            #[inline(always)]
            pub fn is_0x6(&self) -> bool {
                *self == WINDOWR::_0X6
            }
            #[doc = "Checks if the value of the field is `_0X7`"]
            #[inline(always)]
            pub fn is_0x7(&self) -> bool {
                *self == WINDOWR::_0X7
            }
            #[doc = "Checks if the value of the field is `_0X8`"]
            #[inline(always)]
            pub fn is_0x8(&self) -> bool {
                *self == WINDOWR::_0X8
            }
            #[doc = "Checks if the value of the field is `_0X9`"]
            #[inline(always)]
            pub fn is_0x9(&self) -> bool {
                *self == WINDOWR::_0X9
            }
            #[doc = "Checks if the value of the field is `_0XA`"]
            #[inline(always)]
            pub fn is_0x_a(&self) -> bool {
                *self == WINDOWR::_0XA
            }
            #[doc = "Checks if the value of the field is `_0XB`"]
            #[inline(always)]
            pub fn is_0x_b(&self) -> bool {
                *self == WINDOWR::_0XB
            }
        }
        #[doc = "Values that can be written to the field `PER`"]
        pub enum PERW {
            #[doc = "8 clock cycles"]
            _0X0,
            #[doc = "16 clock cycles"]
            _0X1,
            #[doc = "32 clock cycles"]
            _0X2,
            #[doc = "64 clock cycles"]
            _0X3,
            #[doc = "128 clock cycles"]
            _0X4,
            #[doc = "256 clock cycles"]
            _0X5,
            #[doc = "512 clock cycles"]
            _0X6,
            #[doc = "1024 clock cycles"]
            _0X7,
            #[doc = "2048 clock cycles"]
            _0X8,
            #[doc = "4096 clock cycles"]
            _0X9,
            #[doc = "8192 clock cycles"]
            _0XA,
            #[doc = "16384 clock cycles"]
            _0XB,
        }
        impl PERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PERW::_0X0 => 0,
                    PERW::_0X1 => 1,
                    PERW::_0X2 => 2,
                    PERW::_0X3 => 3,
                    PERW::_0X4 => 4,
                    PERW::_0X5 => 5,
                    PERW::_0X6 => 6,
                    PERW::_0X7 => 7,
                    PERW::_0X8 => 8,
                    PERW::_0X9 => 9,
                    PERW::_0XA => 10,
                    PERW::_0XB => 11,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PERW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "8 clock cycles"]
            #[inline(always)]
            pub fn _0x0(self) -> &'a mut W {
                self.variant(PERW::_0X0)
            }
            #[doc = "16 clock cycles"]
            #[inline(always)]
            pub fn _0x1(self) -> &'a mut W {
                self.variant(PERW::_0X1)
            }
            #[doc = "32 clock cycles"]
            #[inline(always)]
            pub fn _0x2(self) -> &'a mut W {
                self.variant(PERW::_0X2)
            }
            #[doc = "64 clock cycles"]
            #[inline(always)]
            pub fn _0x3(self) -> &'a mut W {
                self.variant(PERW::_0X3)
            }
            #[doc = "128 clock cycles"]
            #[inline(always)]
            pub fn _0x4(self) -> &'a mut W {
                self.variant(PERW::_0X4)
            }
            #[doc = "256 clock cycles"]
            #[inline(always)]
            pub fn _0x5(self) -> &'a mut W {
                self.variant(PERW::_0X5)
            }
            #[doc = "512 clock cycles"]
            #[inline(always)]
            pub fn _0x6(self) -> &'a mut W {
                self.variant(PERW::_0X6)
            }
            #[doc = "1024 clock cycles"]
            #[inline(always)]
            pub fn _0x7(self) -> &'a mut W {
                self.variant(PERW::_0X7)
            }
            #[doc = "2048 clock cycles"]
            #[inline(always)]
            pub fn _0x8(self) -> &'a mut W {
                self.variant(PERW::_0X8)
            }
            #[doc = "4096 clock cycles"]
            #[inline(always)]
            pub fn _0x9(self) -> &'a mut W {
                self.variant(PERW::_0X9)
            }
            #[doc = "8192 clock cycles"]
            #[inline(always)]
            pub fn _0x_a(self) -> &'a mut W {
                self.variant(PERW::_0XA)
            }
            #[doc = "16384 clock cycles"]
            #[inline(always)]
            pub fn _0x_b(self) -> &'a mut W {
                self.variant(PERW::_0XB)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WINDOW`"]
        pub enum WINDOWW {
            #[doc = "8 clock cycles"]
            _0X0,
            #[doc = "16 clock cycles"]
            _0X1,
            #[doc = "32 clock cycles"]
            _0X2,
            #[doc = "64 clock cycles"]
            _0X3,
            #[doc = "128 clock cycles"]
            _0X4,
            #[doc = "256 clock cycles"]
            _0X5,
            #[doc = "512 clock cycles"]
            _0X6,
            #[doc = "1024 clock cycles"]
            _0X7,
            #[doc = "2048 clock cycles"]
            _0X8,
            #[doc = "4096 clock cycles"]
            _0X9,
            #[doc = "8192 clock cycles"]
            _0XA,
            #[doc = "16384 clock cycles"]
            _0XB,
        }
        impl WINDOWW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WINDOWW::_0X0 => 0,
                    WINDOWW::_0X1 => 1,
                    WINDOWW::_0X2 => 2,
                    WINDOWW::_0X3 => 3,
                    WINDOWW::_0X4 => 4,
                    WINDOWW::_0X5 => 5,
                    WINDOWW::_0X6 => 6,
                    WINDOWW::_0X7 => 7,
                    WINDOWW::_0X8 => 8,
                    WINDOWW::_0X9 => 9,
                    WINDOWW::_0XA => 10,
                    WINDOWW::_0XB => 11,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINDOWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINDOWW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WINDOWW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "8 clock cycles"]
            #[inline(always)]
            pub fn _0x0(self) -> &'a mut W {
                self.variant(WINDOWW::_0X0)
            }
            #[doc = "16 clock cycles"]
            #[inline(always)]
            pub fn _0x1(self) -> &'a mut W {
                self.variant(WINDOWW::_0X1)
            }
            #[doc = "32 clock cycles"]
            #[inline(always)]
            pub fn _0x2(self) -> &'a mut W {
                self.variant(WINDOWW::_0X2)
            }
            #[doc = "64 clock cycles"]
            #[inline(always)]
            pub fn _0x3(self) -> &'a mut W {
                self.variant(WINDOWW::_0X3)
            }
            #[doc = "128 clock cycles"]
            #[inline(always)]
            pub fn _0x4(self) -> &'a mut W {
                self.variant(WINDOWW::_0X4)
            }
            #[doc = "256 clock cycles"]
            #[inline(always)]
            pub fn _0x5(self) -> &'a mut W {
                self.variant(WINDOWW::_0X5)
            }
            #[doc = "512 clock cycles"]
            #[inline(always)]
            pub fn _0x6(self) -> &'a mut W {
                self.variant(WINDOWW::_0X6)
            }
            #[doc = "1024 clock cycles"]
            #[inline(always)]
            pub fn _0x7(self) -> &'a mut W {
                self.variant(WINDOWW::_0X7)
            }
            #[doc = "2048 clock cycles"]
            #[inline(always)]
            pub fn _0x8(self) -> &'a mut W {
                self.variant(WINDOWW::_0X8)
            }
            #[doc = "4096 clock cycles"]
            #[inline(always)]
            pub fn _0x9(self) -> &'a mut W {
                self.variant(WINDOWW::_0X9)
            }
            #[doc = "8192 clock cycles"]
            #[inline(always)]
            pub fn _0x_a(self) -> &'a mut W {
                self.variant(WINDOWW::_0XA)
            }
            #[doc = "16384 clock cycles"]
            #[inline(always)]
            pub fn _0x_b(self) -> &'a mut W {
                self.variant(WINDOWW::_0XB)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:3 - Time-Out Period"]
            #[inline(always)]
            pub fn per(&self) -> PERR {
                PERR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bits 4:7 - Window Mode Time-Out Period"]
            #[inline(always)]
            pub fn window(&self) -> WINDOWR {
                WINDOWR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 187 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Time-Out Period"]
            #[inline(always)]
            pub fn per(&mut self) -> _PERW {
                _PERW { w: self }
            }
            #[doc = "Bits 4:7 - Window Mode Time-Out Period"]
            #[inline(always)]
            pub fn window(&mut self) -> _WINDOWW {
                _WINDOWW { w: self }
            }
        }
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WENR {
            bits: bool,
        }
        impl WENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ALWAYSONR {
            bits: bool,
        }
        impl ALWAYSONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALWAYSONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALWAYSONW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Watchdog Timer Window Mode Enable"]
            #[inline(always)]
            pub fn wen(&self) -> WENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WENR { bits }
            }
            #[doc = "Bit 7 - Always-On"]
            #[inline(always)]
            pub fn alwayson(&self) -> ALWAYSONR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ALWAYSONR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Watchdog Timer Window Mode Enable"]
            #[inline(always)]
            pub fn wen(&mut self) -> _WENW {
                _WENW { w: self }
            }
            #[doc = "Bit 7 - Always-On"]
            #[inline(always)]
            pub fn alwayson(&mut self) -> _ALWAYSONW {
                _ALWAYSONW { w: self }
            }
        }
    }
    #[doc = "Early Warning Interrupt Control"]
    pub struct EWCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Early Warning Interrupt Control"]
    pub mod ewctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::EWCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `EWOFFSET`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWOFFSETR {
            #[doc = "8 clock cycles"]
            _0X0,
            #[doc = "16 clock cycles"]
            _0X1,
            #[doc = "32 clock cycles"]
            _0X2,
            #[doc = "64 clock cycles"]
            _0X3,
            #[doc = "128 clock cycles"]
            _0X4,
            #[doc = "256 clock cycles"]
            _0X5,
            #[doc = "512 clock cycles"]
            _0X6,
            #[doc = "1024 clock cycles"]
            _0X7,
            #[doc = "2048 clock cycles"]
            _0X8,
            #[doc = "4096 clock cycles"]
            _0X9,
            #[doc = "8192 clock cycles"]
            _0XA,
            #[doc = "16384 clock cycles"]
            _0XB,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl EWOFFSETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    EWOFFSETR::_0X0 => 0,
                    EWOFFSETR::_0X1 => 1,
                    EWOFFSETR::_0X2 => 2,
                    EWOFFSETR::_0X3 => 3,
                    EWOFFSETR::_0X4 => 4,
                    EWOFFSETR::_0X5 => 5,
                    EWOFFSETR::_0X6 => 6,
                    EWOFFSETR::_0X7 => 7,
                    EWOFFSETR::_0X8 => 8,
                    EWOFFSETR::_0X9 => 9,
                    EWOFFSETR::_0XA => 10,
                    EWOFFSETR::_0XB => 11,
                    EWOFFSETR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> EWOFFSETR {
                match value {
                    0 => EWOFFSETR::_0X0,
                    1 => EWOFFSETR::_0X1,
                    2 => EWOFFSETR::_0X2,
                    3 => EWOFFSETR::_0X3,
                    4 => EWOFFSETR::_0X4,
                    5 => EWOFFSETR::_0X5,
                    6 => EWOFFSETR::_0X6,
                    7 => EWOFFSETR::_0X7,
                    8 => EWOFFSETR::_0X8,
                    9 => EWOFFSETR::_0X9,
                    10 => EWOFFSETR::_0XA,
                    11 => EWOFFSETR::_0XB,
                    i => EWOFFSETR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_0X0`"]
            #[inline(always)]
            pub fn is_0x0(&self) -> bool {
                *self == EWOFFSETR::_0X0
            }
            #[doc = "Checks if the value of the field is `_0X1`"]
            #[inline(always)]
            pub fn is_0x1(&self) -> bool {
                *self == EWOFFSETR::_0X1
            }
            #[doc = "Checks if the value of the field is `_0X2`"]
            #[inline(always)]
            pub fn is_0x2(&self) -> bool {
                *self == EWOFFSETR::_0X2
            }
            #[doc = "Checks if the value of the field is `_0X3`"]
            #[inline(always)]
            pub fn is_0x3(&self) -> bool {
                *self == EWOFFSETR::_0X3
            }
            #[doc = "Checks if the value of the field is `_0X4`"]
            #[inline(always)]
            pub fn is_0x4(&self) -> bool {
                *self == EWOFFSETR::_0X4
            }
            #[doc = "Checks if the value of the field is `_0X5`"]
            #[inline(always)]
            pub fn is_0x5(&self) -> bool {
                *self == EWOFFSETR::_0X5
            }
            #[doc = "Checks if the value of the field is `_0X6`"]
            #[inline(always)]
            pub fn is_0x6(&self) -> bool {
                *self == EWOFFSETR::_0X6
            }
            #[doc = "Checks if the value of the field is `_0X7`"]
            #[inline(always)]
            pub fn is_0x7(&self) -> bool {
                *self == EWOFFSETR::_0X7
            }
            #[doc = "Checks if the value of the field is `_0X8`"]
            #[inline(always)]
            pub fn is_0x8(&self) -> bool {
                *self == EWOFFSETR::_0X8
            }
            #[doc = "Checks if the value of the field is `_0X9`"]
            #[inline(always)]
            pub fn is_0x9(&self) -> bool {
                *self == EWOFFSETR::_0X9
            }
            #[doc = "Checks if the value of the field is `_0XA`"]
            #[inline(always)]
            pub fn is_0x_a(&self) -> bool {
                *self == EWOFFSETR::_0XA
            }
            #[doc = "Checks if the value of the field is `_0XB`"]
            #[inline(always)]
            pub fn is_0x_b(&self) -> bool {
                *self == EWOFFSETR::_0XB
            }
        }
        #[doc = "Values that can be written to the field `EWOFFSET`"]
        pub enum EWOFFSETW {
            #[doc = "8 clock cycles"]
            _0X0,
            #[doc = "16 clock cycles"]
            _0X1,
            #[doc = "32 clock cycles"]
            _0X2,
            #[doc = "64 clock cycles"]
            _0X3,
            #[doc = "128 clock cycles"]
            _0X4,
            #[doc = "256 clock cycles"]
            _0X5,
            #[doc = "512 clock cycles"]
            _0X6,
            #[doc = "1024 clock cycles"]
            _0X7,
            #[doc = "2048 clock cycles"]
            _0X8,
            #[doc = "4096 clock cycles"]
            _0X9,
            #[doc = "8192 clock cycles"]
            _0XA,
            #[doc = "16384 clock cycles"]
            _0XB,
        }
        impl EWOFFSETW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EWOFFSETW::_0X0 => 0,
                    EWOFFSETW::_0X1 => 1,
                    EWOFFSETW::_0X2 => 2,
                    EWOFFSETW::_0X3 => 3,
                    EWOFFSETW::_0X4 => 4,
                    EWOFFSETW::_0X5 => 5,
                    EWOFFSETW::_0X6 => 6,
                    EWOFFSETW::_0X7 => 7,
                    EWOFFSETW::_0X8 => 8,
                    EWOFFSETW::_0X9 => 9,
                    EWOFFSETW::_0XA => 10,
                    EWOFFSETW::_0XB => 11,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EWOFFSETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EWOFFSETW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EWOFFSETW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "8 clock cycles"]
            #[inline(always)]
            pub fn _0x0(self) -> &'a mut W {
                self.variant(EWOFFSETW::_0X0)
            }
            #[doc = "16 clock cycles"]
            #[inline(always)]
            pub fn _0x1(self) -> &'a mut W {
                self.variant(EWOFFSETW::_0X1)
            }
            #[doc = "32 clock cycles"]
            #[inline(always)]
            pub fn _0x2(self) -> &'a mut W {
                self.variant(EWOFFSETW::_0X2)
            }
            #[doc = "64 clock cycles"]
            #[inline(always)]
            pub fn _0x3(self) -> &'a mut W {
                self.variant(EWOFFSETW::_0X3)
            }
            #[doc = "128 clock cycles"]
            #[inline(always)]
            pub fn _0x4(self) -> &'a mut W {
                self.variant(EWOFFSETW::_0X4)
            }
            #[doc = "256 clock cycles"]
            #[inline(always)]
            pub fn _0x5(self) -> &'a mut W {
                self.variant(EWOFFSETW::_0X5)
            }
            #[doc = "512 clock cycles"]
            #[inline(always)]
            pub fn _0x6(self) -> &'a mut W {
                self.variant(EWOFFSETW::_0X6)
            }
            #[doc = "1024 clock cycles"]
            #[inline(always)]
            pub fn _0x7(self) -> &'a mut W {
                self.variant(EWOFFSETW::_0X7)
            }
            #[doc = "2048 clock cycles"]
            #[inline(always)]
            pub fn _0x8(self) -> &'a mut W {
                self.variant(EWOFFSETW::_0X8)
            }
            #[doc = "4096 clock cycles"]
            #[inline(always)]
            pub fn _0x9(self) -> &'a mut W {
                self.variant(EWOFFSETW::_0X9)
            }
            #[doc = "8192 clock cycles"]
            #[inline(always)]
            pub fn _0x_a(self) -> &'a mut W {
                self.variant(EWOFFSETW::_0XA)
            }
            #[doc = "16384 clock cycles"]
            #[inline(always)]
            pub fn _0x_b(self) -> &'a mut W {
                self.variant(EWOFFSETW::_0XB)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:3 - Early Warning Interrupt Time Offset"]
            #[inline(always)]
            pub fn ewoffset(&self) -> EWOFFSETR {
                EWOFFSETR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 11 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Early Warning Interrupt Time Offset"]
            #[inline(always)]
            pub fn ewoffset(&mut self) -> _EWOFFSETW {
                _EWOFFSETW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EWR {
            bits: bool,
        }
        impl EWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EWW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Early Warning Interrupt Enable"]
            #[inline(always)]
            pub fn ew(&self) -> EWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EWR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Early Warning Interrupt Enable"]
            #[inline(always)]
            pub fn ew(&mut self) -> _EWW {
                _EWW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EWR {
            bits: bool,
        }
        impl EWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EWW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Early Warning Interrupt Enable"]
            #[inline(always)]
            pub fn ew(&self) -> EWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EWR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Early Warning Interrupt Enable"]
            #[inline(always)]
            pub fn ew(&mut self) -> _EWW {
                _EWW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EWR {
            bits: bool,
        }
        impl EWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EWW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Early Warning"]
            #[inline(always)]
            pub fn ew(&self) -> EWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EWR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Early Warning"]
            #[inline(always)]
            pub fn ew(&mut self) -> _EWW {
                _EWW { w: self }
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 7 - Synchronization Busy"]
            #[inline(always)]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCBUSYR { bits }
            }
        }
    }
}
#[doc = "Watchdog Timer"]
pub struct WDT {
    register_block: wdt::RegisterBlock,
}
impl Deref for WDT {
    type Target = wdt::RegisterBlock;
    fn deref(&self) -> &wdt::RegisterBlock {
        &self.register_block
    }
}
#[doc = r" All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals<'a> {
    #[doc = "CPUID"]
    pub CPUID: &'a CPUID,
    #[doc = "DCB"]
    pub DCB: &'a DCB,
    #[doc = "DWT"]
    pub DWT: &'a DWT,
    #[doc = "FPB"]
    pub FPB: &'a FPB,
    #[doc = "FPU"]
    pub FPU: &'a FPU,
    #[doc = "ITM"]
    pub ITM: &'a ITM,
    #[doc = "MPU"]
    pub MPU: &'a MPU,
    #[doc = "NVIC"]
    pub NVIC: &'a NVIC,
    #[doc = "SCB"]
    pub SCB: &'a SCB,
    #[doc = "SYST"]
    pub SYST: &'a SYST,
    #[doc = "TPIU"]
    pub TPIU: &'a TPIU,
    #[doc = "AC"]
    pub AC: &'a AC,
    #[doc = "ADC"]
    pub ADC: &'a ADC,
    #[doc = "DAC"]
    pub DAC: &'a DAC,
    #[doc = "DMAC"]
    pub DMAC: &'a DMAC,
    #[doc = "DSU"]
    pub DSU: &'a DSU,
    #[doc = "EIC"]
    pub EIC: &'a EIC,
    #[doc = "EVSYS"]
    pub EVSYS: &'a EVSYS,
    #[doc = "GCLK"]
    pub GCLK: &'a GCLK,
    #[doc = "I2S"]
    pub I2S: &'a I2S,
    #[doc = "MTB"]
    pub MTB: &'a MTB,
    #[doc = "NVMCTRL"]
    pub NVMCTRL: &'a NVMCTRL,
    #[doc = "PAC0"]
    pub PAC0: &'a PAC0,
    #[doc = "PAC1"]
    pub PAC1: &'a PAC1,
    #[doc = "PAC2"]
    pub PAC2: &'a PAC2,
    #[doc = "PM"]
    pub PM: &'a PM,
    #[doc = "PORT"]
    pub PORT: &'a PORT,
    #[doc = "SYSCTRL"]
    pub SYSCTRL: &'a SYSCTRL,
    #[doc = "TCC0"]
    pub TCC0: &'a TCC0,
    #[doc = "TCC1"]
    pub TCC1: &'a TCC1,
    #[doc = "TCC2"]
    pub TCC2: &'a TCC2,
    #[doc = "WDT"]
    pub WDT: &'a WDT,
}
impl<'a> Peripherals<'a> {
    #[doc = r" Grants access to all the peripherals"]
    pub unsafe fn all() -> Self {
        Peripherals {
            CPUID: &*CPUID.get(),
            DCB: &*DCB.get(),
            DWT: &*DWT.get(),
            FPB: &*FPB.get(),
            FPU: &*FPU.get(),
            ITM: &*ITM.get(),
            MPU: &*MPU.get(),
            NVIC: &*NVIC.get(),
            SCB: &*SCB.get(),
            SYST: &*SYST.get(),
            TPIU: &*TPIU.get(),
            AC: &*AC.get(),
            ADC: &*ADC.get(),
            DAC: &*DAC.get(),
            DMAC: &*DMAC.get(),
            DSU: &*DSU.get(),
            EIC: &*EIC.get(),
            EVSYS: &*EVSYS.get(),
            GCLK: &*GCLK.get(),
            I2S: &*I2S.get(),
            MTB: &*MTB.get(),
            NVMCTRL: &*NVMCTRL.get(),
            PAC0: &*PAC0.get(),
            PAC1: &*PAC1.get(),
            PAC2: &*PAC2.get(),
            PM: &*PM.get(),
            PORT: &*PORT.get(),
            SYSCTRL: &*SYSCTRL.get(),
            TCC0: &*TCC0.get(),
            TCC1: &*TCC1.get(),
            TCC2: &*TCC2.get(),
            WDT: &*WDT.get(),
        }
    }
}
